<!--{
    "Title": "实效Go编程",
    "Template": true
}-->

<!--{
	"Title": "Effective Go",
	"Template": true
}-->

<div class="english">
<h2 id="introduction">Introduction</h2>
</div>

<h2 id="前言">前言</h2>

<div class="english">
<p>
Go is a new language.  Although it borrows ideas from
existing languages,
it has unusual properties that make effective Go programs
different in character from programs written in its relatives.
A straightforward translation of a C++ or Java program into Go
is unlikely to produce a satisfactory result&mdash;Java programs
are written in Java, not Go.
On the other hand, thinking about the problem from a Go
perspective could produce a successful but quite different
program.
In other words,
to write Go well, it's important to understand its properties
and idioms.
It's also important to know the established conventions for
programming in Go, such as naming, formatting, program
construction, and so on, so that programs you write
will be easy for other Go programmers to understand.
</p>
</div>

<p>
Go是一门全新的语言。尽管它从已有的语言中借鉴了一些理念，但其与众不同的特性，
使得实际的Go程序不同于用其它语言编写的程序。
将C++或Java程序直译为Go并不能产生满意的结果——毕竟Java程序是用Java编写的，而不是Go。
另一方面，如果从Go的角度来考虑问题，你将能写出同样成功但却不一样的程序。换句话说，
要想将Go程序写得好，就必须理解其特性和风格。了解其既定的规则也同样重要，
例如命名、格式化以及程序结构等等，这样你编写的程序才能更容易被其他程序员所理解。
</p>

<div class="english">
<p>
This document gives tips for writing clear, idiomatic Go code.
It augments the <a href="/ref/spec">language specification</a>,
the <a href="http://tour.golang.org/">Tour of Go</a>,
and <a href="/doc/code.html">How to Write Go Code</a>,
all of which you
should read first.
</p>
</div>

<p>
本文档就如何编写清晰、地道的Go代码提供了一些技巧。它是对<a href="/ref/spec">语言规范</a>，
<a href="https://go-tour-zh.appspot.com/">Go语言之旅</a>以及<a href="/doc/code.html">如何使用Go编程</a>的补充，
在阅读本文档之前，你应该先阅读这些文档。
</p>

<div class="english">
<h3 id="examples">Examples</h3>
</div>

<h3 id="示例">示例</h3>

<div class="english">
<p>
The <a href="/src/pkg/">Go package sources</a>
are intended to serve not
only as the core library but also as examples of how to
use the language.
If you have a question about how to approach a problem or how something
might be implemented, they can provide answers, ideas and
background.
</p>
</div>

<p>
<a href="/src/pkg/">Go包的源码</a>不仅是核心库，同时还是如何使用这门语言的示例源码。
如果你有关于某些问题如何解决，或某些东西如何实现疑问，它们可以提供相关的答案、思路和背景。
</p>


<div class="english">
<h2 id="formatting">Formatting</h2>
</div>

<h2 id="格式化">格式化</h2>

<div class="english">
<p>
Formatting issues are the most contentious
but the least consequential.
People can adapt to different formatting styles
but it's better if they don't have to, and
less time is devoted to the topic
if everyone adheres to the same style.
The problem is how to approach this Utopia without a long
prescriptive style guide.
</p>
</div>

<p>
格式化的问题总是充满争议，但却很难争论出结果来。虽然大家可以采用不同的格式化风格，
但最好别这么做。假如所有人都遵循相同的风格，花在这类问题上的时间将会更少。
问题就在于如何实现这个设想，而不需要冗长的风格规范。
</p>

<div class="english">
<p>
With Go we take an unusual
approach and let the machine
take care of most formatting issues.
The <code>gofmt</code> program
(also available as <code>go fmt</code>, which
operates at the package level rather than source file level)
reads a Go program
and emits the source in a standard style of indentation
and vertical alignment, retaining and if necessary
reformatting comments.
If you want to know how to handle some new layout
situation, run <code>gofmt</code>; if the answer doesn't
seem right, rearrange your program (or file a bug about <code>gofmt</code>),
don't work around it.
</p>
</div>

<p>
在Go中我们使用了一种特别的方法，即让机器来处理大部分的格式化问题。<code>gofmt</code>
程序（也可使用 <code>go fmt</code>，它在包的级别上而非源文件的级别上进行操作）
读取Go程序并按照缩进和对齐的标准风格生成源码，保留并在需要时重新格式化注释。
如果你想知道如何处理一些新的布局情况，请运行 <code>gofmt</code>；如果结果看起来不太对，
请重新调整你的程序（或提交一个关于 <code>gofmt</code> 的Bug），而不要自己去修改它。
</p>

<div class="english">
<p>
As an example, there's no need to spend time lining up
the comments on the fields of a structure.
<code>Gofmt</code> will do that for you.  Given the
declaration
</p>
</div>

<p>
举例来说，对于结构中字段的注释，并不需要花时间将它们对齐，<code>gofmt</code>
会为你做这些事。对于给定的声明
</p>

<div class="english">
<pre>
type T struct {
    name string // name of the object
    value int // its value
}
</pre>
</div>

<pre>
type T struct {
    name string // 对象的名字
    value int // 它的值
}
</pre>

<div class="english">
<p>
<code>gofmt</code> will line up the columns:
</p>
</div>

<p>
<code>gofmt</code> 会按列对齐为：
</p>

<div class="english">
<pre>
type T struct {
    name    string // name of the object
    value   int    // its value
}
</pre>
</div>

<pre>
type T struct {
    name    string // 对象的名字
    value   int    // 它的值
}
</pre>

<div class="english">
<p>
All Go code in the standard packages has been formatted with <code>gofmt</code>.
</p>
</div>

<p>
标准包中的所有Go代码都已经使用 <code>gofmt</code> 格式化过了。
</p>


<div class="english">
<p>
Some formatting details remain.  Very briefly,
</p>
</div>

<p>
还有一些格式化的详细说明，这些都非常简单明了：
</p>

<div class="english">
<dl>
    <dt>Indentation</dt>
    <dd>We use tabs for indentation and <code>gofmt</code> emits them by default.
    Use spaces only if you must.
    </dd>
    <dt>Line length</dt>
    <dd>
    Go has no line length limit.  Don't worry about overflowing a punched card.
    If a line feels too long, wrap it and indent with an extra tab.
    </dd>
    <dt>Parentheses</dt>
    <dd>
    Go needs fewer parentheses: control structures (<code>if</code>,
    <code>for</code>, <code>switch</code>) do not have parentheses in
    their syntax.
    Also, the operator precedence hierarchy is shorter and clearer, so
<pre>
x&lt;&lt;8 + y&lt;&lt;16
</pre>
    means what the spacing implies.
    </dd>
</dl>
</div>

<dl>
    <dt>缩进</dt>
    <dd>
    我们使用制表符（tab）缩进，<code>gofmt</code> 默认也使用它。当然你也可以特意使用空格。
    </dd>
    <dt>行的长度</dt>
    <dd>
    Go没有行的长度限制。不要担心代码会在穿孔卡片上溢出。如果一行实在太长，
    可以进行折行并使用一个额外的制表符将其缩进。
    </dd>
    <dt>圆括号</dt>
    <dd>
    Go很少需要括号：控制结构（<code>if</code>、<code>for</code> 和 <code>switch</code>）
    在语法上不需要圆括号。此外，操作符优先级将变得更加简短而清楚，因此
<pre>
x&lt;&lt;8 + y&lt;&lt;16
</pre>
    所表达的意思与其中空格所暗示的一样。
    </dd>
</dl>

<div class="english">
<h2 id="commentary">Commentary</h2>
</div>

<h2 id="注释">注释</h2>

<div class="english">
<p>
Go provides C-style <code>/* */</code> block comments
and C++-style <code>//</code> line comments.
Line comments are the norm;
block comments appear mostly as package comments and
are also useful to disable large swaths of code.
</p>
</div>

<p>
Go提供C风格的 <code>/* */</code> 块注释和C++风格的 <code>//</code> 行注释。
行注释作为标准，而块注释则主要用作包的注释，当然也可在禁用一大段代码时使用。
</p>

<div class="english">
<p>
The program—and web server—<code>godoc</code> processes
Go source files to extract documentation about the contents of the
package.
Comments that appear before top-level declarations, with no intervening newlines,
are extracted along with the declaration to serve as explanatory text for the item.
The nature and style of these comments determines the
quality of the documentation <code>godoc</code> produces.
</p>
</div>

<p>
<code>godoc</code> 既是一个程序，又是一个Web服务器，它对Go的源码进行处理，并提取包中的文档内容。
出现在顶级声明之前且中间没有新行的注释，将与该声明一起被提取出来，作为该项的解释性文本。
这些注释的内容和样式决定了 <code>godoc</code> 生成的文档质量。
</p>

<div class="english">
<p>
Every package should have a <i>package comment</i>, a block
comment preceding the package clause.
For multi-file packages, the package comment only needs to be
present in one file, and any one will do.
The package comment should introduce the package and
provide information relevant to the package as a whole.
It will appear first on the <code>godoc</code> page and
should set up the detailed documentation that follows.
</p>
</div>

<p>
每个包都应该有一个<b>包注释</b>，即放置在包子句前的一个块注释。对于包含多个文件的包，
包注释只需出现在其中的任何一个文件中即可。包注释应在整体上对该包进行介绍，并提供包的相关信息。
它将出现在 <code>godoc</code> 页面中的最上面，并为其下的内容建立详细的文档。
</p>

<div class="english">
<pre>
/*
Package regexp implements a simple library for regular expressions.

The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
</pre>
</div>

<pre>
/*
    regexp 包为正则表达式实现了一个简单的库。

    该正则表达式接受的语法为：

    正则表达式:
        串联 { '|' 串联 }
    串联:
        { 闭包 }
    闭包:
        条目 [ '*' | '+' | '?' ]
    条目:
        '^'
        '$'
        '.'
        字符
        '[' [ '^' ] 字符遍历 ']'
        '(' 正则表达式 ')'
*/
package regexp
</pre>

<div class="english">
<p>
If the package is simple, the package comment can be brief.
</p>
</div>

<p>
如果包很简单，那么该包的注释也可以很简洁。
</p>

<div class="english">
<pre>
// Package path implements utility routines for
// manipulating slash-separated filename paths.
</pre>
</div>

<pre>
// path 包实现了一些常用的工具，以便于操作用反斜杠分隔的路径。
</pre>

<div class="english">
<p>
Comments do not need extra formatting such as banners of stars.
The generated output may not even be presented in a fixed-width font, so don't depend
on spacing for alignment&mdash;<code>godoc</code>, like <code>gofmt</code>,
takes care of that.
The comments are uninterpreted plain text, so HTML and other
annotations such as <code>_this_</code> will reproduce <i>verbatim</i> and should
not be used.
Depending on the context, <code>godoc</code> might not even
reformat comments, so make sure they look good straight up:
use correct spelling, punctuation, and sentence structure,
fold long lines, and so on.
</p>
</div>

<p>
注释无需进行额外的格式化，如用星号来突出等。生成的输出甚至可能无法以等宽字体显示，
因此不要依赖于空格对齐，<code>godoc</code> 和 <code>gofmt</code> 一样，
会自动处理这些文档。注释是不会被解析的纯文本，因此像HTML或其它类似于
<code>_this_</code> 的东西将按照<b>原样</b>输出，因此不应使用它们。根据上下文，
<code>godoc</code> 可能不会重新格式化注释，因此必须保证它们看上去是直白的：
使用正确的拼写、标点和语句结构，折叠长行等等。
</p>

<div class="english">
<p>
Inside a package, any comment immediately preceding a top-level declaration
serves as a <i>doc comment</i> for that declaration.
Every exported (capitalized) name in a program should
have a doc comment.
</p>
</div>

<p>
在包中，任何放在顶级声明前面的注释都将作为该声明的<b>文档注释</b>。
在程序中，每个已导出（首字母大写）的名称都应该有文档注释。
</p>

<div class="english">
<p>
Doc comments work best as complete sentences, which allow
a wide variety of automated presentations.
The first sentence should be a one-sentence summary that
starts with the name being declared.
</p>
</div>

<p>
文档注释最好是完整的句子，这样它就能适用于各种自动化的展示。
第一句应当以被声明的东西开头，并且为一句摘要。
</p>

<div class="english">
<pre>
// Compile parses a regular expression and returns, if successful, a Regexp
// object that can be used to match against text.
func Compile(str string) (regexp *Regexp, err error) {
</pre>
</div>

<pre>
// Compile 用于解析正则表达式并返回，如果成功，则 Regexp 对象就可用于匹配所针对的文本。
func Compile(str string) (regexp *Regexp, err error) {
</pre>

<div class="english">
<p>
Go's declaration syntax allows grouping of declarations.
A single doc comment can introduce a group of related constants or variables.
Since the whole declaration is presented, such a comment can often be perfunctory.
</p>
</div>

<p>
Go的声明语法允许成组声明。单个文档注释可介绍一组相关的常量或变量。
由于是整体声明，这种注释往往是概括性的。
</p>

<div class="english">
<pre>
// Error codes returned by failures to parse an expression.
var (
    ErrInternal      = errors.New("regexp: internal error")
    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
    ...
)
</pre>
</div>

<pre>
// 表达式解析失败后返回错误代码。
var (
    ErrInternal      = errors.New("regexp: internal error")
    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
    ...
)
</pre>

<div class="english">
<p>
Even for private names, grouping can also indicate relationships between items,
such as the fact that a set of variables is protected by a mutex.
</p>
</div>

<p>
即便是对于私有名称，也可通过成组声明来表明项之间的关系，例如实际上由互斥体保护的一组变量。
</p>

<pre>
var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
</pre>

<div class="english">
<h2 id="names">Names</h2>
</div>

<h2 id="命名">命名</h2>

<div class="english">
<p>
Names are as important in Go as in any other language.
In some cases they even have semantic effect: for instance,
the visibility of a name outside a package is determined by whether its
first character is upper case.
It's therefore worth spending a little time talking about naming conventions
in Go programs.
</p>
</div>

<p>
Go中的命名与其它语言中的一样重要。在某些情况下，它们甚至会影响语义：
例如，一个名称在包外的可见性就由其首个字符是否为大写字母来决定。
因此有必要花点时间来讨论Go程序中的命名约定。
</p>

<div class="english">
<h3 id="package-names">Package names</h3>
</div>

<h3 id="包名">包名</h3>

<div class="english">
<p>
When a package is imported, the package name becomes an accessor for the
contents.  After
</p>
</div>

<p>
当一个包被导入时，该包的包名会成为其内容的访问器。在
</p>

<pre>
import "bytes"
</pre>

<div class="english">
<p>
the importing package can talk about <code>bytes.Buffer</code>.  It's
helpful if everyone using the package can use the same name to refer to
its contents, which implies that the package name should be good:
short, concise, evocative.  By convention, packages are given
lower case, single-word names; there should be no need for underscores
or mixedCaps.
Err on the side of brevity, since everyone using your
package will be typing that name.
And don't worry about collisions <i>a priori</i>.
The package name is only the default name for imports; it need not be unique
across all source code, and in the rare case of a collision the
importing package can choose a different name to use locally.
In any case, confusion is rare because the file name in the import
determines just which package is being used.
</p>
</div>

<p>
之后，被导入的包就可以使用 <code>bytes.Buffer</code> 了。
如果所有使用该包的人都以一个相同的名称来引用其内容，那会非常有益，
这也就意味着包应该好好地命名：其名称应该简洁明了而易于理解。按照惯例，
包应当以小写的单个单词来命名，且不应使用下划线或大小写混合。<code>err</code>
的命名就是出于简短考虑的，因为任何使用你的包的人都会键入该名称。
不必担心它会与<b>已有的东西</b>冲突。包名就是导入时所需的唯一默认名称，
它并不需要在所有源码上都是唯一的，即便在少数发生冲突的情况下，
也可为导入的包选择一个不同的名字来局部地使用。
不论如何，由于可通过文件名判定使用的是哪个包，因此不会产生混淆。
</p>

<div class="english">
<p>
Another convention is that the package name is the base name of
its source directory;
the package in <code>src/pkg/encoding/base64</code>
is imported as <code>"encoding/base64"</code> but has name <code>base64</code>,
not <code>encoding_base64</code> and not <code>encodingBase64</code>.
</p>
</div>

<p>
另一个约定就是包名应为其源码目录的基本名称。在 <code>src/pkg/encoding/base64</code>
中的包应作为 <code>"encoding/base64"</code> 导入，其包名应为 <code>base64</code>，
而非 <code>encoding_base64</code> 或 <code>encodingBase64</code>。
</p>

<div class="english">
<p>
The importer of a package will use the name to refer to its contents
(the <code>import .</code> notation is intended mostly for tests and other
unusual situations and should be avoided unless necessary),
so exported names in the package can use that fact
to avoid stutter.
For instance, the buffered reader type in the <code>bufio</code> package is called <code>Reader</code>,
not <code>BufReader</code>, because users see it as <code>bufio.Reader</code>,
which is a clear, concise name.
Moreover,
because imported entities are always addressed with their package name, <code>bufio.Reader</code>
does not conflict with <code>io.Reader</code>.
Similarly, the function to make new instances of <code>ring.Ring</code>&mdash;which
is the definition of a <em>constructor</em> in Go&mdash;would
normally be called <code>NewRing</code>, but since
<code>Ring</code> is the only type exported by the package, and since the
package is called <code>ring</code>, it's called just <code>New</code>,
which clients of the package see as <code>ring.New</code>.
Use the package structure to help you choose good names.
</p>
</div>

<p>
包的导入者会使用该包的包名来引用其内容（<code>import .</code> 往往只用于测试或其它特殊情况，
若非必要，应尽量避免使用），因此包中的已导出名称便可以此来避免冲突。例如，<code>bufio</code>
包中的缓存读取器类型叫做 <code>Reader</code> 而非 <code>BufReader</code>，因为用户看到的其实是
<code>bufio.Reader</code>，这是个清楚而简洁的名称。此外，由于被导入的实体总是通过它们的包名来确定，
因此 <code>bufio.Reader</code> 就不会与 <code>io.Reader</code> 发生冲突。同样，用于创建
<code>ring.Ring</code> 的新实例的函数（这就是Go中的<strong>构造器</strong>）一般会称之为
<code>NewRing</code>，但由于 <code>Ring</code> 是该包所导出的唯一类型，且该包也叫
<code>ring</code>，因此它可以只叫做 <code>New</code>，它跟在包的后面，就像
<code>ring.New</code>。使用包结构可以帮助你选择好的名称。
</p>

<div class="english">
<p>
Another short example is <code>once.Do</code>;
<code>once.Do(setup)</code> reads well and would not be improved by
writing <code>once.DoOrWaitUntilDone(setup)</code>.
Long names don't automatically make things more readable.
If the name represents something intricate or subtle, it's usually better
to write a helpful doc comment than to attempt to put all the information
into the name.
</p>
</div>

<p>
另一个简短的例子是 <code>once.Do</code>。<code>once.Do(setup)</code> 读起来很好，
将它写作 <code>once.DoOrWaitUntilDone(setup)</code> 也不会更好。
长的名称并不会自动让东西变得更有可读性。如果该名称所代表的东西比较复杂而微妙，
通常更好的方法是编写一个有帮助的文档注释，而不是将所有信息都放到名称当中。
</p>

<div class="english">
<h3 id="Getters">Getters</h3>
</div>

<h3 id="获取器">获取器</h3>

<div class="english">
<p>
Go doesn't provide automatic support for getters and setters.
There's nothing wrong with providing getters and setters yourself,
and it's often appropriate to do so, but it's neither idiomatic nor necessary
to put <code>Get</code> into the getter's name.  If you have a field called
<code>owner</code> (lower case, unexported), the getter method should be
called <code>Owner</code> (upper case, exported), not <code>GetOwner</code>.
The use of upper-case names for export provides the hook to discriminate
the field from the method.
A setter function, if needed, will likely be called <code>SetOwner</code>.
Both names read well in practice:
</p>
</div>

<p>
Go并不对获取器（getter）和设置器（setter）提供自动的支持。如果你要自己提供获取器和设置器，
这并没有什么不对，而且往往是很恰当的。但要将 <code>Get</code> 放到获取器的名字中，
既不符合习惯，也没有必要。如果你拥有一个称之为 <code>owner</code> （小写，未导出）的字段，
那么该获取器的方法应称为 <code>Owner</code>（大写，已导出）而非 <code>GetOwner</code>。
使用大写字母名称来进行导出提供了一种挂钩，以将字段和方法区别开来。如果需要，
一个设置器函数也应类似于 <code>SetOwner</code>。两种名称在实践中读起来都很好。
</p>

<pre>
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
</pre>

<div class="english">
<h3 id="interface-names">Interface names</h3>
</div>

<h3 id="接口名">接口名</h3>

<div class="english">
<p>
By convention, one-method interfaces are named by
the method name plus the -er suffix: <code>Reader</code>,
<code>Writer</code>, <code>Formatter</code> etc.
</p>
</div>

<p>
按照约定，单方法的接口应以该方法的名称加上-er后缀来命名，如 <code>Reader</code>、
<code>Writer</code>、<code>Formatter</code> 等。
</p>

<div class="english">
<p>
There are a number of such names and it's productive to honor them and the function
names they capture.
<code>Read</code>, <code>Write</code>, <code>Close</code>, <code>Flush</code>,
<code>String</code> and so on have
canonical signatures and meanings.  To avoid confusion,
don't give your method one of those names unless it
has the same signature and meaning.
Conversely, if your type implements a method with the
same meaning as a method on a well-known type,
give it the same name and signature;
call your string-converter method <code>String</code> not <code>ToString</code>.
</p>
</div>

<p>
这类的名称有很多，用这种方法来表示它们自身以及它们所代表的函数名是非常有用的。
<code>Read</code>、<code>Write</code>、<code>Close</code>、<code>Flush</code>、<code>String</code>
等都具有典型的签名和意义。为避免混淆，你的方法请不要使用这些名称，除非它们拥有相同的签名和意义。
相反地，如果你的类型实现了一个与这些知名的类型具有相同意义的方法，请保持它们的名称和签名相同，
请将你的字符串转换方法称为 <code>String</code> 而非 <code>ToString</code>。
</p>

<div class="english">
<h3 id="mixed-caps">MixedCaps</h3>
</div>

<h3 id="混合大小写">混合大小写</h3>

<div class="english">
<p>
Finally, the convention in Go is to use <code>MixedCaps</code>
or <code>mixedCaps</code> rather than underscores to write
multiword names.
</p>
</div>

<p>
最后，Go中约定使用 <code>MixedCaps</code> 或 <code>mixedCaps</code> 的大小写混合形式，
而非下划线来写多单词名称。
</p>

<div class="english">
<h2 id="semicolons">Semicolons</h2>
</div>

<h2 id="分号">分号</h2>

<div class="english">
<p>
Like C, Go's formal grammar uses semicolons to terminate statements;
unlike C, those semicolons do not appear in the source.
Instead the lexer uses a simple rule to insert semicolons automatically
as it scans, so the input text is mostly free of them.
</p>
</div>

<p>
和C一样，Go的正式语法使用分号来终止语句；和C不同的是，这些分号并不在源码中出现。
取而代之，词法分析器在扫描时会使用一条简单的规则来自动插入分号，因此输入的文本基本上就不用它们了。
</p>

<div class="english">
<p>
The rule is this. If the last token before a newline is an identifier
(which includes words like <code>int</code> and <code>float64</code>),
a basic literal such as a number or string constant, or one of the
tokens
</p>
</div>

<p>
规则是这样的：若在新行前的最后一个标记为标识符（包括 <code>int</code> 和
<code>float64</code> 这类的单词）、数值或字符串常量之类的基本字面或以下标记之一
</p>

<pre>
break continue fallthrough return ++ -- ) }
</pre>

<div class="english">
<p>
the lexer always inserts a semicolon after the token.
This could be summarized as, &ldquo;if the newline comes
after a token that could end a statement, insert a semicolon&rdquo;.
</p>
</div>

<p>
则词法分析将始终在该标记后面插入分号。这点可以概括为：
“如果新行前的标记为语句的末尾，则插入分号”。
</p>

<div class="english">
<p>
A semicolon can also be omitted immediately before a closing brace,
so a statement such as
</p>
</div>

<p>
分号也可在闭括号之前直接省略，因此像
</p>

<pre>
    go func() { for { dst &lt;- &lt;-src } }()
</pre>

<div class="english">
<p>
needs no semicolons.
Idiomatic Go programs have semicolons only in places such as
<code>for</code> loop clauses, to separate the initializer, condition, and
continuation elements.  They are also necessary to separate multiple
statements on a line, should you write code that way.
</p>
</div>

<p>
这样的语句无需分号。通常Go程序只在诸如 <code>for</code> 循环子句这样的地方使用分号，
以此来将初始化器、条件及增量元素分开。如果你在一行中写多个语句，也需要用分号隔开。
</p>

<div class="english">
<p>
One caveat. You should never put the opening brace of a
control structure (<code>if</code>, <code>for</code>, <code>switch</code>,
or <code>select</code>) on the next line.  If you do, a semicolon
will be inserted before the brace, which could cause unwanted
effects.  Write them like this
</p>
</div>

<p>
警告：无论如何，你都不应将一个控制结构（<code>if</code>、<code>for</code>、<code>switch</code>
或 <code>select</code>）的左大括号放在下一行。如果这样做，就会在大括号的前方插入一个分号，这可能引起不需要的效果。
你应该这样写
</p>

<div class="english">
<pre>
if i &lt; f() {
    g()
}
</pre>
<p>
not like this
</p>
<pre>
if i &lt; f()  // wrong!
{           // wrong!
    g()
}
</pre>
</div>

<pre>
if i &lt; f() {
    g()
}
</pre>
<p>
而不是这样
</p>
<pre>
if i &lt; f()  // 错！
{           // 错！
    g()
}
</pre>


<div class="english">
<h2 id="control-structures">Control structures</h2>
</div>

<h2 id="控制结构">控制结构</h2>

<div class="english">
<p>
The control structures of Go are related to those of C but differ
in important ways.
There is no <code>do</code> or <code>while</code> loop, only a
slightly generalized
<code>for</code>;
<code>switch</code> is more flexible;
<code>if</code> and <code>switch</code> accept an optional
initialization statement like that of <code>for</code>;
and there are new control structures including a type switch and a
multiway communications multiplexer, <code>select</code>.
The syntax is also slightly different:
there are no parentheses
and the bodies must always be brace-delimited.
</p>
</div>

<p>
Go的控制语句虽然和C有关，但在一些重要的方面又有所不同。其中没有 <code>do</code>
或 <code>while</code> 循环，只有一个更广义的 <code>for</code> 循环；<code>switch</code>
要更灵活一点；<code>if</code> 和 <code>switch</code> 像 <code>for</code>一样可接受可选的初始化语句；
此外，还有一个包含类型选择和多路通信复用器的新控制结构：<code>select</code>。
其语法也有些许不同：没有圆括号，而其主体必须始终使用大括号括住。
</p>

<h3 id="if">If</h3>

<div class="english">
<p>
In Go a simple <code>if</code> looks like this:
</p>
</div>

<p>
在Go中，一个简单的 <code>if</code> 语句看起来像这样：
</p>

<pre>
if x &gt; 0 {
    return y
}
</pre>

<div class="english">
<p>
Mandatory braces encourage writing simple <code>if</code> statements
on multiple lines.  It's good style to do so anyway,
especially when the body contains a control statement such as a
<code>return</code> or <code>break</code>.
</p>
</div>

<p>
强制的大括号鼓励编写简单的多行 <code>if</code> 语句。总之，这是一种好的风格，
特别是在主体包含诸如 <code>return</code> 或 <code>break</code> 这样的控制语句时。
</p>

<div class="english">
<p>
Since <code>if</code> and <code>switch</code> accept an initialization
statement, it's common to see one used to set up a local variable.
</p>
</div>

<p>
由于 <code>if</code> 和 <code>switch</code> 接受初始化与局，因此经常可以看到它们被用于创建局部变量。
</p>

<pre>
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
</pre>

<div class="english">
<p id="else">
In the Go libraries, you'll find that
when an <code>if</code> statement doesn't flow into the next statement—that is,
the body ends in <code>break</code>, <code>continue</code>,
<code>goto</code>, or <code>return</code>—the unnecessary
<code>else</code> is omitted.
</p>
</div>

<p id="else">
在Go的库中，你会发现当 <code>if</code> 语句不会执行到下一句时——也就是说，
其主体以 <code>break</code>、<code>continue</code>、<code>goto</code> 或
<code>return</code> 结束——不必要的 <code>else</code> 会被省略。
</p>

<pre>
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
</pre>

<div class="english">
<p>
This is an example of a common situation where code must guard against a
sequence of error conditions.  The code reads well if the
successful flow of control runs down the page, eliminating error cases
as they arise.  Since error cases tend to end in <code>return</code>
statements, the resulting code needs no <code>else</code> statements.
</p>
</div>

<p>
以下为代码必须防止一系列错误条件的例子。如果控制流程成功地向下运行，
在排除错误的情况下，代码读起来很好。由于错误情况常在 <code>return</code>
语句中终止，最终代码也就无需 <code>else</code> 语句了。
</p>

<pre>
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
</pre>


<div class="english">
<h3 id="redeclaration">Redeclaration</h3>
</div>

<h3 id="重复声明">重复声明</h3>

<div class="english">
<p>
An aside: The last example in the previous section demonstrates a detail of how the
<code>:=</code> short declaration form works.
The declaration that calls <code>os.Open</code> reads,
</p>
</div>

<p>
顺便说一下：上一节中的最后一个例子展示了短声明形式 <code>:=</code> 的详细工作方式。
调用了 <code>os.Open</code> 的声明语句为
</p>

<pre>
f, err := os.Open(name)
</pre>

<div class="english">
<p>
This statement declares two variables, <code>f</code> and <code>err</code>.
A few lines later, the call to <code>f.Stat</code> reads,
</p>
</div>

<p>
该语句声明了两个变量 <code>f</code> 与 <code>err</code>。在几行之后，又通过以下语句调用了 <code>f.Stat</code>
</p>

<pre>
d, err := f.Stat()
</pre>

<div class="english">
<p>
which looks as if it declares <code>d</code> and <code>err</code>.
Notice, though, that <code>err</code> appears in both statements.
This duplication is legal: <code>err</code> is declared by the first statement,
but only <em>re-assigned</em> in the second.
This means that the call to <code>f.Stat</code> uses the existing
<code>err</code> variable declared above, and just gives it a new value.
</p>
</div>

<p>
该语句看起来是声明了 <code>d</code> 和 <code>err</code>。注意，在两个语句中都出现了
<code>err</code>。这种重复是合法的：<code>err</code> 在第一个语句中被声明，
而在第二个语句中只是被<em>重新赋值</em>了。这意味着对 <code>f.Stat</code>
的调用使用的是前面已声明的 <code>err</code> 变量，这里只是给它一个新的值而已。
</p>

<div class="english">
<p>
In a <code>:=</code> declaration a variable <code>v</code> may appear even
if it has already been declared, provided:
</p>
</div>

<p>
在满足以下条件时，变量 <code>v</code> 可出现在 <code>:=</code> 声明中，即使该变量已被声明：
</p>

<div class="english">
<ul>
<li>this declaration is in the same scope as the existing declaration of <code>v</code>
(if <code>v</code> is already declared in an outer scope, the declaration will create a new variable),</li>
<li>the corresponding value in the initialization is assignable to <code>v</code>, and</li>
<li>there is at least one other variable in the declaration that is being declared anew.</li>
</ul>
</div>

<ul>
<li>该声明的作用域与已存在的 <code>v</code> 的声明作用域相同（若 <code>v</code>
已在外层的作用域中声明，则会创建一个新的变量），</li>
<li>在初始化中相应类型的值才能赋予 <code>v</code>，并且</li>
<li>在声明中至少有另一个变量是新声明的。</li>
</ul>

<div class="english">
<p>
This unusual property is pure pragmatism,
making it easy to use a single <code>err</code> value, for example,
in a long <code>if-else</code> chain.
You'll see it used often.
</p>
</div>

<p>
这种不寻常的特性纯粹是出于实用主义，这使我们可以很方便地只使用一个 <code>err</code>
值，比如说在一个长的 <code>if-else</code> 链中。
</p>

<h3 id="for">For</h3>

<div class="english">
<p>
The Go <code>for</code> loop is similar to&mdash;but not the same as&mdash;C's.
It unifies <code>for</code>
and <code>while</code> and there is no <code>do-while</code>.
There are three forms, only one of which has semicolons.
</p>
</div>

<p>
Go的 <code>for</code> 循环与C的相似却不相同。它统一了 <code>for</code> 和 <code>while</code>，
因此也就不再有 <code>do-while</code> 了。它有三种形式，但只有一种需要分号。
</p>

<div class="english">
<pre>
// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
</pre>
</div>

<pre>
// 如同C的for循环
for init; condition; post { }

// 如同C的while循环
for condition { }

// 如同C的for(;;)循环
for { }
</pre>

<div class="english">
<p>
Short declarations make it easy to declare the index variable right in the loop.
</p>
</div>

<p>
使用简短声明能更够更容易地在循环中声明下表变量。
</p>

<pre>
sum := 0
for i := 0; i &lt; 10; i++ {
    sum += i
}
</pre>

<div class="english">
<p>
If you're looping over an array, slice, string, or map,
or reading from a channel, a <code>range</code> clause can
manage the loop.
</p>
</div>

<p>
若你是在一个数组、切片、字符串或映射中循环遍历，或从一个信道中读取的话，可使用一个
<code>range</code> 子句来管理循环。
</p>

<pre>
for key, value := range oldMap {
    newMap[key] = value
}
</pre>

<div class="english">
<p>
If you only need the first item in the range (the key or index), drop the second:
</p>
</div>

<p>
如果你只需要该遍历中的第一个项（键或下标），去掉第二个就行了：
</p>

<pre>
for key := range m {
    if expired(key) {
        delete(m, key)
    }
}
</pre>

<div class="english">
<p>
If you only need the second item in the range (the value), use the <em>blank identifier</em>, an underscore, to discard the first:
</p>
</div>

<p>
如果你只需要该遍历中的第二个项（值），请使用<em>空白标识符</em>，即一个下划线来丢弃第一个：
</p>

<pre>
sum := 0
for _, value := range array {
    sum += value
}
</pre>

<div class="english">
<p>
For strings, the <code>range</code> does more work for you, breaking out individual
Unicode characters by parsing the UTF-8.
Erroneous encodings consume one byte and produce the
replacement rune U+FFFD. The loop
</p>
</div>

<p>
对于字符串，<code>range</code> 能为你做更多的工作，它能通过解析UTF-8来分离单个的Unicode字符。
占用一个字节的错误编码以字符U+FFFD来代替。以下循环
</p>

<pre>
for pos, char := range "日本語" {
    fmt.Printf("character %c starts at byte position %d\n", char, pos)
}
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
将打印
</p>

<pre>
character 日 starts at byte position 0
character 本 starts at byte position 3
character 語 starts at byte position 6
</pre>

<pre>
for pos, char := range "日本語" {
    fmt.Printf("字符 %c 起始于字节位置 %d\n", char, pos)
}
</pre>

<div class="english">
<p>
Finally, Go has no comma operator and <code>++</code> and <code>--</code>
are statements not expressions.
Thus if you want to run multiple variables in a <code>for</code>
you should use parallel assignment.
</p>
<pre>
// Reverse a
for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
</pre>
</div>

<p>
最后，Go没有逗号操作符，而 <code>++</code> 和 <code>--</code> 为语句而非表达式。
因此如果你想要在 <code>for</code> 中使用多变量，就应该使用并列赋值。
</p>

<pre>
// 反转a
for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
</pre>

<h3 id="switch">Switch</h3>

<div class="english">
<p>
Go's <code>switch</code> is more general than C's.
The expressions need not be constants or even integers,
the cases are evaluated top to bottom until a match is found,
and if the <code>switch</code> has no expression it switches on
<code>true</code>.
It's therefore possible&mdash;and idiomatic&mdash;to write an
<code>if</code>-<code>else</code>-<code>if</code>-<code>else</code>
chain as a <code>switch</code>.
</p>
</div>

<p>
Go的 <code>switch</code> 比C的更通用。其表达式无需为常量或整数，它会自上而下地对每种情况进行求值，
直到发现一个匹配的为止，若 <code>switch</code> 后面没有表达式，它将匹配 <code>true</code>。
因此也可以——且习惯于将 <code>if</code>-<code>else</code>-<code>if</code>-<code>else</code>
链写成一个 <code>switch</code>。
</p>

<pre>
func unhex(c byte) byte {
    switch {
    case '0' &lt;= c &amp;&amp; c &lt;= '9':
        return c - '0'
    case 'a' &lt;= c &amp;&amp; c &lt;= 'f':
        return c - 'a' + 10
    case 'A' &lt;= c &amp;&amp; c &lt;= 'F':
        return c - 'A' + 10
    }
    return 0
}
</pre>

<div class="english">
<p>
There is no automatic fall through, but cases can be presented
in comma-separated lists.
</p>
</div>

<p>
switch并不会自动贯穿，但多个分支可通过逗号分隔的列表来呈现。
</p>

<pre>
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&amp;', '=', '#', '+', '%':
        return true
    }
    return false
}
</pre>

<div class="english">
<p>
Here's a comparison routine for byte slices that uses two
<code>switch</code> statements:
</p>
<pre>
// Compare returns an integer comparing the two byte slices,
// lexicographically.
// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b
func Compare(a, b []byte) int {
    for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ {
        switch {
        case a[i] &gt; b[i]:
            return 1
        case a[i] &lt; b[i]:
            return -1
        }
    }
    switch {
    case len(a) &lt; len(b):
        return -1
    case len(a) &gt; len(b):
        return 1
    }
    return 0
}
</pre>
</div>

<p>
以下程序通过使用两个 <code>switch</code> 语句对字节数组进行比较：
</p>
<pre>
// Compare按照字典顺序比较两个字节数组并返回一个整数，若a == b则结果为0，
// 若a &lt; b则结果为-1，若a &gt; b则结果为1
func Compare(a, b []byte) int {
    for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ {
        switch {
        case a[i] &gt; b[i]:
            return 1
        case a[i] &lt; b[i]:
            return -1
        }
    }
    switch {
    case len(a) &lt; len(b):
        return -1
    case len(a) &gt; len(b):
        return 1
    }
    return 0
}
</pre>

<div class="english">
<p>
A switch can also be used to discover the dynamic type of an interface
variable.  Such a <em>type switch</em> uses the syntax of a type
assertion with the keyword <code>type</code> inside the parentheses.
If the switch declares a variable in the expression, the variable will
have the corresponding type in each clause.
</p>
</div>

<p>
switch也可用于获取接口变量的动态类型。如<em>类型选择</em>通过圆括号中的关键字
<code>type</code> 使用类型断言语法。若switch在表达式中声明了一个变量，
在每个自己种都将有该变量对应的类型。
</p>

<pre>
switch t := interfaceValue.(type) {
default:
    fmt.Printf("unexpected type %T", t)  // %T prints type
case bool:
    fmt.Printf("boolean %t\n", t)
case int:
    fmt.Printf("integer %d\n", t)
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t)
case *int:
    fmt.Printf("pointer to integer %d\n", *t)
}
</pre>

<div class="english">
<h2 id="functions">Functions</h2>
</div>

<h2 id="函数">函数</h2>

<div class="english">
<h3 id="multiple-returns">Multiple return values</h3>
</div>

<h3 id="多返回值">多返回值</h3>

<div class="english">
<p>
One of Go's unusual features is that functions and methods
can return multiple values.  This form can be used to
improve on a couple of clumsy idioms in C programs: in-band
error returns (such as <code>-1</code> for <code>EOF</code>)
and modifying an argument.
</p>
</div>

<p>
Go的一个不寻常的特性就是函数和方法可返回多个值。这种形式可用于改善C程序中一对笨拙的习惯：
带内错误返回（例如用 <code>-1</code> 代表 <code>EOF</code>）以及修改实参。
</p>

<div class="english">
<p>
In C, a write error is signaled by a negative count with the
error code secreted away in a volatile location.
In Go, <code>Write</code>
can return a count <i>and</i> an error: &ldquo;Yes, you wrote some
bytes but not all of them because you filled the device&rdquo;.
The signature of <code>File.Write</code> in package <code>os</code> is:
</p>
</div>

<p>
在C中，写入操作的错误通过一个负数进行标记，该错误代码隐藏在一个不确定的位置。
在Go中，<code>Write</code> 可以返回一个计数<i>和</i>一个错误：
“是的，您写入了一些字节，但并没有全部写入，因为设备已满”。
在 <code>os</code> 包中，<code>File.Write</code> 的签名为：
</p>

<pre>
func (file *File) Write(b []byte) (n int, err error)
</pre>

<div class="english">
<p>
and as the documentation says, it returns the number of bytes
written and a non-nil <code>error</code> when <code>n</code>
<code>!=</code> <code>len(b)</code>.
This is a common style; see the section on error handling for more examples.
</p>
</div>

<p>
如文档所述，当 <code>n</code> <code>!=</code> <code>len(b)</code>
时，它返回被写入的字节数与一个非nil的 <code>error</code>。这是一种常用的方式，
更多示例见错误处理一节。
</p>

<div class="english">
<p>
A similar approach obviates the need to pass a pointer to a return
value to simulate a reference parameter.
Here's a simple-minded function to
grab a number from a position in a byte slice, returning the number
and the next position.
</p>
</div>

<p>
类似的方法无需再将一个指针传至返回值来模拟引用形参。
以下简单的函数可从字节数组中的特定位置获取一个数，它返回该数值和下一个位置。
</p>

<pre>
func nextInt(b []byte, i int) (int, int) {
    for ; i &lt; len(b) &amp;&amp; !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i &lt; len(b) &amp;&amp; isDigit(b[i]); i++ {
        x = x*10 + int(b[i])-'0'
    }
    return x, i
}
</pre>

<div class="english">
<p>
You could use it to scan the numbers in an input slice <code>b</code> like this:
</p>
</div>

<p>
你可以使用它从一个输入的数组 <code>a</code> 中扫描获取数字，就像这样：
</p>

<pre>
    for i := 0; i &lt; len(b); {
        x, i = nextInt(b, i)
        fmt.Println(x)
    }
</pre>

<div class="english">
<h3 id="named-results">Named result parameters</h3>
</div>

<h3 id="带名称结果">带名称的结果形参</h3>

<div class="english">
<p>
The return or result "parameters" of a Go function can be given names and
used as regular variables, just like the incoming parameters.
When named, they are initialized to the zero values for their types when
the function begins; if the function executes a <code>return</code> statement
with no arguments, the current values of the result parameters are
used as the returned values.
</p>
</div>

<p>
Go函数的返回值或结果“形参”可给定名称并像常规变量那样使用，就像输入的形参那样。
命名后，一旦该函数开始执行，它们就会被初始化为对应其类型的零值，若该函数执行了
不带实参的 <code>return</code> 语句，则结果形参的当前值将作为返回值返回。
</p>

<div class="english">
<p>
The names are not mandatory but they can make code shorter and clearer:
they're documentation.
If we name the results of <code>nextInt</code> it becomes
obvious which returned <code>int</code>
is which.
</p>
</div>

<p>
此名称不是强制的，但它们能使代码更加简短而清晰：它们就是文档。如果我们命名了
<code>nextInt</code> 的返回值，各个返回的 <code>int</code> 是什么意思就显而易见了。
</p>

<pre>
func nextInt(b []byte, pos int) (value, nextPos int) {
</pre>

<div class="english">
<p>
Because named results are initialized and tied to an unadorned return, they can simplify
as well as clarify.  Here's a version
of <code>io.ReadFull</code> that uses them well:
</p>
</div>

<p>
由于被命名的结果已经初始化，且已关联至一个无参数的返回，它们就可以简化并清晰化代码。
这里的 <code>io.ReadFull</code> 就是使用它们的一个很好的例子。
</p>

<pre>
func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) &gt; 0 &amp;&amp; err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
</pre>

<div class="english">
<h3 id="defer">Defer</h3>
</div>

<h3 id="推迟">推迟</h3>

<div class="english">
<p>
Go's <code>defer</code> statement schedules a function call (the
<i>deferred</i> function) to be run immediately before the function
executing the <code>defer</code> returns.  It's an unusual but
effective way to deal with situations such as resources that must be
released regardless of which path a function takes to return.  The
canonical examples are unlocking a mutex or closing a file.
</p>
</div>

<p>
Go的 <code>defer</code> 语句用于预设一个函数调用（<i>推迟执行</i>的函数），
该函数会在函数执行 <code>defer</code> 返回之前立即执行。它显得不同常规，
但却是处理一些情况的有效方式，例如无论怎样返回，都必须对其进行资源释放的函数。
典型的例子就是解锁一个互斥或关闭一个文件。
</p>

<div class="english">
<pre>
// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
</pre>
</div>

<pre>
// Contents将文件的内容作为字符串返回。
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close会在我们结束后运行。

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append将在后面讨论。
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // 我们在此返回后，f就会被关闭。
        }
    }
    return string(result), nil // 我们在此返回后，f就会被关闭。
}
</pre>

<div class="english">
<p>
Deferring a call to a function such as <code>Close</code> has two advantages.  First, it
guarantees that you will never forget to close the file, a mistake
that's easy to make if you later edit the function to add a new return
path.  Second, it means that the close sits near the open,
which is much clearer than placing it at the end of the function.
</p>
</div>

<p>
对于像 <code>Close</code> 这种函数的推迟调用有两个优点。其一，它能确保你不会忘记关闭文件，
如果你以后编辑该函数来添加一个新的返回路径时，这种情况往往就会发生。其二，
它意味着关闭离打开很近，这要比将关闭放在函数结尾处更为清楚明了。
</p>

<div class="english">
<p>
The arguments to the deferred function (which include the receiver if
the function is a method) are evaluated when the <i>defer</i>
executes, not when the <i>call</i> executes.  Besides avoiding worries
about variables changing values as the function executes, this means
that a single deferred call site can defer multiple function
executions.  Here's a silly example.
</p>
</div>

<p>
被推迟函数的实参（如果该函数为方法则还包括接收者）在<i>延期</i>执行时就会求值，
而不是在<i>调用</i>执行时才求值。这样不仅无需担心变量值在函数执行时被改变，
同时也意味着单个已推迟的调用可推迟多个函数的执行。下面是个简单的例子。
</p>

<pre>
for i := 0; i &lt; 5; i++ {
    defer fmt.Printf("%d ", i)
}
</pre>

<div class="english">
<p>
Deferred functions are executed in LIFO order, so this code will cause
<code>4 3 2 1 0</code> to be printed when the function returns.  A
more plausible example is a simple way to trace function execution
through the program.  We could write a couple of simple tracing
routines like this:
</p>
</div>

<p>
被推迟的函数按照后进先出（LIFO）的顺序执行，因此以上代码在函数返回时会打印
<code>4 3 2 1 0</code>。一个更合理的例子是用一种简单的方法通过程序来跟踪函数的执行。
我们可以编写一对简单的跟踪例程，就像这样：
</p>

<div class="english">
<pre>
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// Use them like this:
func a() {
    trace("a")
    defer untrace("a")
    // do something....
}
</pre>
</div>

<pre>
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// 像这样使用它们：
func a() {
    trace("a")
    defer untrace("a")
    // 做一些事情....
}
</pre>

<div class="english">
<p>
We can do better by exploiting the fact that arguments to deferred
functions are evaluated when the <code>defer</code> executes.  The
tracing routine can set up the argument to the untracing routine.
This example:
</p>
</div>

<p>
我们可以通过利用被推迟函数的实参在 <code>defer</code> 执行时求值的特点做得更好。
跟踪例程可针对反跟踪例程建立实参。以下程序：
</p>

<pre>
func trace(s string) string {
    fmt.Println("entering:", s)
    return s
}

func un(s string) {
    fmt.Println("leaving:", s)
}

func a() {
    defer un(trace("a"))
    fmt.Println("in a")
}

func b() {
    defer un(trace("b"))
    fmt.Println("in b")
    a()
}

func main() {
    b()
}
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
会打印
</p>

<pre>
entering: b
in b
entering: a
in a
leaving: a
leaving: b
</pre>

<div class="english">
<p>
For programmers accustomed to block-level resource management from
other languages, <code>defer</code> may seem peculiar, but its most
interesting and powerful applications come precisely from the fact
that it's not block-based but function-based.  In the section on
<code>panic</code> and <code>recover</code> we'll see another
example of its possibilities.
</p>
</div>

<p>
对于习惯其它语言中块级资源管理的程序员，<code>defer</code> 似乎有点怪异，
但它最有趣和强大的应用恰恰来自于其基于函数而非基于块的特点。在 <code>panic</code>
和 <code>recover</code> 两节中我们将看到它另一种应用的例子。
</p>

<div class="english">
<h2 id="data">Data</h2>
</div>

<h2 id="数据">数据</h2>

<div class="english">
<h3 id="allocation_new">Allocation with <code>new</code></h3>
</div>

<h3 id="new分配">使用 <code>new</code> 分配内存</h3>

<div class="english">
<p>
Go has two allocation primitives, the built-in functions
<code>new</code> and <code>make</code>.
They do different things and apply to different types, which can be confusing,
but the rules are simple.
Let's talk about <code>new</code> first.
It's a built-in function that allocates memory, but unlike its namesakes
in some other languages it does not <em>initialize</em> the memory,
it only <em>zeros</em> it.
That is,
<code>new(T)</code> allocates zeroed storage for a new item of type
<code>T</code> and returns its address, a value of type <code>*T</code>.
In Go terminology, it returns a pointer to a newly allocated zero value of type
<code>T</code>.
</p>
</div>

<p>
Go有两种内存分配原语，即内建函数 <code>new</code> 和 <code>make</code>。
它们所做的事情不同，所应用到的类型也不同，这可能引起混淆，但规则却很简单。
让我们先讨论 <code>new</code>。它是一个用来分配内存的函数，但不像其它语言中同名的操作，
它不会<em>初始化</em>内存，只会将内存<em>清零</em>。<code>new(T)</code>
会为一个类型为 <code>T</code> 的新项分配已清零的存储空间并返回其地址，
也就是一个类型为 <code>*T</code> 的值。用Go的术语来说，它返回一个指向类型为
<code>T</code> 的新分配零值的指针。
</p>

<div class="english">
<p>
Since the memory returned by <code>new</code> is zeroed, it's helpful to arrange
when designing your data structures that the
zero value of each type can be used without further initialization.  This means a user of
the data structure can create one with <code>new</code> and get right to
work.
For example, the documentation for <code>bytes.Buffer</code> states that
"the zero value for <code>Buffer</code> is an empty buffer ready to use."
Similarly, <code>sync.Mutex</code> does not
have an explicit constructor or <code>Init</code> method.
Instead, the zero value for a <code>sync.Mutex</code>
is defined to be an unlocked mutex.
</p>
</div>

<p>
由于通过 <code>new</code> 返回的内存已清零，这样就更便于设计你的数据结构，
因为每个类型的零值不必进一步初始化就可以使用。这意味着该数据结构的使用者只需用
<code>new</code> 创建一个新的就能正确工作。例如，<code>bytes.Buffer</code>
的文档这样表述：“零值的 <code>Buffer</code> 为已准备就绪的缓存器。”
同样，<code>sync.Mutex</code> 并没有显式的构造器或 <code>Init</code> 方法，
不过零值的 <code>sync.Mutex</code> 已经被定义为解锁的互斥了。
</p>

<div class="english">
<p>
The zero-value-is-useful property works transitively. Consider this type declaration.
</p>
</div>

<p>
零值属性是可以传递的。考虑以下类型声明。
</p>

<pre>
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
</pre>

<div class="english">
<p>
Values of type <code>SyncedBuffer</code> are also ready to use immediately upon allocation
or just declaration.  In the next snippet, both <code>p</code> and <code>v</code> will work
correctly without further arrangement.
</p>
</div>

<p>
类型为 <code>SyncedBuffer</code> 的值也是在声明时就分配好内存并准备就绪了。
在下一个程序片段中，<code>p</code> 和 <code>v</code> 无需进一步处理就可以正确地工作。
</p>

<pre>
p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
</pre>

<div class="english">
<h3 id="composite_literals">Constructors and composite literals</h3>
</div>

<h3 id="复合字面">构造器与复合字面</h3>

<div class="english">
<p>
Sometimes the zero value isn't good enough and an initializing
constructor is necessary, as in this example derived from
package <code>os</code>.
</p>
</div>

<p>
有时零值并不够好，这时就需要一个初始化构造器，如来自包 <code>os</code> 中的这段代码所示。
</p>

<pre>
func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
</pre>

<div class="english">
<p>
There's a lot of boiler plate in there.  We can simplify it
using a <i>composite literal</i>, which is
an expression that creates a
new instance each time it is evaluated.
</p>
</div>

<p>
这里有很多类似的语句。我们可以使用<i>复合字面</i>来对其进行简化，
这是一个在每次求值时都创建一个新实例的表达式。
</p>

<pre>
func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &amp;f
}
</pre>

<div class="english">
<p>
Note that, unlike in C, it's perfectly OK to return the address of a local variable;
the storage associated with the variable survives after the function
returns.
In fact, taking the address of a composite literal
allocates a fresh instance each time it is evaluated,
so we can combine these last two lines.
</p>
</div>

<p>
请注意，返回一个局部变量的地址完全没有问题，这点与C不同，与此变量对应的存储在函数返回后仍然存在。
实际上，每当获取一个复合字面的地址时，都将为一个新的实例分配内存，
因此我们可以将上面的最后两行代码合并。
</p>

<pre>
    return &amp;File{fd, name, nil, 0}
</pre>

<div class="english">
<p>
The fields of a composite literal are laid out in order and must all be present.
However, by labeling the elements explicitly as <i>field</i><code>:</code><i>value</i>
pairs, the initializers can appear in any
order, with the missing ones left as their respective zero values.  Thus we could say
</p>
</div>

<p>
复合字面的字段必须按顺序全部列出。但如果以 <i>字段</i><code>:</code><i>值</i>
对的形式显式地标出元素，初始化器就可以按任何顺序出现，未给出的字段值则为零值。
因此，我们可以用如下形式：
</p>
<pre>
    return &amp;File{fd: fd, name: name}
</pre>

<div class="english">
<p>
As a limiting case, if a composite literal contains no fields at all, it creates
a zero value for the type.  The expressions <code>new(File)</code> and <code>&amp;File{}</code> are equivalent.
</p>
</div>

<p>
少数情况下，若复合字面不包括任何字段，它将创建该类型的零值。表达式
<code>new(File)</code> 和 <code>&amp;File{}</code> 是等价的。
</p>

<div class="english">
<p>
Composite literals can also be created for arrays, slices, and maps,
with the field labels being indices or map keys as appropriate.
In these examples, the initializations work regardless of the values of <code>Enone</code>,
<code>Eio</code>, and <code>Einval</code>, as long as they are distinct.
</p>
</div>

<p>
复合字面同样可用于创建数组、切片和映射，映射的字段标签是索引还是映射键则视情况而定。
在下面例字的初始化过程中，不管 <code>Enone</code>、<code>Eio</code> 和 <code>Einval</code>
的值是什么，只要它们的标签不同就行。
</p>

<pre>
a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
</pre>

<div class="english">
<h3 id="allocation_make">Allocation with <code>make</code></h3>
</div>

<h3 id="make分配">使用 <code>make</code> 分配内存</h3>

<div class="english">
<p>
Back to allocation.
The built-in function <code>make(T, </code><i>args</i><code>)</code> serves
a purpose different from <code>new(T)</code>.
It creates slices, maps, and channels only, and it returns an <em>initialized</em>
(not <em>zeroed</em>)
value of type <code>T</code> (not <code>*T</code>).
The reason for the distinction
is that these three types are, under the covers, references to data structures that
must be initialized before use.
A slice, for example, is a three-item descriptor
containing a pointer to the data (inside an array), the length, and the
capacity, and until those items are initialized, the slice is <code>nil</code>.
For slices, maps, and channels,
<code>make</code> initializes the internal data structure and prepares
the value for use.
For instance,
</p>
</div>

<p>
再回到内存分配上来。内建函数 <code>make(T, </code><i>args</i><code>)</code>
的目的不同于 <code>new(T)</code>。它只用于创建切片、映射和信道，并返回类型为
<code>T</code>（而非 <code>*T</code>）的一个<em>已初始化</em> （而非<em>清零</em>）的值。
出现这种用差异的原因是由于这三种类型本质上为引用数据类型，它们在使用前必须初始化。
例如，切片是一个具有三项内容的描述符，包含一个指向（数组内部）数据的指针、长度以及容量，
在这三项被初始化之前，该切片为 <code>nil</code>。对于切片、映射和信道，<code>make</code>
用于初始化其内部的数据结构并准备好将要使用的值。例如，
</p>

<pre>
make([]int, 10, 100)
</pre>

<div class="english">
<p>
allocates an array of 100 ints and then creates a slice
structure with length 10 and a capacity of 100 pointing at the first
10 elements of the array.
(When making a slice, the capacity can be omitted; see the section on slices
for more information.)
In contrast, <code>new([]int)</code> returns a pointer to a newly allocated, zeroed slice
structure, that is, a pointer to a <code>nil</code> slice value.
</p>
</div>

<p>
会分配一个具有100个 <code>int</code> 的数组，接着创建一个长度为10，
容量为100并指向该数组中前10个元素的切片构造。（生成切片时，其容量可以省略，更多信息见切片一节。）
与此相反，<code>new([]int)</code> 会返回一个指向新分配的，已清零的切片构造，
即一个指向 <code>nil</code> 切片值的指针。returns a pointer to a newly allocated, zeroed slice
structure, that is, a pointer to a <code>nil</code> slice value.
</p>

<div class="english">
<p>
These examples illustrate the difference between <code>new</code> and
<code>make</code>.
</p>
</div>

<p>
下面的例子阐明了 <code>new</code> 与 <code>make</code> 之间的不同。
</p>

<div class="english">
<pre>
var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
</pre>
</div>

<pre>
var p *[]int = new([]int)       // 分配切片构造；*p == nil；基本没用
var v  []int = make([]int, 100) // 切片v现在引用了一个具有100个int元素的新数组

// 不必要地使问题复杂化：
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// 习惯用法：
v := make([]int, 100)
</pre>

<div class="english">
<p>
Remember that <code>make</code> applies only to maps, slices and channels
and does not return a pointer.
To obtain an explicit pointer allocate with <code>new</code>.
</p>
</div>

<p>
请记住，<code>make</code> 只适用于映射、切片和信道且不返回指针。要获得一个明确的指针，
请使用 <code>new</code> 分配内存。
</p>

<div class="english">
<h3 id="arrays">Arrays</h3>
</div>

<h3 id="数组">数组</h3>

<div class="english">
<p>
Arrays are useful when planning the detailed layout of memory and sometimes
can help avoid allocation, but primarily
they are a building block for slices, the subject of the next section.
To lay the foundation for that topic, here are a few words about arrays.
</p>
</div>

<p>
在详细规划内存布局时，数组是非常有用的，有时可帮助避免内存分配，但它们主要用作切片的构件，
这将是下一节的主题。作为对该主题的一个铺垫，这里先对数组说上几句。
</p>

<div class="english">
<p>
There are major differences between the ways arrays work in Go and C.
In Go,
</p>
<ul>
<li>
Arrays are values. Assigning one array to another copies all the elements.
</li>
<li>
In particular, if you pass an array to a function, it
will receive a <i>copy</i> of the array, not a pointer to it.
<li>
The size of an array is part of its type.  The types <code>[10]int</code>
and <code>[20]int</code> are distinct.
</li>
</ul>
</div>

<p>
以下为在Go和C中的数组的主要区别，在Go中，
</p>
<ul>
<li>
数组是值。将一个数组赋予另一个数组将复制其所有元素。
</li>
<li>
特别地，如果你将一个数组传递给一个函数，它将接收到该数组的一个<i>副本</i>，
而不是指向它的指针。
<li>
数组的大小是其类型的一部分。类型 <code>[10]int</code> 和 <code>[20]int</code> 是不同的。
</li>
</ul>

<div class="english">
<p>
The value property can be useful but also expensive; if you want C-like behavior and efficiency,
you can pass a pointer to the array.
</p>
</div>

<p>
数组为值的属性很有用，但代价高昂；如果你想要类似于C的行为和效率，你可以传递一个指向该数组的指针。
</p>

<div class="english">
<pre>
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&amp;array)  // Note the explicit address-of operator
</pre>

<p>
But even this style isn't idiomatic Go.  Slices are.
</p>
</div>

<pre>
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&amp;array)  // 注意显式的取址操作
</pre>

<div class="english">
<p>
But even this style isn't idiomatic Go.  Slices are.
</p>
</div>

<p>
但这并不是Go的习惯用法，切片才是。
</p>

<div class="english">
<h3 id="slices">Slices</h3>
</div>

<h3 id="切片">切片</h3>

<div class="english">
<p>
Slices wrap arrays to give a more general, powerful, and convenient
interface to sequences of data.  Except for items with explicit
dimension such as transformation matrices, most array programming in
Go is done with slices rather than simple arrays.
</p>
</div>

<p>
切片通过包装数组对数据序列提供了一个更通用、强大和方便的界面。
除了像矩阵变换这种需要明确尺寸的情况外，Go中的数组编程是通过切片而非简单的数组完成的。
</p>

<div class="english">
<p>
Slices are <i>reference types</i>, which means that if you assign one
slice to another, both refer to the same underlying array.  For
instance, if a function takes a slice argument, changes it makes to
the elements of the slice will be visible to the caller, analogous to
passing a pointer to the underlying array.  A <code>Read</code>
function can therefore accept a slice argument rather than a pointer
and a count; the length within the slice sets an upper
limit of how much data to read.  Here is the signature of the
<code>Read</code> method of the <code>File</code> type in package
<code>os</code>:
</p>
</div>

<p>
切片是<i>引用类型</i>，这意味着如果你将一个切片赋予另外一个，这两个切片将引用同一个基本数组。
例如，若一个函数获取了一个切片实参，它对切片元素的修改对于调用者来说是可见的。
类似于传递一个指向其基本数组的指针。因此，<code>Read</code> 函数可接受一个切片实参而非指针或计数；
切片的决定了可读取数据的上限。以下为 <code>os</code> 包中 <code>File</code>
类型的 <code>Read</code> 方法签名：
</p>

<pre>
func (file *File) Read(buf []byte) (n int, err error)
</pre>

<div class="english">
<p>
The method returns the number of bytes read and an error value, if
any.  To read into the first 32 bytes of a larger buffer
<code>b</code>, <i>slice</i> (here used as a verb) the buffer.
</p>
</div>

<p>
该方法返回读取的字节数和一个错误值（若有的话）。要读入一个大型缓存器 <code>b</code>
的前32个字节，只需<i>切分</i>该缓冲区即可。
</p>

<pre>
    n, err := f.Read(buf[0:32])
</pre>

<div class="english">
<p>
Such slicing is common and efficient.  In fact, leaving efficiency aside for
the moment, the following snippet would also read the first 32 bytes of the buffer.
</p>
</div>

<p>
这种切分的方法常用且高效。实际上，暂不考虑效率问题，一下片段同样可读取该缓存器的前32个字节。
</p>

<div class="english">
<pre>
    var n int
    var err error
    for i := 0; i &lt; 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.
        if nbytes == 0 || e != nil {
            err = e
            break
        }
        n += nbytes
    }
</pre>
</div>

<pre>
    var n int
    var err error
    for i := 0; i &lt; 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // 读取一个字节。
        if nbytes == 0 || e != nil {
            err = e
            break
        }
        n += nbytes
    }
</pre>

<div class="english">
<p>
The length of a slice may be changed as long as it still fits within
the limits of the underlying array; just assign it to a slice of
itself.  The <i>capacity</i> of a slice, accessible by the built-in
function <code>cap</code>, reports the maximum length the slice may
assume.  Here is a function to append data to a slice.  If the data
exceeds the capacity, the slice is reallocated.  The
resulting slice is returned.  The function uses the fact that
<code>len</code> and <code>cap</code> are legal when applied to the
<code>nil</code> slice, and return 0.
</p>
</div>

<p>
切片的长度是可改变的，只要它不超出其基本数组的长度极限；只需将该数组的一个切片赋予它便可。
切片的<i>容量</i>可通过内建函数 <code>cap</code> 访问，它将给出该切片可被赋予的最大长度。
以下是为切片追加数据的函数。若数据超出容量其，则会重新分配该切片。返回值即为所得的切片。
该函数中所使用的 <code>len</code> 和 <code>cap</code> 在应用于 <code>nil</code>
切片时是合法的，它会返回0.
</p>

<div class="english">
<pre>
func Append(slice, data[]byte) []byte {
    l := len(slice)
    if l + len(data) &gt; cap(slice) {  // reallocate
        // Allocate double what's needed, for future growth.
        newSlice := make([]byte, (l+len(data))*2)
        // The copy function is predeclared and works for any slice type.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    for i, c := range data {
        slice[l+i] = c
    }
    return slice
}
</pre>
</div>

<pre>
func Append(slice, data[]byte) []byte {
    l := len(slice)
    if l + len(data) &gt; cap(slice) {  // 重新分配
        // 为后面需要的增长分配两份。
        newSlice := make([]byte, (l+len(data))*2)
        //  copy函数是预声明的，且可工作于任何切片类型。
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    for i, c := range data {
        slice[l+i] = c
    }
    return slice
}
</pre>

<div class="english">
<p>
We must return the slice afterwards because, although <code>Append</code>
can modify the elements of <code>slice</code>, the slice itself (the run-time data
structure holding the pointer, length, and capacity) is passed by value.
</p>
</div>

<p>
我们必须在最后返回切片，这是因为尽管 <code>Append</code> 可修改 <code>slice</code>
的元素，但切片自身（其运行时数据结构包含指针、长度和容量）是通过值传递的。
</p>

<div class="english">
<p>
The idea of appending to a slice is so useful it's captured by the
<code>append</code> built-in function.  To understand that function's
design, though, we need a little more information, so we'll return
to it later.
</p>
</div>

<p>
为切片追加东西的想法非常有用，因此有一个专门的内建函数 <code>append</code>。
要理解该函数的设计，我们还需要更多一点的信息，我们将稍后再介绍它。
</p>


<div class="english">
<h3 id="maps">Maps</h3>
</div>

<h3 id="映射">映射</h3>

<div class="english">
<p>
Maps are a convenient and powerful built-in data structure to associate
values of different types.
The key can be of any type for which the equality operator is defined,
such as integers,
floating point and complex numbers,
strings, pointers, interfaces (as long as the dynamic type
supports equality), structs and arrays. Slices cannot be used as map keys,
because equality is not defined on them.
Like slices, maps are a reference type. If you pass a map to a function
that changes the contents of the map, the changes will be visible
in the caller.
</p>
</div>

<p>
映射是方便而强大的内建数据结构，它可以关联不同类型的值。其键可以是任意的已定义了相等性操作符的类型，
如整数、浮点数和复数、字符串、指针、接口（只要其动态类型支持相等性）、结构以及数组。
切片不能用作映射键，因为它们的相等性还未定义。就像切片一样，映射也是引用类型。
若你将一个映射传递给函数，并更改了该映射的内容，则此修改对于调用者来说是可见的。
</p>

<div class="english">
<p>
Maps can be constructed using the usual composite literal syntax
with colon-separated key-value pairs,
so it's easy to build them during initialization.
</p>
</div>

<p>
映射可使用通常的复合字面语法进行构建，其键-值对使用逗号分隔，因此可在初始化时来构建它们
</p>

<pre>
var timeZone = map[string] int {
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
</pre>

<div class="english">
<p>
Assigning and fetching map values looks syntactically just like
doing the same for arrays and slices except that the index doesn't
need to be an integer.
</p>
</div>

<p>
赋值和获取映射值的语法类似于数组，不同的是映射的索引不必为整数。
</p>

<pre>
offset := timeZone["EST"]
</pre>

<div class="english">
<p>
An attempt to fetch a map value with a key that
is not present in the map will return the zero value for the type
of the entries
in the map.  For instance, if the map contains integers, looking
up a non-existent key will return <code>0</code>.
A set can be implemented as a map with value type <code>bool</code>.
Set the map entry to <code>true</code> to put the value in the set, and then
test it by simple indexing.
</p>
</div>

<p>
如果试图使用一个不存在的键来获取映射值，就会返回在该映射对应该项类型的零值。
例如，若映射包含整数，查找一个不存在的键将返回 <code>0</code>。一个集合可使用一个值类型为
<code>bool</code> 的映射来实现。通过将该映射中的项置为 <code>true</code>
来将值放入集合中，然后通过简单的索引对齐进行测试。
</p>

<div class="english">
<pre>
attended := map[string] bool {
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // will be false if person is not in the map
    fmt.Println(person, "was at the meeting")
}
</pre>
</div>

<pre>
attended := map[string] bool {
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // 若人不在该映射中，则为false
    fmt.Println(person, "was at the meeting")
}
</pre>

<div class="english">
<p>
Sometimes you need to distinguish a missing entry from
a zero value.  Is there an entry for <code>"UTC"</code>
or is that zero value because it's not in the map at all?
You can discriminate with a form of multiple assignment.
</p>
</div>

<p>
有时你需要从零值中区分出不存在的条目。如对于一个值本应为零的 <code>"UTC"</code>
条目，也可能是由于不存在该项而得到零值。你可以使用多重赋值的形式来分辨这种情况。
</p>

<pre>
var seconds int
var ok bool
seconds, ok = timeZone[tz]
</pre>

<div class="english">
<p>
For obvious reasons this is called the &ldquo;comma ok&rdquo; idiom.
In this example, if <code>tz</code> is present, <code>seconds</code>
will be set appropriately and <code>ok</code> will be true; if not,
<code>seconds</code> will be set to zero and <code>ok</code> will
be false.
Here's a function that puts it together with a nice error report:
</p>
</div>

<p>
显然这种习惯的用法可称作“逗号ok”。在下面的例子中，若 <code>tz</code> 存在，
<code>seconds</code> 就会被恰当地设置，而 <code>ok</code> 将为 <code>true</code>；
若不存在，<code>seconds</code> 将会被置为零，而 <code>ok</code> 将为 <code>false</code>。
</p>

<pre>
func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
}
</pre>

<div class="english">
<p>
To test for presence in the map without worrying about the actual value,
you can use the blank identifier (<code>_</code>).
The blank identifier can be assigned or declared with any value of any type, with the
value discarded harmlessly.  For testing just presence in a map, use the blank
identifier in place of the usual variable for the value.
</p>
</div>

<p>
若只需测试映射中是否存在某项而不关心实际的值，可使用空白标识符（<code>_</code>）。
空白标识符可被赋予或声明任意类型的任意值，这样的值将被丢弃，且并不产生任何问题。
对于只是测试某项是否在映射中而言，可将原本存储值的变量替换为空白标识符。
</p>

<pre>
_, present := timeZone[tz]
</pre>

<div class="english">
<p>
To delete a map entry, use the <code>delete</code>
built-in function, whose arguments are the map and the key to be deleted.
It's safe to do this this even if the key is already absent
from the map.
</p>
</div>

<p>
要删除映射中的一项，可使用内建函数 <code>delete</code>，其实参为该映射以及要被删除的键。
即便对应的键不在该映射中，此操作也是安全的。
</p>

<div class="english">
<pre>
delete(timeZone, "PDT")  // Now on Standard Time
</pre>
</div>

<pre>
delete(timeZone, "PDT")  // 现在是标准时间
</pre>

<div class="english">
<h3 id="printing">Printing</h3>
</div>

<h3 id="打印">打印</h3>

<div class="english">
<p>
Formatted printing in Go uses a style similar to C's <code>printf</code>
family but is richer and more general. The functions live in the <code>fmt</code>
package and have capitalized names: <code>fmt.Printf</code>, <code>fmt.Fprintf</code>,
<code>fmt.Sprintf</code> and so on.  The string functions (<code>Sprintf</code> etc.)
return a string rather than filling in a provided buffer.
</p>
</div>

<p>
Go中格式化打印的风格类似于C的 <code>printf</code> 家族，但却更加丰富和通用。
这些函数位于 <code>fmt</code> 包中，且函数名以答谢字母开头：如
<code>fmt.Printf</code>、<code>fmt.Fprintf</code>，<code>fmt.Sprintf</code> 等。
字符串函数（<code>Sprintf</code> 等）并不是填充一个给定的缓存区，而是返回一个字符串。
</p>

<div class="english">
<p>
You don't need to provide a format string.  For each of <code>Printf</code>,
<code>Fprintf</code> and <code>Sprintf</code> there is another pair
of functions, for instance <code>Print</code> and <code>Println</code>.
These functions do not take a format string but instead generate a default
format for each argument. The <code>Println</code> versions also insert a blank
between arguments and append a newline to the output while
the <code>Print</code> versions add blanks only if the operand on neither side is a string.
In this example each line produces the same output.
</p>
</div>

<p>
你无需提供一个格式字符串。每个 <code>Printf</code>、<code>Fprintf</code> 和
<code>Sprintf</code> 都分别对应另外的函数，如 <code>Print</code> 与 <code>Println</code>。
这些函数并不接受格式字符串，而是为每个实参生成一种默认格式。<code>Println</code>
的版本还会在实参中插入一个空白并在输出时追加一个换行符，而 <code>Print</code>
版本仅在操作数两遍都没有字符串时才添加空白。以下示例中各行产生的输出都是一样的。
</p>

<pre>
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
</pre>

<div class="english">
<p>
As mentioned in
the <a href="http://tour.golang.org">Tour</a>, <code>fmt.Fprint</code>
and friends take as a first argument any object
that implements the <code>io.Writer</code> interface; the variables <code>os.Stdout</code>
and <code>os.Stderr</code> are familiar instances.
</p>
</div>

<p>
正如<a href="http://tour.golang.org">Go语言之旅</a>中所说，<code>fmt.Fprint</code>
一类的函数可接受任何实现了 <code>io.Writer</code> 接口的对象作为第一个实参；变量
<code>os.Stdout</code> 与 <code>os.Stderr</code> 都是大家熟知的例子。
</p>

<div class="english">
<p>
Here things start to diverge from C.  First, the numeric formats such as <code>%d</code>
do not take flags for signedness or size; instead, the printing routines use the
type of the argument to decide these properties.
</p>
</div>

<p>
这里与C还有些不同。首先，像 <code>%d</code> 这样的数值格式并不接受表示符号或大小的标记，
打印例程会根据实参的类型来决定这些属性。
</p>

<pre>
var x uint64 = 1&lt;&lt;64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
将打印
</p>

<pre>
18446744073709551615 ffffffffffffffff; -1 -1
</pre>

<div class="english">
<p>
If you just want the default conversion, such as decimal for integers, you can use
the catchall format <code>%v</code> (for &ldquo;value&rdquo;); the result is exactly
what <code>Print</code> and <code>Println</code> would produce.
Moreover, that format can print <em>any</em> value, even arrays, slices, structs, and
maps.  Here is a print statement for the time zone map defined in the previous section.
</p>
</div>

<p>
如果你只想要默认的转换，如使用十进制的整数，你可以使用通用的格式
<code>%v</code>（对应“值”）；其结果与 <code>Print</code> 和 <code>Println</code>
产生的输出时完全一样的。此外，这种格式可打印<em>任意</em>值，甚至包括数组、结构和映射。
以下是针对上一节中定义的时区映射的打印语句。
</p>

<div class="english">
<pre>
fmt.Printf("%v\n", timeZone)  // or just fmt.Println(timeZone)
</pre>
</div>

<pre>
fmt.Printf("%v\n", timeZone)  // 或只用 fmt.Println(timeZone)
</pre>

<div class="english">
<p>
which gives output
</p>
</div>

<p>
这会输出
</p>

<pre>
map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]
</pre>

<div class="english">
<p>
For maps the keys may be output in any order, of course.
When printing a struct, the modified format <code>%+v</code> annotates the
fields of the structure with their names, and for any value the alternate
format <code>%#v</code> prints the value in full Go syntax.
</p>
</div>

<p>
当然，映射中的键可能按任意顺序输出。当打印一个结构时，改进的格式 <code>%+v</code>
将使用字段的名称来注解该结构的字段，而另外一个格式将完全按照Go的语法打印任意值。
</p>

<pre>
type T struct {
    a int
    b float64
    c string
}
t := &amp;T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
将打印
</p>

<pre>
&amp;{7 -2.35 abc   def}
&amp;{a:7 b:-2.35 c:abc     def}
&amp;main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string] int{"CST":-21600, "PST":-28800, "EST":-18000, "UTC":0, "MST":-25200}
</pre>

<div class="english">
<p>
(Note the ampersands.)
That quoted string format is also available through <code>%q</code> when
applied to a value of type <code>string</code> or <code>[]byte</code>;
the alternate format <code>%#q</code> will use backquotes instead if possible.
Also, <code>%x</code> works on strings, byte arrays and byte slices as well as
on integers, generating a long hexadecimal string, and with
a space in the format (<code>%&nbsp;x</code>) it puts spaces between the bytes.
</p>
</div>

<p>
（请注意其中的&amp;符号）当遇到 <code>string</code> 或 <code>[]byte</code> 值时，
可使用 <code>%q</code> 产生带引号的字符串；而格式 <code>%#q</code> 将尽可能使用反引号。
另外，<code>%x</code> 还可用于字符串、字节数组以及整数，并生成一个很长的十六进制字符串，
而带空格的格式（<code>%&nbsp;x</code>）还会在字节之间插入空格。
</p>

<div class="english">
<p>
Another handy format is <code>%T</code>, which prints the <em>type</em> of a value.
</p>
</div>

<p>
另一个方便的格式是 <code>%T</code>，它会打印一个值的<em>类型</em>。
</p>

<pre>
fmt.Printf(&quot;%T\n&quot;, timeZone)
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
将打印
</p>

<pre>
map[string] int
</pre>

<div class="english">
<p>
If you want to control the default format for a custom type, all that's required is to define
a method with the signature <code>String() string</code> on the type.
For our simple type <code>T</code>, that might look like this.
</p>
</div>

<p>
如果你想要控制一个自定义类型的默认格式，只需为此类型定义一个具有
<code>String() string</code> 签名的方法。对于我们简单的类型 <code>T</code>，
可进行如下操作。
</p>

<pre>
func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
</pre>

<div class="english">
<p>
to print in the format
</p>
</div>

<p>
它将以格式化的形式打印
</p>

<pre>
7/-2.35/"abc\tdef"
</pre>

<div class="english">
<p>
(If you need to print <em>values</em> of type <code>T</code> as well as pointers to <code>T</code>,
the receiver for <code>String</code> must be of value type; this example used a pointer because
that's more efficient and idiomatic for struct types.
See the section below on <a href="#pointers_vs_values">pointers vs. value receivers</a> for more information.)
</p>
</div>

<p>
（如果你需要像指向 <code>T</code> 的指针那样打印类型 <code>T</code> 的<em>值</em>，
<code>String</code> 的接收者就必须是值类型的；上面的例子中接收者是一个指针，
因为这对结构来说更高效而常用。更多详情见<a href="#指针vs值">指针vs.值接收者</a>一节）
</p>

<div class="english">
<p>
Our <code>String</code> method is able to call <code>Sprintf</code> because the
print routines are fully reentrant and can be used recursively.
We can even go one step further and pass a print routine's arguments directly to another such routine.
The signature of <code>Printf</code> uses the type <code>...interface{}</code>
for its final argument to specify that an arbitrary number of parameters (of arbitrary type)
can appear after the format.
</p>
</div>

<p>
<code>String</code> 方法也可调用 <code>Sprintf</code>，这是由于打印例程完全可以重新加入并递归使用。
我们甚至可以将一个打印例程的实参直接传递给另一个这样的例程。<code>Printf</code> 的签名使用
<code>...interface{}</code>
类型作为其最后一个实参，这样就可以指定（任意类型的）任意数量的形参出现在 <code>format</code> 之后了。
</p>

<pre>
func Printf(format string, v ...interface{}) (n int, err error) {
</pre>

<div class="english">
<p>
Within the function <code>Printf</code>, <code>v</code> acts like a variable of type
<code>[]interface{}</code> but if it is passed to another variadic function, it acts like
a regular list of arguments.
Here is the implementation of the
function <code>log.Println</code> we used above. It passes its arguments directly to
<code>fmt.Sprintln</code> for the actual formatting.
</p>
</div>

<p>
在 <code>Printf</code> 函数中，<code>v</code> 就像一个类型为 <code>[]interface{}</code>
的变量，但如果将它传递至另一个变参函数中，它就变得与常规实参列表一样了。
以下是我们在上面使用过的 <code>log.Println</code> 函数。它直接将其实参传递给
<code>fmt.Sprintln</code> 进行实际的格式化。
</p>

<div class="english">
<pre>
// Println prints to the standard logger in the manner of fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)
}
</pre>
</div>

<pre>
// Println prints to the standard logger in the manner of fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // 输出接受形参(int, string)
}
</pre>

<div class="english">
<p>
We write <code>...</code> after <code>v</code> in the nested call to <code>Sprintln</code> to tell the
compiler to treat <code>v</code> as a list of arguments; otherwise it would just pass
<code>v</code> as a single slice argument.
</p>
</div>

<p>
我们通过在嵌套调用的 <code>Sprintln</code> 中的 <code>v</code> 之后写上 <code>...</code>
来告诉编译器将 <code>v</code> 视作一个实参列表，否则它就只会将 <code>v</code>
作为一个单一的切片实参来传递。
</p>

<div class="english">
<p>
There's even more to printing than we've covered here.  See the <code>godoc</code> documentation
for package <code>fmt</code> for the details.
</p>
</div>

<p>
还有一些我们没有介绍的打印。详情请参阅 <code>fmt</code> 包中的 <code>godoc</code> 文档
</p>

<div class="english">
<p>
By the way, a <code>...</code> parameter can be of a specific type, for instance <code>...int</code>
for a min function that chooses the least of a list of integers:
</p>
</div>

<p>
顺便说一下，<code>...</code> 形参可以指定类型，如 <code>...int</code>
可以让求最小值的函数选定一个整数列表中的最小值：
</p>

<div class="english">
<pre>
func Min(a ...int) int {
    min := int(^uint(0) >> 1)  // largest int
    for _, i := range a {
        if i &lt; min {
            min = i
        }
    }
    return min
}
</pre>
</div>

<pre>
func Min(a ...int) int {
    min := int(^uint(0) >> 1)  // 最大整数
    for _, i := range a {
        if i &lt; min {
            min = i
        }
    }
    return min
}
</pre>

<div class="english">
<h3 id="append">Append</h3>
</div>

<h3 id="追加">追加</h3>

<div class="english">
<p>
Now we have the missing piece we needed to explain the design of
the <code>append</code> built-in function.  The signature of <code>append</code>
is different from our custom <code>Append</code> function above.
Schematically, it's like this:
</p>
</div>

<p>
现在我们要对内建函数 <code>append</code> 的设计进行补充说明。<code>append</code>
函数的签名不同于前面我们自定义的 <code>Append</code> 函数。大致来说，它就像这样：
</p>

<pre>
func append(slice []<i>T</i>, elements...T) []<i>T</i>
</pre>

<div class="english">
<p>
where <i>T</i> is a placeholder for any given type.  You can't
actually write a function in Go where the type <code>T</code>
is determined by the caller.
That's why <code>append</code> is built in: it needs support from the
compiler.
</p>
</div>

<p>
其中的 <i>T</i> 为任意给定类型的占位符。实际上在Go中你无法编写一个类型 <code>T</code>
由调用者决定的函数。这也就是为什么 <code>append</code> 是内建函数的原因：它需要编译器的支持。
</p>

<div class="english">
<p>
What <code>append</code> does is append the elements to the end of
the slice and return the result.  The result needs to be returned
because, as with our hand-written <code>Append</code>, the underlying
array may change.  This simple example
</p>
</div>

<p>
<code>append</code> 所做的就是在切片的末尾追加元素并返回结果。必须返回结果的原因与前面我们手写的
<code>Append</code> 一样，即其基本数组可能已发生改变。以下简单的例子
</p>

<pre>
x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
</pre>

<div class="english">
<p>
prints <code>[1 2 3 4 5 6]</code>.  So <code>append</code> works a
little like <code>Printf</code>, collecting an arbitrary number of
arguments.
</p>
</div>

<p>
将打印 <code>[1 2 3 4 5 6]</code>。因此 <code>append</code> 有点像 <code>Printf</code>
那样，可接受任意个数的实参。
</p>

<div class="english">
<p>
But what if we wanted to do what our <code>Append</code> does and
append a slice to a slice?  Easy: use <code>...</code> at the call
site, just as we did in the call to <code>Output</code> above.  This
snippet produces identical output to the one above.
</p>
</div>

<p>
但如果我们想做 <code>Append</code> 所做的工作，或者将一个切片追加到另一个切片时怎么办？
很简单：在调用的地方使用 <code>...</code>，就像我们在上面调用 <code>Output</code>
那样。以下代码片段的输出与上一个相同。
</p>

<pre>
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
</pre>

<div class="english">
<p>
Without that <code>...</code>, it wouldn't compile because the types
would be wrong; <code>y</code> is not of type <code>int</code>.
</p>
</div>

<p>
如果没有 <code>...</code>，它就会由于类型错误而无法编译，因为 <code>y</code>
不是 <code>int</code> 类型的。
</p>

<div class="english">
<h2 id="initialization">Initialization</h2>
</div>

<h2 id="初始化">初始化</h2>

<div class="english">
<p>
Although it doesn't look superficially very different from
initialization in C or C++, initialization in Go is more powerful.
Complex structures can be built during initialization and the ordering
issues between initialized objects in different packages are handled
correctly.
</p>
</div>

<p>
尽管在表面上，Go的初始化与C或C++的相比变化并不是很大，但Go的初始化却更加强大。
在初始化过程中，不仅可以构建复杂的结构，还能正确地处理不同包中被初始化对象之间的次序问题。
</p>

<div class="english">
<h3 id="constants">Constants</h3>
</div>

<h3 id="常量">常量</h3>

<div class="english">
<p>
Constants in Go are just that&mdash;constant.
They are created at compile time, even when defined as
locals in functions,
and can only be numbers, strings or booleans.
Because of the compile-time restriction, the expressions
that define them must be constant expressions,
evaluatable by the compiler.  For instance,
<code>1&lt;&lt;3</code> is a constant expression, while
<code>math.Sin(math.Pi/4)</code> is not because
the function call to <code>math.Sin</code> needs
to happen at run time.
</p>
</div>

<p>
Go中的常量就是不变量。它们在编译时创建，即便在函数中定义的局部变量也是如此，
常量只能是数字、字符串或布尔值。由于编译时的限制，定义它们的表达式必须是可被编译器求值的常量表达式。
例如，<code>1&lt;&lt;3</code> 就是一个常量表达式，而 <code>math.Sin(math.Pi/4)</code>
则不是，因为对 <code>math.Sin</code> 的函数调用在运行时才会发生。
</p>

<div class="english">
<p>
In Go, enumerated constants are created using the <code>iota</code>
enumerator.  Since <code>iota</code> can be part of an expression and
expressions can be implicitly repeated, it is easy to build intricate
sets of values.
</p>
</div>

<p>
在Go中，枚举常量使用枚举器 <code>iota</code> 创建。由于 <code>iota</code>
可为表达式的一部分，而表达式可以被隐式地重复，这样也就更容易构建复杂的值的集合。
</p>

{{code "/doc/progs/eff_bytesize.go" `/^type ByteSize/` `/^\)/`}}

<div class="english">
<p>
The ability to attach a method such as <code>String</code> to a
type makes it possible for such values to format themselves
automatically for printing, even as part of a general type.
</p>
</div>

<p>
由于可为一个类型附加一个 <code>String</code> 方法，
因此可以使这些值在打印时自动地格式化它们自己，即便是作为一个通用类型的一部分。
</p>

{{code "/doc/progs/eff_bytesize.go" `/^func.*ByteSize.*String/` `/^}/`}}

<div class="english">
<p>
The expression <code>YB</code> prints as <code>1.00YB</code>,
while <code>ByteSize(1e13)</code> prints as <code>9.09TB</code>.
</p>
</div>

<p>
表达式 <code>YB</code> 的打印形式为 <code>1.00YB</code>，而 <code>ByteSize(1e13)</code>
的打印形式为 <code>9.09TB</code>。
</p>

<div class="english">
<p>
Note that it's fine to call <code>Sprintf</code> and friends in the
implementation of <code>String</code> methods, but beware of
recurring into the <code>String</code> method through the nested
<code>Sprintf</code> call using a string format
(<code>%s</code>, <code>%q</code>, <code>%v</code>, <code>%x</code> or <code>%X</code>).
The <code>ByteSize</code> implementation of <code>String</code> is safe
because it calls <code>Sprintf</code> with <code>%f</code>.
</p>
</div>

<p>
注意，在 <code>String</code> 方法的实现中调用 <code>Sprintf</code> 这类函数完全没有问题，
但要知道在使用字符串格式（<code>%s</code>、<code>%q</code>、<code>%v</code>、<code>%x</code>
或 <code>%X</code>）嵌套调用 <code>Sprintf</code> 时可导致 <code>String</code>
方法被多次递归调用。上面所实现的 <code>ByteSize</code> 的 <code>String</code>
方法是安全的，因为它通过 <code>%f</code> 调用 <code>Sprintf</code>。
</p>

<div class="english">
<h3 id="variables">Variables</h3>
</div>

<h3 id="变量">变量</h3>

<div class="english">
<p>
Variables can be initialized just like constants but the
initializer can be a general expression computed at run time.
</p>
</div>

<p>
变量的初始化与常量类似，但其初始值可以是在运行时计算的一般表达式。
</p>

<pre>
var (
    home   = os.Getenv("HOME")
    user   = os.Getenv("USER")
    goRoot = os.Getenv("GOROOT")
)
</pre>

<div class="english">
<h3 id="init">The init function</h3>
</div>

<h3 id="init函数">init函数</h3>

<div class="english">
<p>
Finally, each source file can define its own niladic <code>init</code> function to
set up whatever state is required.  (Actually each file can have multiple
<code>init</code> functions.)
And finally means finally: <code>init</code> is called after all the
variable declarations in the package have evaluated their initializers,
and those are evaluated only after all the imported packages have been
initialized.
</p>
</div>

<p>
最后，每一个源文件都可以定义自己的无参数 <code>init</code> 函数来建立各种需要的状态。
（实际上每个文件都可拥有多个 <code>init</code> 函数。）而它的结束就意味着初始化结束：
该包中的所有变量声明在求得其初始值后 <code>init</code>
才会被调用，而求值的工作则是在所有被导入的包都初始化后才开始进行的。
</p>

<div class="english">
<p>
Besides initializations that cannot be expressed as declarations,
a common use of <code>init</code> functions is to verify or repair
correctness of the program state before real execution begins.
</p>
</div>

<p>
另外初始化中不能进行声明，<code>init</code>
的一个常见应用是在程序真正开始执行前，对其状态的正确性进行验证或修复。
</p>

<div class="english">
<pre>
func init() {
    if user == "" {
        log.Fatal("$USER not set")
    }
    if home == "" {
        home = "/home/" + user
    }
    if goRoot == "" {
        goRoot = home + "/go"
    }
    // goRoot may be overridden by --goroot flag on command line.
    flag.StringVar(&amp;goRoot, "goroot", goRoot, "Go root directory")
}
</pre>
</div>

<pre>
func init() {
    if user == "" {
        log.Fatal("$USER not set")
    }
    if home == "" {
        home = "/home/" + user
    }
    if goRoot == "" {
        goRoot = home + "/go"
    }
    // goRoot 可在命令行中通过 --goroot 标记覆盖。
    flag.StringVar(&amp;goRoot, "goroot", goRoot, "Go root directory")
}
</pre>

<div class="english">
<h2 id="methods">Methods</h2>
</div>

<h2 id="方法">方法</h2>

<div class="english">
<h3 id="pointers_vs_values">Pointers vs. Values</h3>
</div>

<h3 id="指针vs值">指针vs.值</h3>

<div class="english">
<p>
Methods can be defined for any named type that is not a pointer or an interface;
the receiver does not have to be a struct.
</p>
</div>

<p>
任何不是指针或接口的已命名类型均可定义方法；接收者可不为结构。
</p>

<div class="english">
<p>
In the discussion of slices above, we wrote an <code>Append</code>
function.  We can define it as a method on slices instead.  To do
this, we first declare a named type to which we can bind the method, and
then make the receiver for the method a value of that type.
</p>
</div>

<p>
在上面关于切片的讨论中，我们编写了一个 <code>Append</code> 函数。
我们也可将其定义为切片上的方法。要这样做，我们首先需要声明一个已命名的类型来绑定该方法，
然后使该方法的接收者成为该类型的值。
</p>

<div class="english">
<pre>
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // Body exactly the same as above
}
</pre>
</div>

<pre>
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // 函数体和上面完全一样。
}
</pre>

<div class="english">
<p>
This still requires the method to return the updated slice.  We can
eliminate that clumsiness by redefining the method to take a
<i>pointer</i> to a <code>ByteSlice</code> as its receiver, so the
method can overwrite the caller's slice.
</p>
</div>

<p>
这里仍然要求此方法返回更新过的切片。为了消除这种不便，我们可以重定义此方法，
使其接受一个指向 <code>ByteSlice</code> 的<i>指针</i>作为其接收者，
这样此方法就可以覆盖调用者的切片了。
</p>

<div class="english">
<pre>
func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // Body as above, without the return.
    *p = slice
}
</pre>
</div>

<pre>
func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // 主体和前面一样，但没有return。
    *p = slice
}
</pre>

<div class="english">
<p>
In fact, we can do even better.  If we modify our function so it looks
like a standard <code>Write</code> method, like this,
</p>
</div>

<p>
事实上，我们可以做得更好。我们可以修改我们函数使其看起来更像一个标准的 <code>Write</code>
方法，就像这样：
</p>

<div class="english">
<pre>
func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // Again as above.
    *p = slice
    return len(data), nil
}
</pre>
</div>

<pre>
func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // 还是和上面一样。
    *p = slice
    return len(data), nil
}
</pre>

<div class="english">
<p>
then the type <code>*ByteSlice</code> satisfies the standard interface
<code>io.Writer</code>, which is handy.  For instance, we can
print into one.
</p>
</div>

<p>
这样类型 <code>*ByteSlice</code> 就满足标准的接口 <code>io.Writer</code> 了，
这样做有其方便之处。例如，我们可以将它用于打印。
</p>

<pre>
    var b ByteSlice
    fmt.Fprintf(&amp;b, "This hour has %d days\n", 7)
</pre>

<div class="english">
<p>
We pass the address of a <code>ByteSlice</code>
because only <code>*ByteSlice</code> satisfies <code>io.Writer</code>.
The rule about pointers vs. values for receivers is that value methods
can be invoked on pointers and values, but pointer methods can only be
invoked on pointers.  This is because pointer methods can modify the
receiver; invoking them on a copy of the value would cause those
modifications to be discarded.
</p>
</div>

<p>
我们传递了一个 <code>ByteSlice</code> 的地址，因为只有 <code>*ByteSlice</code>
才满足 <code>io.Writer</code>。关于接收者为指针还是值的规则是：值方法可以调用指针和值，
而指针方法只能调用指针。这是由于指针方法可修改接收者，而调用值的副本会让这些修改被抛弃。
</p>

<div class="english">
<p>
By the way, the idea of using <code>Write</code> on a slice of bytes
is implemented by <code>bytes.Buffer</code>.
</p>
</div>

<p>
顺便一提，在字节切片上使用 <code>Write</code> 的想法已被 <code>bytes.Buffer</code> 所实现。
</p>

<div class="english">
<h2 id="interfaces_and_types">Interfaces and other types</h2>
</div>

<h2 id="接口与类型">接口与其它类型</h2>

<div class="english">
<h3 id="interfaces">Interfaces</h3>
</div>

<h3 id="接口">接口</h3>

<div class="english">
<p>
Interfaces in Go provide a way to specify the behavior of an
object: if something can do <em>this</em>, then it can be used
<em>here</em>.  We've seen a couple of simple examples already;
custom printers can be implemented by a <code>String</code> method
while <code>Fprintf</code> can generate output to anything
with a <code>Write</code> method.
Interfaces with only one or two methods are common in Go code, and are
usually given a name derived from the method, such as <code>io.Writer</code>
for something that implements <code>Write</code>.
</p>
</div>

<p>
Go中的接口提供了一种指定一个对象行为的方法：如果某样东西可以完成<em>这个</em>，
那么它就可以用在<em>这里</em>。我们已经见过许多简单的示例了；自定义的打印函数可以通过
<code>String</code> 方法实现，而 <code>Fprintf</code> 则能对任何实现了 <code>Write</code>
方法的东西产生输出。只有一两个方法的接口在Go代码中很常见，且其名称常常从该方法得来，
如 <code>io.Writer</code> 就是实现了 <code>Write</code> 的东西。
</p>

<div class="english">
<p>
A type can implement multiple interfaces.
For instance, a collection can be sorted
by the routines in package <code>sort</code> if it implements
<code>sort.Interface</code>, which contains <code>Len()</code>,
<code>Less(i, j int) bool</code>, and <code>Swap(i, j int)</code>,
and it could also have a custom formatter.
In this contrived example <code>Sequence</code> satisfies both.
</p>
</div>

<p>
一个类型可以实现多个接口。例如一个实现了 <code>sort.Interface</code> 接口的集合就可通过
<code>sort</code> 包中的例程进行排序。该接口包括 <code>Len()</code>、<code>Less(i, j int) bool</code>
以及 <code>Swap(i, j int)</code>，另外，该集合仍然可以有一个自定义的格式化器。
以下特意构建的例子 <code>Sequence</code> 就同时满足这两种情况。
</p>

{{code "/doc/progs/eff_sequence.go" `/^type/` "$"}}

<div class="english">
<h3 id="conversions">Conversions</h3>
</div>

<h3 id="转换">转换</h3>

<div class="english">
<p>
The <code>String</code> method of <code>Sequence</code> is recreating the
work that <code>Sprint</code> already does for slices.  We can share the
effort if we convert the <code>Sequence</code> to a plain
<code>[]int</code> before calling <code>Sprint</code>.
</p>
</div>

<p>
<code>Sequence</code> 的 <code>String</code> 重做了 <code>Sprint</code>
对于切片已实现的工作。如果将 <code>Sequence</code> 转换为一个普通的 <code>[]int</code>，
就能够使用 <code>Sprint</code> 的这种功能。
</p>

<pre>
func (s Sequence) String() string {
    sort.Sort(s)
    return fmt.Sprint([]int(s))
}
</pre>

<div class="english">
<p>
The conversion causes <code>s</code> to be treated as an ordinary slice
and therefore receive the default formatting.
Without the conversion, <code>Sprint</code> would find the
<code>String</code> method of <code>Sequence</code> and recur indefinitely.
Because the two types (<code>Sequence</code> and <code>[]int</code>)
are the same if we ignore the type name, it's legal to convert between them.
The conversion doesn't create a new value, it just temporarily acts
as though the existing value has a new type.
(There are other legal conversions, such as from integer to floating point, that
do create a new value.)
</p>
</div>

<p>
这种转换使 <code>s</code> 可以被当作一个普通的切片使用，因此可使用默认的格式化。
不进行转换的话，<code>Sprint</code> 将为了发现 <code>Sequence</code> 的 <code>String</code>
而无限递归。因为如果忽略类型名的话，这两种类型（<code>Sequence</code> 和 <code>[]int</code>）
是相同的，因此在这两者之间进行转换是合法的。该转换并不会创建一个新值，
它只是暂时地认为已有的值具有一个新类型。（还有另外一些合法的转换也不创建新值，
如从整数转换为浮点数。）
</p>

<div class="english">
<p>
It's an idiom in Go programs to convert the
type of an expression to access a different
set of methods. As an example, we could use the existing
type <code>sort.IntSlice</code> to reduce the entire example
to this:
</p>
</div>

<p>
Go程序常常转换一个表达式的类型以使用不同的方法。例如，我们可使用已有的
<code>sort.IntSlice</code> 简化整个示例：
</p>

<div class="english">
<pre>
type Sequence []int

// Method for printing - sorts the elements before printing
func (s Sequence) String() string {
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
</pre>
</div>

<pre>
type Sequence []int

// 用于打印的方法——在打印之前对元素进行排序
func (s Sequence) String() string {
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
</pre>

<div class="english">
<p>
Now, instead of having <code>Sequence</code> implement multiple
interfaces (sorting and printing), we're using the ability of a data item to be
converted to multiple types (<code>Sequence</code>, <code>sort.IntSlice</code>
and <code>[]int</code>), each of which does some part of the job.
That's more unusual in practice but can be effective.
</p>
</div>

<p>
现在，不必让 <code>Sequence</code> 实现多个接口（打印和排序），
我们可以转而通过将数据项转换为多种类型（<code>Sequence</code>、<code>sort.IntSlice</code>
和 <code>[]int</code>）而使用相应的功能，每次转换都完成一部分工作。
这种做法有点不同寻常，但往往很有效。
</p>

<div class="english">
<h3 id="generality">Generality</h3>
</div>

<h3 id="通用性">通用性</h3>

<div class="english">
<p>
If a type exists only to implement an interface
and has no exported methods beyond that interface,
there is no need to export the type itself.
Exporting just the interface makes it clear that
it's the behavior that matters, not the implementation,
and that other implementations with different properties
can mirror the behavior of the original type.
It also avoids the need to repeat the documentation
on every instance of a common method.
</p>
</div>

<p>
如果有一个只实现了一个接口的类型，并且该类型没有除该接口外其他的导出方法，
则就不需要导出该类型。仅导出接口的方法明确说明了事情的行为，而不关心其实现，
而具有不同属性的其他实现则可以参照原始类型的行为。
这样同样可以避免对一个常用方法的每个实例写重复的文档。
</p>

<div class="english">
<p>
In such cases, the constructor should return an interface value
rather than the implementing type.
As an example, in the hash libraries
both <code>crc32.NewIEEE</code> and <code>adler32.New</code>
return the interface type <code>hash.Hash32</code>.
Substituting the CRC-32 algorithm for Adler-32 in a Go program
requires only changing the constructor call;
the rest of the code is unaffected by the change of algorithm.
</p>
</div>

<p>
在这种情况下，构造器应该返回一个接口值而不是实现的类型。例如，在 <code>hash</code>
库中，<code>crc32.NewIEEE</code> 和 <code>adler32.New</code> 都返回接口类型
<code>hash.Hash32</code>。在Go程序中，将CRC-32算法替换为Adler-32只需要更改构造器调用，
而其余的代码则不受算法更改的影响。
</p>

<div class="english">
<p>
A similar approach allows the streaming cipher algorithms
in the various <code>crypto</code> packages to be
separated from the block ciphers they chain together.
The <code>Block</code> interface
in the <code>crypto/cipher</code> package specifies the
behavior of a block cipher, which provides encryption
of a single block of data.
Then, by analogy with the <code>bufio</code> package,
cipher packages that implement this interface
can be used to construct streaming ciphers, represented
by the <code>Stream</code> interface, without
knowing the details of the block encryption.
</p>
</div>

<p>
同样的方式使各个 <code>crypto</code> 包中的流加密算法与它们链接起来形成的块加密区分开来。
<code>crypto/cipher</code> 包中的 <code>Block </code> 接口指定了一个块加密行为，
它提供对单个数据块的加密。然后，与 <code>bufio</code> 包类似，
实现此接口的加密包可以被用于构建流加密，这由 <code>Stream</code> 表示，并且不必知道块加密的细节。
</p>

<div class="english">
<p>
The  <code>crypto/cipher</code> interfaces look like this:
</p>
</div>

<p>
<code>crypto/cipher</code> 接口看起来就像这样：
</p>

<pre>
type Block interface {
    BlockSize() int
    Encrypt(src, dst []byte)
    Decrypt(src, dst []byte)
}

type Stream interface {
    XORKeyStream(dst, src []byte)
}
</pre>

<div class="english">
<p>
Here's the definition of the counter mode (CTR) stream,
which turns a block cipher into a streaming cipher; notice
that the block cipher's details are abstracted away:
</p>
</div>

<p>
这里是计数模式（CTR）流的定义，它将一个块加密转变为流加密；注意块加密的细节是抽象的：
</p>

<div class="english">
<pre>
// NewCTR returns a Stream that encrypts/decrypts using the given Block in
// counter mode. The length of iv must be the same as the Block's block size.
func NewCTR(block Block, iv []byte) Stream
</pre>
</div>

<pre>
// NewCTR 返回一个 Stream，encrypts/decrypts 在计数模式中使用给定的块。
// iv 的长度必须与该 Block 块的大小相同
func NewCTR(block Block, iv []byte) Stream
</pre>

<div class="english">
<p>
<code>NewCTR</code> applies not
just to one specific encryption algorithm and data source but to any
implementation of the <code>Block</code> interface and any
<code>Stream</code>.  Because they return
interface values, replacing CTR
encryption with other encryption modes is a localized change.  The constructor
calls must be edited, but because the surrounding code must treat the result only
as a <code>Stream</code>, it won't notice the difference.
</p>
</div>

<p>
<code>NewCTR</code> 使用的加密算法和数据源并没有被特别限定，而是任何 <code>Block</code>
接口的实现和任意的 <code>Stream</code>。由于它们返回了接口值，
将CTR加密替换为其它的加密模式将只是一个局部更改。必须要修改其构造器调用，
但由于外围的代码仅将结果看作一个 <code>Stream</code>，它将不会在意已完成的改动。
</p>

<div class="english">
<h3 id="interface_methods">Interfaces and methods</h3>
</div>

<h3 id="接口方法">接口与方法</h3>

<div class="english">
<p>
Since almost anything can have methods attached, almost anything can
satisfy an interface.  One illustrative example is in the <code>http</code>
package, which defines the <code>Handler</code> interface.  Any object
that implements <code>Handler</code> can serve HTTP requests.
</p>
</div>

<p>
由于几乎所有的东西都可以附加方法，因此几乎所有的东西都能满足一个接口。<code>http</code>
包中就有一个示例，它定义了 <code>Handler</code> 接口。任何实现了 <code>Handler</code>
的对象都能服务HTTP请求。
</p>

<pre>
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
</pre>

<div class="english">
<p>
<code>ResponseWriter</code> is itself an interface that provides access
to the methods needed to return the response to the client.
Those methods include the standard <code>Write</code> method, so an
<code>http.ResponseWriter</code> can be used wherever an <code>io.Writer</code>
can be used.
<code>Request</code> is a struct containing a parsed representation
of the request from the client.
</p>
</div>

<p>
<code>ResponseWriter</code> 本身是一个接口，它提供了用于返回客户端响应的访问方法。
这些包括标准的 <code>Write</code> 方法，因此一个 <code>http.ResponseWriter</code>
可被用于所有可使用 <code>io.Writer</code> 的地方。<code>Request</code> 是一个结构，
它包含了对来自客户端请求解析后的表示。
</p>

<div class="english">
<p>
For brevity, let's ignore POSTs and assume HTTP requests are always
GETs; that simplification does not affect the way the handlers are
set up.  Here's a trivial but complete implementation of a handler to
count the number of times the
page is visited.
</p>
</div>

<p>
为了简明起见，让我们忽略POST而假设HTTP请求始终是GET；这种简化并不影响处理程序（handler）的构建方式。
以下是一个很小但却完整的handler实现，它可以对页面的访问次数进行计数。
</p>

<div class="english">
<pre>
// Simple counter server.
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
</pre>
</div>

<pre>
// 简单的计数器服务。
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
</pre>

<div class="english">
<p>
(Keeping with our theme, note how <code>Fprintf</code> can print to an
<code>http.ResponseWriter</code>.)
For reference, here's how to attach such a server to a node on the URL tree.
</p>
</div>

<p>
（注意 <code>Fprintf</code> 能打印到一个 <code>http.ResponseWriter</code> 中。）
作为参考，这里演示了如何将这样一个服务器程序加到URL树的一个节点上。
</p>

<pre>
import "net/http"
...
ctr := new(Counter)
http.Handle("/counter", ctr)
</pre>

<div class="english">
<p>
But why make <code>Counter</code> a struct?  An integer is all that's needed.
(The receiver needs to be a pointer so the increment is visible to the caller.)
</p>
</div>

<p>
但为什么要使 <code>Counter</code> 成为一个结构呢？只需要一个整数就够了。
（接受者需要是一个指针，这样该增加值对调用者是可见的。）
</p>

<div class="english">
<pre>
// Simpler counter server.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    *ctr++
    fmt.Fprintf(w, "counter = %d\n", *ctr)
}
</pre>
</div>

<pre>
// 简单的计数器服务
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    *ctr++
    fmt.Fprintf(w, "counter = %d\n", *ctr)
}
</pre>

<div class="english">
<p>
What if your program has some internal state that needs to be notified that a page
has been visited?  Tie a channel to the web page.
</p>
</div>

<p>
当页面被访问后怎样通知程序去更新一些内部状态呢？请为Web页面连上一个信道。
</p>

<div class="english">
<pre>
// A channel that sends a notification on each visit.
// (Probably want the channel to be buffered.)
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ch &lt;- req
    fmt.Fprint(w, "notification sent")
}
</pre>
</div>

<pre>
// 一个每次访问都发送通知的信道。（可能需要该信道进行缓存。）
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ch &lt;- req
    fmt.Fprint(w, "notification sent")
}
</pre>

<div class="english">
<p>
Finally, let's say we wanted to present on <code>/args</code> the arguments
used when invoking the server binary.
It's easy to write a function to print the arguments.
</p>
</div>

<p>
最后，假如我们想在调用服务器二进制文件时显示 <code>/args</code> 中的实参。
可以很容易地写一个函数来打印这些实参。
</p>

<pre>
func ArgServer() {
    for _, s := range os.Args {
        fmt.Println(s)
    }
}
</pre>

<div class="english">
<p>
How do we turn that into an HTTP server?  We could make <code>ArgServer</code>
a method of some type whose value we ignore, but there's a cleaner way.
Since we can define a method for any type except pointers and interfaces,
we can write a method for a function.
The <code>http</code> package contains this code:
</p>
</div>

<p>
如何将这些放入HTTP服务器中呢？我们可以将 <code>ArgServer</code> 变成某些类型的一个方法，
而这些类型的值可以忽略，但也有一个更整洁的做法。由于我们可以为除了指针和接口的其他任何类型定义方法，
也即我们可以为一个函数写一个方法。<code>http</code> 包中包含以下代码：
</p>

<div class="english">
<pre>
// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers.  If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler object that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(c, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
    f(w, req)
}
</pre>
</div>

<pre>
// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers.  If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler object that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(c, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
    f(w, req)
}
</pre>

<div class="english">
<p>
<code>HandlerFunc</code> is a type with a method, <code>ServeHTTP</code>,
so values of that type can serve HTTP requests.  Look at the implementation
of the method: the receiver is a function, <code>f</code>, and the method
calls <code>f</code>.  That may seem odd but it's not that different from, say,
the receiver being a channel and the method sending on the channel.
</p>
</div>

<p>
<code>HandlerFunc</code> 类型有一个 <code>ServeHTTP</code> 方法，因此该类型的值可以为HTTP请求提供服务。
查看该方法的实现：其接受者是一个函数 <code>f</code>，并且该方法调用了 <code>f</code>。
这看起来有点奇怪，但却与接受者为信道而方法发送到此信道并没有什么不同。
</p>

<div class="english">
<p>
To make <code>ArgServer</code> into an HTTP server, we first modify it
to have the right signature.
</p>
</div>

<p>
要使 <code>ArgServer</code> 变为一个HTTP服务器，需要对其进行修改，使其拥有恰当的签名。
</p>

<pre>
// Argument server.
func ArgServer(w http.ResponseWriter, req *http.Request) {
    for _, s := range os.Args {
        fmt.Fprintln(w, s)
    }
}
</pre>

<div class="english">
<p>
<code>ArgServer</code> now has same signature as <code>HandlerFunc</code>,
so it can be converted to that type to access its methods,
just as we converted <code>Sequence</code> to <code>IntSlice</code>
to access <code>IntSlice.Sort</code>.
The code to set it up is concise:
</p>
</div>

<p>
现在 <code>ArgServer</code> 的签名与 <code>HandlerFunc</code>
一样了，这样就能其转化为此类型以访问其方法，就像将 <code>Sequence</code> 转换为
<code>IntSlice</code> 并访问 <code>IntSlice.Sort</code> 一样。设置代码很简洁：
</p>

<pre>
http.Handle("/args", http.HandlerFunc(ArgServer))
</pre>

<div class="english">
<p>
When someone visits the page <code>/args</code>,
the handler installed at that page has value <code>ArgServer</code>
and type <code>HandlerFunc</code>.
The HTTP server will invoke the method <code>ServeHTTP</code>
of that type, with <code>ArgServer</code> as the receiver, which will in turn call
<code>ArgServer</code> (via the invocation <code>f(c, req)</code>
inside <code>HandlerFunc.ServeHTTP</code>).
The arguments will then be displayed.
</p>
</div>

<p>
当某人访问 <code>/args</code> 页面时，安装在此页面的处理程序（handler）的值为
<code>ArgServer</code>，类型为 <code>HandlerFunc</code>。HTTP服务器将调用该类型的
<code>ServeHTTP</code>方法，并以 <code>ArgServer</code>作为接受者，
这将相应地调用 <code>ArgServer</code>（通过调用 <code>HandlerFunc.ServeHTTP</code>
中的 <code>f(c, req)</code>）。进而将显示各实参。
</p>

<div class="english">
<p>
In this section we have made an HTTP server from a struct, an integer,
a channel, and a function, all because interfaces are just sets of
methods, which can be defined for (almost) any type.
</p>
</div>

<p>
在该部分中，我们可以从一个结构、整数、信道及函数构建了一个HTTP服务器，
这全都因为接口就是方法的集合，它可以针对（几乎）任何类型定义。
</p>

<div class="english">
<h2 id="embedding">Embedding</h2>
</div>

<h2 id="嵌入">嵌入</h2>

<div class="english">
<p>
Go does not provide the typical, type-driven notion of subclassing,
but it does have the ability to &ldquo;borrow&rdquo; pieces of an
implementation by <em>embedding</em> types within a struct or
interface.
</p>
</div>

<p>
Go不提供典型的、类型驱动的子类化概念，但它通过在一个结构或接口中 <em>嵌入</em>
类型而能够从前者的实现中“借用”一些东西。
</p>

<div class="english">
<p>
Interface embedding is very simple.
We've mentioned the <code>io.Reader</code> and <code>io.Writer</code> interfaces before;
here are their definitions.
</p>
</div>

<p>
接口的嵌入非常简单。前面我们已经提到了 <code>io.Reader</code> 和 <code>io.Writer</code>
接口。这里是它们的定义。
</p>

<pre>
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
</pre>

<div class="english">
<p>
The <code>io</code> package also exports several other interfaces
that specify objects that can implement several such methods.
For instance, there is <code>io.ReadWriter</code>, an interface
containing both <code>Read</code> and <code>Write</code>.
We could specify <code>io.ReadWriter</code> by listing the
two methods explicitly, but it's easier and more evocative
to embed the two interfaces to form the new one, like this:
</p>
</div>

<p>
<code>io</code> 包同时也导出了几个其他的接口来指定对象能够实现的几个类似的方法。
例如，<code>io.ReadWriter</code> 就是一个包含 <code>Read</code> 和 <code>Write</code>
的接口。我们可以通过显式地列出这两个方法来定义 <code>io.ReadWriter</code>，
但更简便且更被理解的是嵌入这两个接口而形成新的一个，如下所示：
</p>

<div class="english">
<pre>
// ReadWriter is the interface that combines the Reader and Writer interfaces.
type ReadWriter interface {
    Reader
    Writer
}
</pre>
</div>

<pre>
// ReadWriter is the interface that combines the Reader and Writer interfaces.
type ReadWriter interface {
    Reader
    Writer
}
</pre>

<div class="english">
<p>
This says just what it looks like: A <code>ReadWriter</code> can do
what a <code>Reader</code> does <em>and</em> what a <code>Writer</code>
does; it is a union of the embedded interfaces (which must be disjoint
sets of methods).
Only interfaces can be embedded within interfaces.
</p>
</div>

<p>
正如该代码看起来那样：<code>ReadWriter</code> 能够完成 <code>Reader</code>
<em>和</em> <code>Writer</code> 所完成的工作；它是被嵌入接口（它们的方法不能有交集）的一个并集。
只有接口才能被嵌入到接口中。
</p>

<div class="english">
<p>
The same basic idea applies to structs, but with more far-reaching
implications.  The <code>bufio</code> package has two struct types,
<code>bufio.Reader</code> and <code>bufio.Writer</code>, each of
which of course implements the analogous interfaces from package
<code>io</code>.
And <code>bufio</code> also implements a buffered reader/writer,
which it does by combining a reader and a writer into one struct
using embedding: it lists the types within the struct
but does not give them field names.
</p>
</div>

<p>
同样的理念也可被应用于结构中，但却有更多的深意。<code>bufio</code> 包有两个结构类型，
<code>bufio.Reader</code> 和 <code>bufio.Writer</code>，两者各自实现了来自 <code>io</code>
的对应接口。另外 <code>bufio</code> 还实现了一个缓冲的 <code>reader/writer</code>，
这是使用嵌入将一个 <code>reader</code> 和一个 <code>writer</code>
组合成一个结构：它在结构内列出了这些类型但并没有给出这些类型的字段名称。
</p>

<div class="english">
<pre>
// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
    *Reader  // *bufio.Reader
    *Writer  // *bufio.Writer
}
</pre>
</div>

<pre>
// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
    *Reader  // *bufio.Reader
    *Writer  // *bufio.Writer
}
</pre>

<div class="english">
<p>
The embedded elements are pointers to structs and of course
must be initialized to point to valid structs before they
can be used.
The <code>ReadWriter</code> struct could be written as
</p>
</div>

<p>
若被嵌入的元素是指向结构的指针，则在可以使用这些类型之前必须将其初始化，使它们指向合法的结构。
<code>ReadWriter</code> 结构也可以如下方式定义
</p>

<pre>
type ReadWriter struct {
    reader *Reader
    writer *Writer
}
</pre>

<div class="english">
<p>
but then to promote the methods of the fields and to
satisfy the <code>io</code> interfaces, we would also need
to provide forwarding methods, like this:
</p>
</div>

<p>
但若要使字段的方法提升为结构的方法，以使结构满足 <code>io</code>
接口，我们还需要提供转发的方法，如下所示：
</p>

<pre>
func (rw *ReadWriter) Read(p []byte) (n int, err error) {
    return rw.reader.Read(p)
}
</pre>

<div class="english">
<p>
By embedding the structs directly, we avoid this bookkeeping.
The methods of embedded types come along for free, which means that <code>bufio.ReadWriter</code>
not only has the methods of <code>bufio.Reader</code> and <code>bufio.Writer</code>,
it also satisfies all three interfaces:
<code>io.Reader</code>,
<code>io.Writer</code>, and
<code>io.ReadWriter</code>.
</p>
</div>

<p>
而通过直接嵌入结构，就可以不必这么繁琐。嵌入类型的方法被自动继承得来，这意味着
<code>bufio.ReadWriter</code> 不仅具有 <code>bufio.Reader</code> 和 <code>bufio.Writer</code>
方法，同时还满足三个接口：<code>io.Reader</code>、<code>io.Writer</code>
和 <code>io.ReadWriter</code>。
</p>

<div class="english">
<p>
There's an important way in which embedding differs from subclassing.  When we embed a type,
the methods of that type become methods of the outer type,
but when they are invoked the receiver of the method is the inner type, not the outer one.
In our example, when the <code>Read</code> method of a <code>bufio.ReadWriter</code> is
invoked, it has exactly the same effect as the forwarding method written out above;
the receiver is the <code>reader</code> field of the <code>ReadWriter</code>, not the
<code>ReadWriter</code> itself.
</p>
</div>

<p>
嵌入与子类化有一个重大不同。当嵌入一个类型时，此类型的方法变为外部一级类型的方法，
而当这些方法被调用时，它们的接受者是内部一级的内省，而非外部一级。在上例中，当调用
<code>bufio.ReadWriter</code> 的 <code>Read</code>方法时，将出现与以上转发的方法相同的结果；
其接受者为 <code>ReadWriter</code> 的 <code>reader</code> 字段，而非<code>ReadWriter</code>本身。
</p>

<div class="english">
<p>
Embedding can also be a simple convenience.
This example shows an embedded field alongside a regular, named field.
</p>
</div>

<p>
嵌入还有另外一个小便利，如下例子一个嵌入字段以及一个正常的命名字段。
</p>

<pre>
type Job struct {
    Command string
    *log.Logger
}
</pre>

<div class="english">
<p>
The <code>Job</code> type now has the <code>Log</code>, <code>Logf</code>
and other
methods of <code>*log.Logger</code>.  We could have given the <code>Logger</code>
a field name, of course, but it's not necessary to do so.  And now, once
initialized, we can
log to the <code>Job</code>:
</p>
</div>

<p>
现在 <code>Job</code> 类型具有 <code>*log.Logger</code> 的 <code>Log</code> 和
<code>Logf</code> 等方法。我们当然也可以给 <code>Logger</code> 一个字段名称，但却没有必要这么做。
现在，一旦完成初始化，我们就可以对 <code>Job</code> 进行日志记录：
</p>

<pre>
job.Log("starting now...")
</pre>

<div class="english">
<p>
The <code>Logger</code> is a regular field of the struct and we can initialize
it in the usual way with a constructor,
</p>
</div>

<p>
<code>Logger</code> 是一个结构的一个常规的字段，我们可以通过一个构造器使用常规的方法初始化它，
</p>

<pre>
func NewJob(command string, logger *log.Logger) *Job {
    return &amp;Job{command, logger}
}
</pre>

<div class="english">
<p>
or with a composite literal,
</p>
</div>

<p>
或者使用复合字面，
</p>

<pre>
job := &amp;Job{command, log.New(os.Stderr, "Job: ", log.Ldate)}
</pre>

<div class="english">
<p>
If we need to refer to an embedded field directly, the type name of the field,
ignoring the package qualifier, serves as a field name.  If we needed to access the
<code>*log.Logger</code> of a <code>Job</code> variable <code>job</code>,
we would write <code>job.Logger</code>.
This would be useful if we wanted to refine the methods of <code>Logger</code>.
</p>
</div>

<p>
如果我们需要直接引用嵌入的字段，就使用字段的类型名称，像使用字段名称一样省略包限定词。
如果我们需要访问 <code>Job</code> 类型的 <code>job</code> 变量的 <code>*log.Logger</code>，
写成 <code>job.Logger</code> 就行了。当我们想要改进 <code>Logger</code> 方法时，这种方式将很有用。
</p>

<pre>
func (job *Job) Logf(format string, args ...interface{}) {
    job.Logger.Logf("%q: %s", job.Command, fmt.Sprintf(format, args...))
}
</pre>

<div class="english">
<p>
Embedding types introduces the problem of name conflicts but the rules to resolve
them are simple.
First, a field or method <code>X</code> hides any other item <code>X</code> in a more deeply
nested part of the type.
If <code>log.Logger</code> contained a field or method called <code>Command</code>, the <code>Command</code> field
of <code>Job</code> would dominate it.
</p>
</div>

<p>
嵌入类型会引入类型冲突的问题，但解决的规则也很简单。首先，一个字段或方法 <code>X</code>
将隐藏更深层嵌入类型的 <code>X</code> 项。如果 <code>log.Logger</code>包含一个名称为
<code>Command</code> 的字段或方法，将只使用 <code>Job</code> 的 <code>Command</code> 字段。
</p>

<div class="english">
<p>
Second, if the same name appears at the same nesting level, it is usually an error;
it would be erroneous to embed <code>log.Logger</code> if the <code>Job</code> struct
contained another field or method called <code>Logger</code>.
However, if the duplicate name is never mentioned in the program outside the type definition, it is OK.
This qualification provides some protection against changes made to types embedded from outside; there
is no problem if a field is added that conflicts with another field in another subtype if neither field
is ever used.
</p>
</div>

<p>
其次，如果相同的嵌套级别上出现相同的名称，这将出现一个错误；如果 <code>Job</code>
结构包含另外一个名称为 <code>Logger</code> 的字段或方法，则再嵌入 <code>log.Logger</code>
将产生错误。但是，如果重复的名字从未在类型定义以外的程序中用到过，就不会出现问题。
这种限定对外部嵌入类型更改的一些保护；如果所添加的一个字段与另一个次级类型中的另一个字段产生冲突，
但两个字段都没有被用到过，就不会发生问题。
</p>


<div class="english">
<h2 id="concurrency">Concurrency</h2>
</div>

<h2 id="并发">并发</h2>

<div class="english">
<h3 id="sharing">Share by communicating</h3>
</div>

<h3 id="共享">通过通信共享</h3>

<div class="english">
<p>
Concurrent programming is a large topic and there is space only for some
Go-specific highlights here.
</p>
</div>

<p>
并发编程是一个大论题，由于篇幅限制，这里只讨论一些Go特有的东西。
</p>

<div class="english">
<p>
Concurrent programming in many environments is made difficult by the
subtleties required to implement correct access to shared variables.  Go encourages
a different approach in which shared values are passed around on channels
and, in fact, never actively shared by separate threads of execution.
Only one goroutine has access to the value at any given time.
Data races cannot occur, by design.
To encourage this way of thinking we have reduced it to a slogan:
</p>
</div>

<p>
要实现对共享变量的正确访问非常复杂，这使得多数环境中的并发编程都很困难。
Go尝试一种不同的方法，其中共享的值通过信道进行传递，事实上，
从来没有什么东西会被多个执行的线程一直共享。在任何给定的时间，只能有一个Go程访问该值。
这样就从设计上杜绝了数据竞争。为了鼓励这种思考方式，我们将其简化为一个口号：
</p>

<div class="english">
<blockquote>
Do not communicate by sharing memory;
instead, share memory by communicating.
</blockquote>
</div>

<blockquote>
不要通过共享内存来进行通信，而应通过通信来共享内存。
</blockquote>

<div class="english">
<p>
This approach can be taken too far.  Reference counts may be best done
by putting a mutex around an integer variable, for instance.  But as a
high-level approach, using channels to control access makes it easier
to write clear, correct programs.
</p>
</div>

<p>
这种方式有很多好处。例如，虽然通过将一个整型变量设置为互斥量来实现引用计数是一种非常好的方法。
但在更高级的方法中，使用信道来控制访问可以更容易地编写整洁且正确的程序。
</p>

<div class="english">
<p>
One way to think about this model is to consider a typical single-threaded
program running on one CPU. It has no need for synchronization primitives.
Now run another such instance; it too needs no synchronization.  Now let those
two communicate; if the communication is the synchronizer, there's still no need
for other synchronization.  Unix pipelines, for example, fit this model
perfectly.  Although Go's approach to concurrency originates in Hoare's
Communicating Sequential Processes (CSP),
it can also be seen as a type-safe generalization of Unix pipes.
</p>
</div>

<p>
来说明此模型的一个方法是考虑一个运行在单CPU上的典型的单线程程序。它不需要什么同步机制。
现在运行另外一个同样的程序；它同样也不需要同步。然后让这两个程序通信；
如果通信正好合拍，同样也不需要其他的同步。例如，Unix的管道就完美地符合此种模型。
尽管Go的并发概念始自Hoare的通信顺序处理（CSP），它同样可被看作是实现了类型安全的Unix管道。
</p>

<div class="english">
<h3 id="goroutines">Goroutines</h3>
</div>

<h3 id="Go程">Go程</h3>

<div class="english">
<p>
They're called <em>goroutines</em> because the existing
terms&mdash;threads, coroutines, processes, and so on&mdash;convey
inaccurate connotations.  A goroutine has a simple model: it is a
function executing concurrently with other goroutines in the same
address space.  It is lightweight, costing little more than the
allocation of stack space.
And the stacks start small, so they are cheap, and grow
by allocating (and freeing) heap storage as required.
</p>
</div>

<p>
之所以叫<em>Go程</em>是因为已有的一些术语——线程、协程、进程等——可能会传达不准确的涵义。
Go程具有简单的模型：它是一个与其他Go程在同一地址空间中并发执行的函数。
相对于在栈空间分配内存，这样更轻量级且消耗少。这样起始时栈就可以更小，因此也更轻省，
随着程序的增长，可以根据需要在堆上分配（和释放）存储空间。
</p>

<div class="english">
<p>
Goroutines are multiplexed onto multiple OS threads so if one should
block, such as while waiting for I/O, others continue to run.  Their
design hides many of the complexities of thread creation and
management.
</p>
</div>

<p>
Go程可复用多个操作系统线程，因此如果其中的一个被阻塞，比如等待I/O，其他的会继续运行。
这种设计隐藏了许多线程创建和管理的复杂性。
</p>

<div class="english">
<p>
Prefix a function or method call with the <code>go</code>
keyword to run the call in a new goroutine.
When the call completes, the goroutine
exits, silently.  (The effect is similar to the Unix shell's
<code>&amp;</code> notation for running a command in the
background.)
</p>
</div>

<p>
在函数或方法调用的前面加上 <code>go</code> 关键字可在一个新的Go程中运行调用。
当调用完成后，此Go程将会静默地退出。（这种效果与Unix shell的 <code>&amp;</code>
符号可在后台运行命令的概念相似。）
</p>

<div class="english">
<pre>
go list.Sort()  // run list.Sort concurrently; don't wait for it.
</pre>
</div>

<pre>
go list.Sort()  // run list.Sort concurrently; don't wait for it.
</pre>

<div class="english">
<p>
A function literal can be handy in a goroutine invocation.
</p>
</div>

<p>
在Go程调用中使用函数字面会非常方便。
</p>

<div class="english">
<pre>
func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // Note the parentheses - must call the function.
}
</pre>
</div>

<pre>
func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // Note the parentheses - must call the function.
}
</pre>

<div class="english">
<p>
In Go, function literals are closures: the implementation makes
sure the variables referred to by the function survive as long as they are active.
</p>
</div>

<p>
在Go中，函数字面就是闭包：其实现能确保被此函数引用的变量只要是活动（能再次被使用）的就一直存在。
</p>

<div class="english">
<p>
These examples aren't too practical because the functions have no way of signaling
completion.  For that, we need channels.
</p>
</div>

<p>
由于函数在完成后没办法发出信号，这些例子并没有什么实用性。要做到更有用，就需要信道。
</p>

<div class="english">
<h3 id="channels">Channels</h3>
</div>

<h3 id="信道">信道</h3>

<div class="english">
<p>
Like maps, channels are a reference type and are allocated with <code>make</code>.
If an optional integer parameter is provided, it sets the buffer size for the channel.
The default is zero, for an unbuffered or synchronous channel.
</p>
</div>

<p>
与映射一样，信道是引用类型，需要使用 <code>make</code> 分配内存。
如果同时提供了一个可选的整型形参，它将为信道设置缓存的大小。
对一个未被缓存的同步的信道，其默认值是零。
</p>

<div class="english">
<pre>
ci := make(chan int)            // unbuffered channel of integers
cj := make(chan int, 0)         // unbuffered channel of integers
cs := make(chan *os.File, 100)  // buffered channel of pointers to Files
</pre>
</div>

<pre>
ci := make(chan int)            // unbuffered channel of integers
cj := make(chan int, 0)         // unbuffered channel of integers
cs := make(chan *os.File, 100)  // buffered channel of pointers to Files
</pre>

<div class="english">
<p>
Channels combine communication&mdash;the exchange of a value&mdash;with
synchronization&mdash;guaranteeing that two calculations (goroutines) are in
a known state.
</p>
</div>

<p>
信道将以下事情组合在一起：通信——值的交换——同步——确保两个计算（Go程）的状态可知。
</p>

<div class="english">
<p>
There are lots of nice idioms using channels.  Here's one to get us started.
In the previous section we launched a sort in the background. A channel
can allow the launching goroutine to wait for the sort to complete.
</p>
</div>

<p>
使用信道有许多章法。这里先从其中的一个出发。在上一节中我们在后台启动了一个排序Go程。
可以通过使用一个信道来使得启动该排序例程的Go程等待着排序的完成。
</p>

<div class="english">
<pre>
c := make(chan int)  // Allocate a channel.
// Start the sort in a goroutine; when it completes, signal on the channel.
go func() {
    list.Sort()
    c &lt;- 1  // Send a signal; value does not matter.
}()
doSomethingForAWhile()
&lt;-c   // Wait for sort to finish; discard sent value.
</pre>
</div>

<pre>
c := make(chan int)  // Allocate a channel.
// Start the sort in a goroutine; when it completes, signal on the channel.
go func() {
    list.Sort()
    c &lt;- 1  // Send a signal; value does not matter.
}()
doSomethingForAWhile()
&lt;-c   // Wait for sort to finish; discard sent value.
</pre>

<div class="english">
<p>
Receivers always block until there is data to receive.
If the channel is unbuffered, the sender blocks until the receiver has
received the value.
If the channel has a buffer, the sender blocks only until the
value has been copied to the buffer; if the buffer is full, this
means waiting until some receiver has retrieved a value.
</p>
</div>

<p>
接收者将一直被阻塞，直到收到数据。如果此信道未被缓存，发送者将一直被阻塞直到接收者收到了此值。
如果信道有一个缓存，发送者仅在值被复制到缓存之前被阻塞；如果缓存满了，
这就意味着需要等到一些接收者取回了一个值。
</p>

<div class="english">
<p>
A buffered channel can be used like a semaphore, for instance to
limit throughput.  In this example, incoming requests are passed
to <code>handle</code>, which sends a value into the channel, processes
the request, and then receives a value from the channel.
The capacity of the channel buffer limits the number of
simultaneous calls to <code>process</code>.
</p>
</div>

<p>
一个缓存的信道可以被像信号等那样用来进行限制通过。在下例中，进入的请求被传递到
<code>handle</code>，它将向信道发送一个值，然后处理请求，再然后从信道接收一个值。
信道缓存的容量限制了同时调用 <code>process</code> 的数量。
</p>

<div class="english">
<pre>
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem &lt;- 1    // Wait for active queue to drain.
    process(r)  // May take a long time.
    &lt;-sem       // Done; enable next request to run.
}

func Serve(queue chan *Request) {
    for {
        req := &lt;-queue
        go handle(req)  // Don't wait for handle to finish.
    }
}
</pre>
</div>

<pre>
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem &lt;- 1    // Wait for active queue to drain.
    process(r)  // May take a long time.
    &lt;-sem       // Done; enable next request to run.
}

func Serve(queue chan *Request) {
    for {
        req := &lt;-queue
        go handle(req)  // Don't wait for handle to finish.
    }
}
</pre>

<div class="english">
<p>
Here's the same idea implemented by starting a fixed
number of <code>handle</code> goroutines all reading from the request
channel.
The number of goroutines limits the number of simultaneous
calls to <code>process</code>.
This <code>Serve</code> function also accepts a channel on which
it will be told to exit; after launching the goroutines it blocks
receiving from that channel.
</p>
</div>

<p>
基于同样的概念，下例启动了固定数量的 <code>handle</code> Go程，这些Go程都读取请求的信道。
Go程的数量决定了同时调用 <code>process</code> 的数量。这里的 <code>Serve</code>
函数同样接受一个信道，该信道将告知此函数何时退出；在启动Go程后，它将不再从该信道上接收东西。
</p>

<pre>
func handle(queue chan *Request) {
    for r := range queue {
        process(r)
    }
}

func Serve(clientRequests chan *Request, quit chan bool) {
    // Start handlers
    for i := 0; i &lt; MaxOutstanding; i++ {
        go handle(clientRequests)
    }
    &lt;-quit  // Wait to be told to exit.
}
</pre>

<div class="english">
<h3 id="chan_of_chan">Channels of channels</h3>
</div>

<h3 id="信道的信道">信道的信道</h3>

<div class="english">
<p>
One of the most important properties of Go is that
a channel is a first-class value that can be allocated and passed
around like any other.  A common use of this property is
to implement safe, parallel demultiplexing.
</p>
</div>

<p>
Go最重要的特性之一就是信道根本就是值，它可以像其他值一样被分配内存并进行传递。
常使用这种特性来实现安全、并行的多路化。
</p>

<div class="english">
<p>
In the example in the previous section, <code>handle</code> was
an idealized handler for a request but we didn't define the
type it was handling.  If that type includes a channel on which
to reply, each client can provide its own path for the answer.
Here's a schematic definition of type <code>Request</code>.
</p>
</div>

<p>
在上一节的例子中，<code>handle</code> 是请求的理想化的处理程序，
但我们并没有定义其所处理请求的类型。如该该类型包括它要回复的一个信道，
每个客户端都能提供自己的回答路径。以下是对类型 <code>Request</code> 定义的一个示意。
</p>

<pre>
type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
</pre>

<div class="english">
<p>
The client provides a function and its arguments, as well as
a channel inside the request object on which to receive the answer.
</p>
</div>

<p>
客户端提供了一个函数和它的实参，以及一个包含在用来进行接收回答的请求对象中的信道。
</p>

<div class="english">
<pre>
func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &amp;Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests &lt;- request
// Wait for response.
fmt.Printf("answer: %d\n", &lt;-request.resultChan)
</pre>
</div>

<pre>
func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &amp;Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests &lt;- request
// Wait for response.
fmt.Printf("answer: %d\n", &lt;-request.resultChan)
</pre>

<div class="english">
<p>
On the server side, the handler function is the only thing that changes.
</p>
</div>

<p>
在服务器端，仅仅对处理器函数进行更改。
</p>

<pre>
func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan &lt;- req.f(req.args)
    }
}
</pre>

<div class="english">
<p>
There's clearly a lot more to do to make it realistic, but this
code is a framework for a rate-limited, parallel, non-blocking RPC
system, and there's not a mutex in sight.
</p>
</div>

<p>
很显然实际应用中还需要做很多的工作，但这里的代码构建了一个针对限制速率的、并行的、
非阻塞的RPC（远程过程调用）系统的框架，并且这里看不到一个使用互斥的情况。
</p>

<div class="english">
<h3 id="parallel">Parallelization</h3>
</div>

<h3 id="并行化">并行化</h3>

<div class="english">
<p>
Another application of these ideas is to parallelize a calculation
across multiple CPU cores.  If the calculation can be broken into
separate pieces that can execute independently, it can be parallelized,
with a channel to signal when each piece completes.
</p>
</div>

<p>
此种概念的另一种应用就是在多个CPU内核上实现并行计算。如果计算可以被拆分为多个可独立执行的块，
它就可以进行并行处理，当每块计算完成后，就使用一个信道来标记。
</p>

<div class="english">
<p>
Let's say we have an expensive operation to perform on a vector of items,
and that the value of the operation on each item is independent,
as in this idealized example.
</p>
</div>

<p>
假设我们需要对一个向量的多个子项行大量操作，并且对每个子项的操作值是相互独立的，
以下是一个理想化的示例。
</p>

<div class="english">
<pre>
type Vector []float64

// Apply the operation to v[i], v[i+1] ... up to v[n-1].
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i &lt; n; i++ {
        v[i] += u.Op(v[i])
    }
    c &lt;- 1    // signal that this piece is done
}
</pre>
</div>

<pre>
type Vector []float64

// Apply the operation to v[i], v[i+1] ... up to v[n-1].
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i &lt; n; i++ {
        v[i] += u.Op(v[i])
    }
    c &lt;- 1    // signal that this piece is done
}
</pre>

<div class="english">
<p>
We launch the pieces independently in a loop, one per CPU.
They can complete in any order but it doesn't matter; we just
count the completion signals by draining the channel after
launching all the goroutines.
</p>
</div>

<p>
我们在一个循环中独立地启动各个计算块，每个CPU对应对应一块。它们的完成顺序可以是任意的；
我们只需要在启动所有Go程后通过从信道得到的信号计算出已完成计算块的数量就行了。
</p>

<div class="english">
<pre>
const NCPU = 4  // number of CPU cores

func (v Vector) DoAll(u Vector) {
    c := make(chan int, NCPU)  // Buffering optional but sensible.
    for i := 0; i &lt; NCPU; i++ {
        go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)
    }
    // Drain the channel.
    for i := 0; i &lt; NCPU; i++ {
        &lt;-c    // wait for one task to complete
    }
    // All done.
}

</pre>
</div>

<pre>
const NCPU = 4  // number of CPU cores

func (v Vector) DoAll(u Vector) {
    c := make(chan int, NCPU)  // Buffering optional but sensible.
    for i := 0; i &lt; NCPU; i++ {
        go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)
    }
    // Drain the channel.
    for i := 0; i &lt; NCPU; i++ {
        &lt;-c    // wait for one task to complete
    }
    // All done.
}

</pre>

<div class="english">
<p>
The current implementation of the Go runtime
will not parallelize this code by default.
It dedicates only a single core to user-level processing.  An
arbitrary number of goroutines can be blocked in system calls, but
by default only one can be executing user-level code at any time.
It should be smarter and one day it will be smarter, but until it
is if you want CPU parallelism you must tell the run-time
how many goroutines you want executing code simultaneously.  There
are two related ways to do this.  Either run your job with environment
variable <code>GOMAXPROCS</code> set to the number of cores to use
or import the <code>runtime</code> package and call
<code>runtime.GOMAXPROCS(NCPU)</code>.
A helpful value might be <code>runtime.NumCPU()</code>, which reports the number
of logical CPUs on the local machine.
Again, this requirement is expected to be retired as the scheduling and run-time improve.
</p>
</div>

<p>
Go运行时的当前实现将默认不并行运行此代码。它对用户级处理只投入一个核心。
任意数量的Go程在系统调用时会被阻止，使得默认在任何时候只能有一个内核能执行用户级代码。
它本该更聪明一点，并且有一天这一点会实现，但目前如果你想使多个CPU并行运行，
就必须明确告诉运行时你想要同时执行的Go程的数目。有两种相关方法来实现这一目的。
要么是使用环境变量 <code>GOMAXPROCS</code> 设定将要使用的核心数目来运行你的工作，
要么是导入 <code>runtime</code> 包并调用 <code>runtime.GOMAXPROCS(NCPU)</code>。
<code>runtime.NumCPU()</code> 的值很有用，它会报告在本地机子上的CPU数目。
另外，随着开发进度的完成以及运行时的改善，将来会不再要求这样做。
</p>

<div class="english">
<h3 id="leaky_buffer">A leaky buffer</h3>
</div>

<h3 id="漏桶缓存">漏桶缓存</h3>

<div class="english">
<p>
The tools of concurrent programming can even make non-concurrent
ideas easier to express.  Here's an example abstracted from an RPC
package.  The client goroutine loops receiving data from some source,
perhaps a network.  To avoid allocating and freeing buffers, it keeps
a free list, and uses a buffered channel to represent it.  If the
channel is empty, a new buffer gets allocated.
Once the message buffer is ready, it's sent to the server on
<code>serverChan</code>.
</p>
</div>

<p>
并发编程工具甚至能使非并发的思想更容易被表达。以下示例的概念是菜单RPC包抽象而来。
客户端Go程循环从一些源（可能为一个网络）接收数据。为了避免对缓存分配和释放内存，
它维持了一个自由列表，并使用一个换缓存的信道来代表它。如果该信道是空的，将分配一个新的缓存。
一旦此消息缓存就绪，它将通过 <code>serverChan</code> 发送给服务器。
</p>

<div class="english">
<pre>
var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
    for {
        var b *Buffer
        // Grab a buffer if available; allocate if not.
        select {
        case b = &lt;-freeList:
            // Got one; nothing more to do.
        default:
            // None free, so allocate a new one.
            b = new(Buffer)
        }
        load(b)              // Read next message from the net.
        serverChan &lt;- b      // Send to server.
    }
}
</pre>
</div>

<pre>
var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
    for {
        var b *Buffer
        // Grab a buffer if available; allocate if not.
        select {
        case b = &lt;-freeList:
            // Got one; nothing more to do.
        default:
            // None free, so allocate a new one.
            b = new(Buffer)
        }
        load(b)              // Read next message from the net.
        serverChan &lt;- b      // Send to server.
    }
}
</pre>

<div class="english">
<p>
The server loop receives each message from the client, processes it,
and returns the buffer to the free list.
</p>
</div>

<p>
服务器在循环中从客户端接收每条消息，并对其进行处理，然后向自由列表返回此缓存。
</p>

<div class="english">
<pre>
func server() {
    for {
        b := &lt;-serverChan    // Wait for work.
        process(b)
        // Reuse buffer if there's room.
        select {
        case freeList &lt;- b:
            // Buffer on free list; nothing more to do.
        default:
            // Free list full, just carry on.
        }
    }
}
</pre>
</div>

<pre>
func server() {
    for {
        b := &lt;-serverChan    // Wait for work.
        process(b)
        // Reuse buffer if there's room.
        select {
        case freeList &lt;- b:
            // Buffer on free list; nothing more to do.
        default:
            // Free list full, just carry on.
        }
    }
}
</pre>

<div class="english">
<p>
The client attempts to retrieve a buffer from <code>freeList</code>;
if none is available, it allocates a fresh one.
The server's send to <code>freeList</code> puts <code>b</code> back
on the free list unless the list is full, in which case the
buffer is dropped on the floor to be reclaimed by
the garbage collector.
(The <code>default</code> clauses in the <code>select</code>
statements execute when no other case is ready,
meaning that the <code>selects</code> never block.)
This implementation builds a leaky bucket free list
in just a few lines, relying on the buffered channel and
the garbage collector for bookkeeping.
</p>
</div>

<p>
客户端试图从 <code>freeList</code> 检出一个缓存；如果没有可用的，它将分配一个新的。
如果自由列表没有满，服务器向 <code>freeList</code> 的发送将 <code>b</code> 放回自由列表；
如果自由列表满了，则自由列表下方位置的缓存将被删除进而被垃圾回收器回收。
（当其他的 <code>case</code> 都不可用时，<code>select</code> 语句中的 <code>default</code>
子句将被执行，这样 <code>selects</code> 将永远不会被阻塞。）
这种实现基于缓存的信道和垃圾回收器记账，仅通过区区几行代码，构建了一个漏桶算法的自由列表。
</p>

<div class="english">
<h2 id="errors">Errors</h2>
</div>

<h2 id="错误">错误</h2>

<div class="english">
<p>
Library routines must often return some sort of error indication to
the caller.  As mentioned earlier, Go's multivalue return makes it
easy to return a detailed error description alongside the normal
return value.  By convention, errors have type <code>error</code>,
a simple built-in interface.
</p>
</div>

<p>
计算机库程序必须经常向调用者返回一些错误指示。前面已经提到过，
Go的多值返回使其在返回一个常规的返回值之外，还能轻易地返回一个详细的错误描述。
通常情况下，错误的类型是 <code>error</code> ，这是一个内建的接口。
</p>

<pre>
type error interface {
    Error() string
}
</pre>

<div class="english">
<p>
A library writer is free to implement this interface with a
richer model under the covers, making it possible not only
to see the error but also to provide some context.
For example, <code>os.Open</code> returns an <code>os.PathError</code>.
</p>
</div>

<p>
For example, <code>os.Open</code> returns an <code>os.PathError</code>.
库的作者可以在此封装之下自由地用更丰富的模型实现此接口，从而不仅看到错误，并且提供一些上下文。
例如，<code>os.Open</code> 返回了一个 <code>os.PathError</code>。
</p>

<div class="english">
<pre>
// PathError records an error and the operation and
// file path that caused it.
type PathError struct {
    Op string    // "open", "unlink", etc.
    Path string  // The associated file.
    Err error    // Returned by the system call.
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
</pre>
</div>

<pre>
// PathError records an error and the operation and
// file path that caused it.
type PathError struct {
    Op string    // "open", "unlink", etc.
    Path string  // The associated file.
    Err error    // Returned by the system call.
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
</pre>

<div class="english">
<p>
<code>PathError</code>'s <code>Error</code> generates
a string like this:
</p>
</div>

<p>
<code>PathError</code> 的 <code>error</code> 产生的字符串样式为：
</p>

<pre>
open /etc/passwx: no such file or directory
</pre>

<div class="english">
<p>
Such an error, which includes the problematic file name, the
operation, and the operating system error it triggered, is useful even
if printed far from the call that caused it;
it is much more informative than the plain
"no such file or directory".
</p>
</div>

<p>
这种错误包含了有问题的文件名称、操作以及其所触发的操作系统错误，打印出这些信息非常有用，
即便距离引发此错误的调用很远时也是如此；相对于平白的“no such file or directory”，它更有说明性。
</p>

<div class="english">
<p>
When feasible, error strings should identify their origin, such as by having
a prefix naming the package that generated the error.  For example, in package
<code>image</code>, the string representation for a decoding error due to an
unknown format is "image: unknown format".
</p>
</div>

<p>
错误字符串应尽可能地标示出它们的来源，如放入一个包的名称作为产生的错误信息的前缀。
比如，在 <code>image</code> 包中，由于未知格式引发的解码错误字符串表示为：
"image: unknown format"。
</p>

<div class="english">
<p>
Callers that care about the precise error details can
use a type switch or a type assertion to look for specific
errors and extract details.  For <code>PathErrors</code>
this might include examining the internal <code>Err</code>
field for recoverable failures.
</p>
</div>

<p>
当调用者想准确地得到错误细节时，可以使用一个类型开关或类型断言来查找特定的错误并抽取其细节。
如对于 <code>PathErrors</code>，就可以检查内部的 <code>Err</code> 字段以进行错误恢复。
</p>

<div class="english">
<pre>
for try := 0; try &lt; 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
</pre>
</div>

<pre>
for try := 0; try &lt; 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
</pre>

<div class="english">
<p>
The second <code>if</code> statement here is idiomatic Go.
The type assertion <code>err.(*os.PathError)</code> is
checked with the "comma ok" idiom (mentioned <a href="#maps">earlier</a>
in the context of examining maps).
If the type assertion fails, <code>ok</code> will be false, and <code>e</code>
will be <code>nil</code>.
If it succeeds,  <code>ok</code> will be true, which means the
error was of type <code>*os.PathError</code>, and then so is <code>e</code>,
which we can examine for more information about the error.
</p>
</div>

<p>
上面第二个 <code>if</code> 语句在Go中很常见。通过“逗号ok”的习惯用法
（<a href="#映射">先前</a>已经在检查映射的上下文中提到过）检查类型断言
<code>err.(*os.PathError)</code> 。如果类型断言失败，<code>ok</code> 将为假（false），
并且 <code>e</code> 将为 <code>nil</code>。如果成功，<code>ok</code> 将为真（true），
这意味着此错误正属于 <code>*os.PathError</code> 类型，即为 <code>e</code>，
我们可以用它对此错误的更多信息进行检查。
</p>

<div class="english">
<h3 id="panic">Panic</h3>
</div>

<h3 id="恐慌">恐慌</h3>

<div class="english">
<p>
The usual way to report an error to a caller is to return an
<code>error</code> as an extra return value.  The canonical
<code>Read</code> method is a well-known instance; it returns a byte
count and an <code>error</code>.  But what if the error is
unrecoverable?  Sometimes the program simply cannot continue.
</p>
</div>

<p>
通常通过返回一个额外的 <code>error</code> 值来向调用者报告一个错误。标准的 <code>Read</code>
方法就是一个大家熟知的例子；它返回一个字节技术和一个 <code>error</code>。
但当错误不可恢复时会怎么样呢？有时只是简单地让程序停止运行。
</p>

<div class="english">
<p>
For this purpose, there is a built-in function <code>panic</code>
that in effect creates a run-time error that will stop the program
(but see the next section).  The function takes a single argument
of arbitrary type&mdash;often a string&mdash;to be printed as the
program dies.  It's also a way to indicate that something impossible has
happened, such as exiting an infinite loop.  In fact, the compiler
recognizes a <code>panic</code> at the end of a function and
suppresses the usual check for a <code>return</code> statement.
</p>
</div>

<p>
对此，有一个内建的 <code>panic</code> 函数，它将创建一个运行时错误并使程序停止（请继续看下一节）。
该函数接收一个任意类型——往往是字符串——的实参作为程序死亡时要打印的东西。
它同样也是标明已经发生了一些不可能完成事件的一种方法，例如，退出无限循环。
事实上，当编译器在函数的结尾处检查到一个 <code>panic</code> 时，就会停止进行常规的
<code>return</code> 语句检查。
</p>

<div class="english">
<pre>
// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i &lt; 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
</pre>
</div>

<pre>
// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i &lt; 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
</pre>

<div class="english">
<p>
This is only an example but real library functions should
avoid <code>panic</code>.  If the problem can be masked or worked
around, it's always better to let things continue to run rather
than taking down the whole program.  One possible counterexample
is during initialization: if the library truly cannot set itself up,
it might be reasonable to panic, so to speak.
</p>
</div>

<p>
这仅仅是一个示例，但实际的库函数应避免 <code>panic</code>。如果问题可以被掩盖或解决，
最好是让事情继续下去而不是终止整个程序。一个反例可能发生在初始化期间：
如果库不能设定自己，这时就应该发出恐慌。
</p>

<pre>
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
</pre>

<div class="english">
<h3 id="recover">Recover</h3>
</div>

<h3 id="恢复">恢复</h3>

<div class="english">
<p>
When <code>panic</code> is called, including implicitly for run-time
errors such as indexing a slice out of bounds or failing a type
assertion, it immediately stops execution of the current function
and begins unwinding the stack of the goroutine, running any deferred
functions along the way.  If that unwinding reaches the top of the
goroutine's stack, the program dies.  However, it is possible to
use the built-in function <code>recover</code> to regain control
of the goroutine and resume normal execution.
</p>
</div>

<p>
当 <code>panic</code> 被调用时，包括隐式的运行时错误，如对数组的引用越界或类型断言失败，
它将立即停止当前函数的执行并开始解开Go程的堆栈，同时运行所有被延期的函数。
如果这种解开达到Go程堆栈的顶端，程序就死亡了。但是，也可以使用内建的 <code>recover</code>
函数来重新获得Go程的控制权并恢复正常的执行。
</p>

<div class="english">
<p>
A call to <code>recover</code> stops the unwinding and returns the
argument passed to <code>panic</code>.  Because the only code that
runs while unwinding is inside deferred functions, <code>recover</code>
is only useful inside deferred functions.
</p>
</div>

<p>
对 <code>recover</code> 的调用会通知解开堆栈并返回传递到 <code>panic</code>
的实参。由于仅在解开期间运行的代码处在被延期的函数之内，<code>recover</code>
仅在被延期的函数内部才是有用的。
</p>

<div class="english">
<p>
One application of <code>recover</code> is to shut down a failing goroutine
inside a server without killing the other executing goroutines.
</p>
</div>

<p>
<code>recover</code> 的应用之一就是关闭一个服务器内运行失败的Go程，同时不用杀死其他正在执行的Go程。
</p>

<pre>
func server(workChan &lt;-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
</pre>

<div class="english">
<p>
In this example, if <code>do(work)</code> panics, the result will be
logged and the goroutine will exit cleanly without disturbing the
others.  There's no need to do anything else in the deferred closure;
calling <code>recover</code> handles the condition completely.
</p>
</div>

<p>
在此例中，如果 <code>do(work)</code> 发生严重错误（panic），其结果将被记录下来，
Go程会干净地退出，并不会打断其他的Go程。在被延期的闭包中并不需要做其他事情；
对 <code>recover</code> 的调用彻底地处理了这种情况。
</p>

<div class="english">
<p>
Because <code>recover</code> always returns <code>nil</code> unless called directly
from a deferred function, deferred code can call library routines that themselves
use <code>panic</code> and <code>recover</code> without failing.  As an example,
the deferred function in <code>safelyDo</code> might call a logging function before
calling <code>recover</code>, and that logging code would run unaffected
by the panicking state.
</p>
</div>

<p>
由于除非 <code>recover</code> 直接被一个延期的函数调用，它将总是返回 <code>nil</code>，
因此被延期的代码可以调用使用了 <code>panic</code> 和 <code>recover</code> 的库程序而不发生错误。
例如，在 <code>safelyDo</code> 中的被延期函数可能在调用 <code>recover</code>
之前先调用一个日志记录函数，此记录代码的运行并不受错误处理（panicking）状态的影响。
</p>

<div class="english">
<p>
With our recovery pattern in place, the <code>do</code>
function (and anything it calls) can get out of any bad situation
cleanly by calling <code>panic</code>.  We can use that idea to
simplify error handling in complex software.  Let's look at an
idealized excerpt from the <code>regexp</code> package, which reports
parsing errors by calling <code>panic</code> with a local
error type.  Here's the definition of <code>Error</code>,
an <code>error</code> method, and the <code>Compile</code> function.
</p>
</div>

<p>
通过合理地使用恢复模式，<code>do</code> 函数（或其他任何名称）可以通过调用
<code>panic</code> 从任何糟糕的情况中干净利落地脱身。我们可以使用这种概念在复杂的软件中简化错误处理。
让我们来看看来自 <code>regexp</code> 包中的一个理想化的节选，它以一个局部错误类型通过调用
<code>panic</code> 报告解析错误。以下是 <code>Error</code>、<code>error</code>
方法以及 <code>Compile</code> 函数的定义。
</p>

<div class="english">
<pre>
// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}
</pre>
</div>

<pre>
// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}
</pre>

<div class="english">
<p>
If <code>doParse</code> panics, the recovery block will set the
return value to <code>nil</code>&mdash;deferred functions can modify
named return values.  It then will then check, in the assignment
to <code>err</code>, that the problem was a parse error by asserting
that it has the local type <code>Error</code>.
If it does not, the type assertion will fail, causing a run-time error
that continues the stack unwinding as though nothing had interrupted
it.  This check means that if something unexpected happens, such
as an index out of bounds, the code will fail even though we
are using <code>panic</code> and <code>recover</code> to handle
user-triggered errors.
</p>
</div>

<p>
如果 <code>doParse</code> 遭遇严重错误，恢复代码将把返回值设为 <code>nil</code>
——被延期的函数可以修改已被命名的返回值。然后，它会对 <code>err</code> 再进行检查，
这种检查是通过断言 <code>err</code> 具有局部的 <code>Error</code> 类型来断定出现的问题是一个解析错误。
如果不是解析错误，此类型断言将会失败，这将引起一个运行时错误，从而使堆栈的解开继续进行下去，
就如同不曾有什么打断过此项解开工作一样。这种检查意味着如果发生了一些未遇到到的事情，
例如数组索引超限，则即便我们已经使用了 <code>panic</code> 和 <code>recover</code>
来处理用户触发的错误，代码仍将失败。
</p>

<div class="english">
<p>
With error handling in place, the <code>error</code> method
makes it easy to report parse errors without worrying about unwinding
the parse stack by hand.
</p>
</div>

<p>
通过合理地使用错误处理，<code>error</code>
方法使其能很容易地报告解析错误而不必操心需要手动解开解析堆栈。
</p>

<div class="english">
<p>
Useful though this pattern is, it should be used only within a package.
<code>Parse</code> turns its internal <code>panic</code> calls into
<code>error</code> values; it does not expose <code>panics</code>
to its client.  That is a good rule to follow.
</p>
</div>

<p>
尽管这种模式很有用，它应该只被用于包内。<code>Parse</code> 将其内部的 <code>panic</code>
调用转变为 <code>error</code> 值；它没有向客户端暴露 <code>panics</code>。
这是一种需要遵循的好原则。
</p>

<div class="english">
<p>
By the way, this re-panic idiom changes the panic value if an actual
error occurs.  However, both the original and new failures will be
presented in the crash report, so the root cause of the problem will
still be visible.  Thus this simple re-panic approach is usually
sufficient&mdash;it's a crash after all&mdash;but if you want to
display only the original value, you can write a little more code to
filter unexpected problems and re-panic with the original error.
That's left as an exercise for the reader.
</p>
</div>
<p>
顺便提一下，如果一个实际的错误发生了，这种重新触发严重错误（re-panic）
的习惯用法改变了严重错误（panic）的值。但是，原来的和新的错误都将会出现在崩溃报告中，
因此引发问题的根仍然是可见的。因此这种简单的重新触发严重错误的方法通常已经足够了——
它毕竟是一个意外事故——但如果你只想显示原始值，
你可以稍微多写点代码来筛选出未遇到的问题并重新触发此原始的严重错误。这就在为练习留给读者了。
</p>

<h2 id="blank">Blank identifier</h2>

<p>
Go defines a special identifier <code>_</code>, called the <i>blank identifier</i>.
The blank identifier can be used in a declaration to avoid
declaring a name, and it can be used in an assignment to discard a value.
This definition makes it useful in a variety of contexts.
</p>

<h3 id="blank_assign">Multiple assignment</h3>

<p>
If an assignment requires multiple values on the left side,
but one of the values will not be used by the program,
using the blank identifier in the assignment avoids the need
to create a dummy variable.
We saw one example of this in the discussion of
<a href="#for">for loops</a> above.
</p>
<pre>
sum := 0
for _, value := range array {
    sum += value
}
</pre>

<p>
Another common use is when calling a function that returns
a value and an error, but only the error is important.
</p>
<pre>
if _, err := os.Stat(path); os.IsNotExist(err) {
	fmt.Printf("%s does not exist\n", path)
}
</pre>

<p>
A final use that is more common than it should be is to
discard the error from a function that is not expected to fail.
This is usually a mistake: when the function does fail, the code
will continue on and probably panic dereferencing a nil pointer.
</p>
<pre>
// Always check errors: this program crashes if path does not exist.
fi, _ := os.Stat(path)
fmt.Printf("%s is %d bytes\n", path, fi.Size())
</pre>

<h3 id="blank_unused">Unused imports and variables</h3>

<p>
Go defines that it is an error to import a package without using it,
or to declare a variable without using its value.
Unused imports bloat a program and lengthen compiles unnecessarily;
a variable that is initialized but not used is at least
a wasted computation and perhaps indicative of a
larger bug.
Of course, both of these situations also arise in programs
that are under active development, as you test and refine
your code.
</p>
<p>
For example, in this program, there are two unused imports
(<code>fmt</code> and <code>io</code>)
and an unused variable (<code>greeting</code>).
</p>
{{code "/doc/progs/eff_unused1.go" `/package/` `$`}}
<p>
Top-level blank declarations referring to the packages
will silence the unused import errors.
By convention, these declarations should come immediately after
the imports, as a reminder to clean things up later.
Similarly, assigning <code>greeting</code> to a blank identifier
will silence the unused variable error.
</p>
{{code "/doc/progs/eff_unused2.go" `/package/` `$`}}

<h3 id="blank_import">Import for side effect</h3>

<p>
An unused import like <code>fmt</code> or <code>io</code> in the last section
should eventually be used or removed:
blank assignments identify code as a work in progress.
But sometimes it is useful to import a package only for its
side effects, without any explicit use.
For example, during its <code>init</code> function,
the <code><a href="/pkg/net/http/pprof/">net/http/pprof</a></code>
package registers HTTP handlers that provide useful
debugging information. It has an exported API too, but
most clients need only the handler registration.
In this situation, it is conventional to rename the package
to the blank identifier:
</p>
<pre>
import _ "net/http/pprof"
</pre>
<p>
This form of import makes clear that the package is being
imported for its side effects, because there is no other possible
use of the package: in this file, it doesn't have a name.
</p>

<h3 id="blank_implements">Interface checks</h3>

<p>
As we saw in the discussion of <a href="#interfaces_and_types">interfaces</a> above,
Go does not require a type to declare explicitly that it implements an interface.
It implements the interface by simply implementing the required methods.
This makes Go programs more lightweight and flexible, and it can avoid
unnecessary dependencies between packages.
Most interface conversions are static, visible to the compiler,
and therefore checked at compile time.
For example, passing an <code>*os.File</code> to a function
expecting an <code>io.Reader</code> will not compile unless
<code>*os.File</code> implements the <code>io.Reader</code> interface.
</p>
<p>
However, some types that are used only to satisfy dynamic interface checks.
For example, the <code><a href="/pkg/encoding/json/">encoding/json</a></code>
package defines a <code><a href="/pkg/encoding/json/#Marshaler">Marshaler</a></code>
interface. If the JSON encoder encounters a type implementing that interface,
the encoder will let the type convert itself to JSON instead of using the standard
conversion.
This check is done only at runtime, with code like:
</p>
<pre>
m, ok := val.(json.Marshaler)
</pre>
<p>
If a type—for example,
<code><a href="/pkg/encoding/json/#RawMessage">json.RawMessage</a></code>—intends
to customize its JSON representation, it should implement
<code>json.Marshaler</code>, but there are no static conversions that would
cause the compiler to verify this automatically.
A declaration can be used to add such a check:
</p>
<pre>
var _ json.Marshaler = (*MyMessage)(nil)
</pre>
<p>
As part of type-checking this static assignment of a
<code>*RawMessage</code> to a <code>Marshaler</code>,
the Go compiler will require that <code>*RawMessage</code> implements <code>Marshaler</code>.
Using the blank identifier here indicates that
the declaration exists only for the type checking,
not to create a variable.
Conventionally, such declarations are used only when there are
no static conversions already present in the code.
</p>

<div class="english">
<h2 id="web_server">A web server</h2>
</div>

<h2 id="Web服务器">Web服务器</h2>

<div class="english">
<p>
Let's finish with a complete Go program, a web server.
This one is actually a kind of web re-server.
Google provides a service at
<a href="http://chart.apis.google.com">http://chart.apis.google.com</a>
that does automatic formatting of data into charts and graphs.
It's hard to use interactively, though,
because you need to put the data into the URL as a query.
The program here provides a nicer interface to one form of data: given a short piece of text,
it calls on the chart server to produce a QR code, a matrix of boxes that encode the
text.
That image can be grabbed with your cell phone's camera and interpreted as,
for instance, a URL, saving you typing the URL into the phone's tiny keyboard.
</p>
</div>

<p>
让我们以一个完整的Go程序作为结束，一个web服务器。该程序实际上是一种web服务器的重用。
Google在<a href="http://chart.apis.google.com">http://chart.apis.google.com</a>
提供了一个自动将数据格式化为图表和图形的服务。该服务很难交互地使用，
这是因为你需要将数据放入URL构成一个查询。此处的程序为一种数据形式提供了一个更好的接口：
给出一小段文本，它将调用图表服务器产生一个二维码（QR code），即一个对此文本进行编码的矩阵框。
此图像可以通过你的手机摄像头获取，并被解释为一个URL，免除了你从手机的小键盘上输入URL的麻烦。
</p>

<div class="english">
<p>
Here's the complete program.
An explanation follows.
</p>
</div>

<p>
以下是完整的程序。其后的文字是对它的解释。
</p>

{{code "/doc/progs/eff_qr.go" `/package/` `$`}}

<div class="english">
<p>
The pieces up to <code>main</code> should be easy to follow.
The one flag sets a default HTTP port for our server.  The template
variable <code>templ</code> is where the fun happens. It builds an HTML template
that will be executed by the server to display the page; more about
that in a moment.
</p>
</div>

<p>
<code>main</code> 程序之前的部分应该很容易理解。一个标记（flag）设置了我们服务器的默认端口。
模板变量 <code>templ</code> 正是有趣之处。它构建了一个将被解析并显示页面的HTML模板；过会儿再细讲。
</p>

<div class="english">
<p>
The <code>main</code> function parses the flags and, using the mechanism
we talked about above, binds the function <code>QR</code> to the root path
for the server.  Then <code>http.ListenAndServe</code> is called to start the
server; it blocks while the server runs.
</p>
</div>

<p>
<code>main</code> 解析了标记并使用我们在前面已讲过的机制将 <code>QR</code>
函数绑定到服务器的根路径。然后调用 <code>http.ListenAndServe</code> 启动服务器；
当服务器运行时它将保持阻塞。
</p>

<div class="english">
<p>
<code>QR</code> just receives the request, which contains form data, and
executes the template on the data in the form value named <code>s</code>.
</p>
</div>

<p>
<code>QR</code> 只是接收包含表单数据的请求，并在名称为 <code>s</code>
的表单值所包含的数据上执行模板。
</p>

<div class="english">
<p>
The template package <code>html/template</code> is powerful;
this program just touches on its capabilities.
In essence, it rewrites a piece of HTML text on the fly by substituting elements derived
from data items passed to <code>templ.Execute</code>, in this case the
form value.
Within the template text (<code>templateStr</code>),
double-brace-delimited pieces denote template actions.
The piece from <code>{{html "{{if .}}"}}</code>
to <code>{{html "{{end}}"}}</code> executes only if the value of the current data item, called <code>.</code> (dot),
is non-empty.
That is, when the string is empty, this piece of the template is suppressed.
</p>
</div>

<p>
<code>template</code> 包非常强大；该程序将使用了它功能的一点皮毛。
本质上，它通过将文本中的元素替换为传递到 <code>templ.Execute</code>
的数据项（上例为表单值）元素来重写一段文本。在模板文本中（<code>templateStr</code>），
双大括号包括起来的文本标明了模板的行为。而从<code>{{html "{{if .}}"}}</code>
到 <code>{{html "{{end}}"}}</code> 间的文本片段仅在当前数据项（称作点 <code>.</code>）
的值为非空时才被执行。也就是说，当此字符串为空时，此部分模板就会被忽略。
</p>

<div class="english">
<p>
The two snippets <code>{{html "{{.}}"}}</code> say to show the data presented to
the template—the query string—on the web page.
The HTML template package automatically provides appropriate escaping so the
text is safe to display.
</p>
</div>

<p>
<code>{{html "{{urlquery .}}"}}</code> 片段告知 <code>urlquery</code>
函数去处理数据，它使查询字符串可以安全地在Web页面上显示。
</p>

<div class="english">
<p>
The rest of the template string is just the HTML to show when the page loads.
If this is too quick an explanation, see the <a href="/pkg/html/template/">documentation</a>
for the template package for a more thorough discussion.
</p>
</div>

<p>
余下的模板字符串只是在页面加载时将要显示的HTML。如果你无理解这种快速入门解释，
请参看模板包的<a href="/pkg/text/template/">文档</a>以得到一个更彻底的讨论。
</p>

<div class="english">
<p>
And there you have it: a useful web server in a few lines of code plus some
data-driven HTML text.
Go is powerful enough to make a lot happen in a few lines.
</p>
</div>

<p>
这就是你现在得到的：一个仅通过少数几行代码实现的有用的web服务器以及一些数据驱动的HTML文本。
Go很强大，使其能仅用少数几行代码完成大量的工作。
</p>

<!--
TODO
<pre>
verifying implementation
type Color uint32

// Check that Color implements image.Color and image.Image
var _ image.Color = Black
var _ image.Image = Black
</pre>
-->

