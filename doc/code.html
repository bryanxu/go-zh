<!--{
	"Title": "如何编写Go代码"
}-->

<!--{
	"Title": "How to Write Go Code"
}-->

<div class="english">
<h2 id="Introduction">Introduction</h2>
</div>

<h2 id="前言">前言</h2>

<div class="english">
<p>
This document demonstrates the development of a simple Go package and
introduces the <a href="/cmd/go/">go command</a>, the standard way to fetch,
build, and install Go packages and commands.
</p>
</div>

<p>
本文档演示了一个简单Go包的开发，并介绍了使用<a href="/cmd/go/">go命令</a>来获取、
构建并安装Go包及命令的标准方式。
</p>

<div class="english">
<p>
This content is also available as a <a href="http://www.youtube.com/watch?v=XCsL89YtqCs">screencast</a>.
</p>
</div>

<p>
本文档内容也可在此<a href="http://www.youtube.com/watch?v=XCsL89YtqCs">视频</a>中获得。
</p>

<div class="english">
<h2 id="GOPATH">Code organization</h2>
</div>

<h2 id="GOPATH">代码的组织</h2>

<div class="english">
<h3><code>GOPATH</code> and workspaces</h3>
</div>

<h3><code>GOPATH</code> 与工作空间</h3>

<div class="english">
<p>
One of Go's design goals is to make writing software easier.  To that end, the
<code>go</code> command doesn't use Makefiles or other configuration files to
guide program construction. Instead, it uses the source code to find
dependencies and determine build conditions. This means your source code and
build scripts are always in sync; they are one and the same.
</p>
</div>

<p>
Go的设计目标之一就是让软件更容易编写。因此，<code>go</code>
命令并不使用Makefile或其它配置文件来指导程序的构造，而是使用源代码来寻找依赖并确定构建条件。
也就是说，你的源代码与构建脚本总是同步的，因为它们就是同一个。
</p>

<div class="english">
<p>
The one thing you must do is set a <code>GOPATH</code> environment variable.
<code>GOPATH</code> tells the <code>go</code> command (and other related tools)
where to find and install the Go packages on your system.
</p>
</div>

<p>
首先，你必须设置 <code>GOPATH</code> 环境变量。它用来告诉 <code>go</code>
命令（及其相关命令）在你的系统上可以从哪找到并安装Go包。
</p>

<div class="english">
<p>
<code>GOPATH</code> is a list of paths. It shares the syntax of your system's
<code>PATH</code> environment variable. A typical <code>GOPATH</code> on
a Unix system might look like this:
</p>
</div>

<p>
<code>GOPATH</code> 是一个路径的列表，它与你的系统共享 <code>PATH</code> 环境变量。
在Unix系统上，一个典型的 <code>GOPATH</code> 看起来是这样的：
</p>

<pre>
GOPATH=/home/user/ext:/home/user/mygo
</pre>

<div class="english">
<p>
(On a Windows system use semicolons as the path separator instead of colons.)
</p>
</div>

<p>
（在Windows系统上，路径分隔符是分号而非冒号。）
</p>

<div class="english">
<p>
Each path in the list (in this case <code>/home/user/ext</code> or
<code>/home/user/mygo</code>) specifies the location of a <i>workspace</i>.
A workspace contains Go source files and their associated package objects, and
command executables. It has a prescribed structure of three subdirectories:
</p>
</div>

<p>
在该列表中，每个路径（此时为 <code>/home/user/ext</code> 或 <code>/home/user/mygo</code>）
都指定了一个<i>工作空间</i>的位置。工作空间包含Go源文件及与其关联的包对象与可执行命令。
它有三个预定义的子目录结构：
</p>

<div class="english">
<ul>
<li><code>src</code> contains Go source files,
<li><code>pkg</code> contains compiled package objects, and
<li><code>bin</code> contains executable commands.
</ul>
</div>

<ul>
<li><code>src</code> 包含Go源文件</li>
<li><code>pkg</code> 包含已编译包对象</li>
<li><code>bin</code> 包含可执行命令</li>
</ul>

<div class="english">
<p>
Subdirectories of the <code>src</code> directory hold independent packages, and
all source files (<code>.go</code>, <code>.c</code>, <code>.h</code>, and
<code>.s</code>) in each subdirectory are elements of that subdirectory's
package.
</p>
</div>

<p>
其中 <code>src</code> 目录的子目录均为独立的包，且其每个下级目录中所有源文件
（即<code>.go</code>、<code>.c</code>、<code>.h</code>与<code>.s</code>文件）
均为其所在目录包的元素。
</p>

<div class="english">
<p>
When building a program that imports the package "<code>widget</code>" the
<code>go</code> command looks for <code>src/pkg/widget</code> inside the Go root,
and then&mdash;if the package source isn't found there&mdash;it searches
for <code>src/widget</code> inside each workspace in order.
</p>
</div>

<p>
当构建一个导入了 "<code>widget</code>" 包的程序时，<code>go</code> 命令就会在Go根目录中寻找
<code>src/pkg/widget</code>，若该包源未在此处找到，则会按顺序在每个工作空间中搜索 <code>src/widget</code>。
</p>

<div class="english">
<p>
Multiple workspaces can offer some flexibility and convenience, but for now
we'll concern ourselves with only a single workspace.
</p>
</div>

<p>
多工作空间可提供一些灵活性与便利性，不过现在我们只关心自己的单个工作空间。
</p>

<div class="english">
<p>
Let's work through a simple example. First, create a <code>$HOME/mygo</code>
directory and its <code>src</code> subdirectory:
</p>
</div>

<p>
我们先来完成一个简单的例子。首先，创建一个 <code>$HOME/mygo</code> 目录，其子目录为 <code>src</code>：
</p>

<div class="english">
<pre>
$ mkdir -p $HOME/mygo/src # create a place to put source code
</pre>
</div>

<pre>
$ mkdir -p $HOME/mygo/src # 创建一个放源代码的地方
</pre>

<div class="english">
<p>
Next, set it as the <code>GOPATH</code>. You should also add the
<code>bin</code> subdirectory to your <code>PATH</code> environment variable so
that you can run the commands therein without specifying their full path.
To do this, add the following lines to <code>$HOME/.profile</code> (or
equivalent):
</p>
</div>

<p>
接着，将它设置为 <code>GOPATH</code>。你也应该在你的 <code>PATH</code>
环境变量中添加子目录 <code>bin</code>，以便无需指定完整路径而运行其中的命令。
为此，请将以下几行添加到 <code>$HOME/.profile</code>（或等价的文件） 中：
</p>

<pre>
export GOPATH=$HOME/mygo
export PATH=$PATH:$HOME/mygo/bin
</pre>


<div class="english">
<h3>Import paths</h3>
</div>

<h3>导入路径</h3>

<div class="english">
<p>
The standard packages are given short import paths such as <code>"fmt"</code>
and <code>"net/http"</code> for convenience.
For your own projects, it is important to choose a base import path that is
unlikely to collide with future additions to the standard library or other
external libraries.
</p>
</div>

<p>
为了方便，标准包给定了短导入路径，例如 <code>"fmt"</code> 或 <code>"net/http"</code>。
对于你自己的项目，选择一个好的基本导入路径是重要的，它不会与将来添加的标准库或其它扩展库相冲突。
</p>

<div class="english">
<p>
The best way to choose an import path is to use the location of your version
control repository.
For instance, if your source repository is at <code>example.com</code>
or <code>code.google.com/p/example</code>, you should begin your package
paths with that URL, as in "<code>example.com/foo/bar</code>" or
"<code>code.google.com/p/example/foo/bar</code>".
Using this convention, the <code>go</code> command can automatically check out and
build the source code by its import path alone.
</p>
</div>

<p>
选择一个导入路径的最好方式就是使用你的版本控制仓库的位置。
例如，若你的源码库在 <code>example.com</code> 或 <code>code.google.com/p/example</code>上，
你应当将该URL作为你的包路径的开端，像 "<code>example.com/foo/bar</code>" 或
"<code>code.google.com/p/example/foo/bar</code>" 这样。
使用此约定，<code>go</code> 命令可以单独通过其导入路径来自动检出并构建源码。
</p>

<div class="english">
<p>
If you don't intend to install your code in this way, you should at
least use a unique prefix like "<code>widgets/</code>", as in
"<code>widgets/foo/bar</code>". A good rule is to use a prefix such as your
company or project name, since it is unlikely to be used by another group.
</p>
</div>

<p>
如果你不打算通过此方式安装你的代码，你至少应当使用唯一的前缀 "<code>widgets/</code>"，
像 "<code>widgets/foo/bar</code>" 这样。
</p>

<div class="english">
<p>
We'll use <code>example/</code> as our base import path:
</p>
</div>

<p>
我们使用 <code>example/</code> 来作为我们的基本导入路径：
</p>

<pre>
$ mkdir -p $GOPATH/src/example
</pre>


<div class="english">
<h3>Package names</h3>
</div>

<h3>包名</h3>

<div class="english">
<p>
The first statement in a Go source file should be
</p>
</div>

<p>
Go源文件中的第一个语句应当为
</p>

<pre>
package <i>name</i>
</pre>

<div class="english">
<p>
where <code><i>name</i></code> is the package's default name for imports.
(All files in a package must use the same <code><i>name</i></code>.)
</p>
</div>

<p>
其中 <code><i>name</i></code> 为包用于导入的默认名。
（包中的所有文件都必须使用相同的 <code><i>name</i></code>。）
</p>

<div class="english">
<p>
Go's convention is that the package name is the last element of the
import path: the package imported as "<code>crypto/rot13</code>"
should be named <code>rot13</code>.
There is no requirement that package names be unique
across all packages linked into a single binary,
only that the import paths (their full file names) be unique.
</p>
</div>

<p>
Go的约定是将包名作为导入路径的最后一个元素：作为
"<code>crypto/rot13</code>" 导入的包应当命名为 <code>rot13</code>。
所有连接到单一二进制文件的包名无需唯一，只有导入路径（它们的完整文件名）是唯一的。
</p>

<div class="english">
<p>
Create a new package under <code>example</code> called <code>newmath</code>:
</p>
</div>

<p>
在 <code>example</code> 下创建一个名为 <code>newmath</code> 的新包：
</p>

<pre>
$ cd $GOPATH/src/example
$ mkdir newmath
</pre>

<div class="english">
<p>
Then create a file named <code>$GOPATH/src/example/newmath/sqrt.go</code>
containing the following Go code:
</p>
</div>

<p>
然后创建一个名为 <code>$GOPATH/src/example/newmath/sqrt.go</code>
的文件，它包含以下Go代码：
</p>

<div class="english">
<pre>
// Package newmath is a trivial example package.
package newmath

// Sqrt returns an approximation to the square root of x.
func Sqrt(x float64) float64 {
        // This is a terrible implementation.
        // Real code should import "math" and use math.Sqrt.
        z := 0.0
        for i := 0; i &lt; 1000; i++ {
                z -= (z*z - x) / (2 * x)
        }
        return z
}
</pre>
</div>

<pre>
// newmath只是个小例子包。
package newmath

// Sqrt返回x平方根的近似值。
func Sqrt(x float64) float64 {
        // 这是一个糟糕的实现。
        // 真实的代码应当导入 "math" 并使用 math.Sqrt.
        z := 0.0
        for i := 0; i &lt; 1000; i++ {
                z -= (z*z - x) / (2 * x)
        }
        return z
}
</pre>

<div class="english">
<p>
This package is imported by the path name of the directory it's in, starting
after the <code>src</code> component:
</p>
</div>

<p>
此包通过它所在目录的路径名导入，始于 <code>src</code> 组件之后：
</p>

<pre>
import "example/newmath"
</pre>

<div class="english">
<p>
See <a href="/doc/effective_go.html#names">Effective Go</a> to learn more about
Go's naming conventions.
</p>
</div>

<p>
欲了解更多关于Go的命名约定，请访问 <a href="/doc/effective_go.html#names">实效Go编程</a>。
</p>


<div class="english">
<h2>Building and installing</h2>
</div>

<h2>构建并安装</h2>

<div class="english">
<p>
The <code>go</code> command comprises several subcommands, the most central being
<code>install</code>. Running <code>go install <i>importpath</i></code> builds
and installs a package and its dependencies.
</p>
</div>

<p>
<code>go</code> 命令包含几个子命令，最主要的是 <code>install</code>。运行
<code>go install <i>importpath</i></code> 来构建并安装一个包及其依赖。
</p>

<div class="english">
<p>
To "install a package" means to write the package object or executable command
to the <code>pkg</code> or <code>bin</code> subdirectory of the workspace in
which the source resides.
</p>
</div>

<p>
To "install a package" means to write the package object or executable command
to the <code>pkg</code> or <code>bin</code> subdirectory of the workspace in
which the source resides.
“安装一个包”意为将一个包对象或可执行命令写入到源所属工作空间中的
<code>pkg</code> 或 <code>bin</code> 子目录中。
</p>

<div class="english">
<h3>Building a package</h3>
</div>

<h3>构建一个包</h3>

<div class="english">
<p>
To build and install the <code>newmath</code> package, type
</p>
</div>

<p>
To build and install the <code>newmath</code> package, type
要构建并安装 <code>newmath</code> 包，输入
</p>

<pre>
$ go install example/newmath
</pre>

<div class="english">
<p>
This command will produce no output if the package and its dependencies
are built and installed correctly.
</p>
</div>

<p>
若该包及其依赖能够正确构建并安装，该命令就不会产生输出。
</p>

<div class="english">
<p>
As a convenience, the <code>go</code> command will assume the current directory
if no import path is specified on the command line. This sequence of commands
has the same effect as the one above:
</p>
</div>

<p>
按照惯例，若命令行中未指定导入路径，则<code>go</code> 命令将假定为当前目录。
此命令序列与上文效果相同：
</p>

<pre>
$ cd $GOPATH/src/example/newmath
$ go install
</pre>

<div class="english">
<p>
The resulting workspace directory tree (assuming we're running Linux on a 64-bit
system) looks like this:
</p>
</div>

<p>
The resulting workspace directory tree (assuming we're running Linux on a 64-bit
system) looks like this:
产生的工作空间树（假定我们运行在64位Linux系统上）看起来像这样：
</p>

<div class="english">
<pre>
pkg/
    linux_amd64/
        example/
            newmath.a  # package object
src/
    example/
        newmath/
            sqrt.go    # package source
</pre>
</div>

<pre>
pkg/
    linux_amd64/
        example/
            newmath.a  # 包对象
src/
    example/
        newmath/
            sqrt.go    # 包源码
</pre>


<div class="english">
<h3>Building a command</h3>
</div>

<h3>构建一个命令</h3>

<div class="english">
<p>
The <code>go</code> command treats code belonging to <code>package main</code> as
an executable command and installs the package binary to the
<code>GOPATH</code>'s <code>bin</code> subdirectory.
</p>
</div>

<p>
<code>go</code> 命令会把属于 <code>main</code> 包的代码作为可执行命令处理，并将该二进制包安装到
<code>GOPATH</code> 的 <code>bin</code> 子目录下。
</p>

<div class="english">
<p>
Add a command named <code>hello</code> to the source tree.
First create the <code>example/hello</code> directory:
</p>
</div>

<p>
将一个名为 <code>hello</code> 的命令添加到源码树。
首先创建 <code>example/hello</code> 目录：
</p>

<pre>
$ cd $GOPATH/src/example
$ mkdir hello
</pre>

<div class="english">
<p>
Then create the file <code>$GOPATH/src/example/hello/hello.go</code>
containing the following Go code.
</p>
</div>

<p>
然后创建包含以下Go代码的文件 <code>$GOPATH/src/example/hello/hello.go</code>。
</p>

<div class="english">
<pre>
// Hello is a trivial example of a main package.
package main

import (
        "example/newmath"
        "fmt"
)

func main() {
        fmt.Printf("Hello, world.  Sqrt(2) = %v\n", newmath.Sqrt(2))
}
</pre>
</div>

<pre>
// Hello只是个main包的小例子。
package main

import (
        "example/newmath"
        "fmt"
)

func main() {
        fmt.Printf("Hello, world.  Sqrt(2) = %v\n", newmath.Sqrt(2))
}
</pre>

<div class="english">
<p>
Next, run <code>go install</code>, which builds and installs the binary to
<code>$GOPATH/bin</code> (or <code>$GOBIN</code>, if set; to simplify
presentation, this document assumes <code>GOBIN</code> is unset):
</p>
</div>

<p>
接着，运行 <code>go install</code>，它将构建并安装二进制文件到 <code>$GOPATH/bin</code> 中
（或 <code>$GOBIN</code>中，如果设置了的话；为简单起见，本文档假定 <code>GOBIN</code> 未设置）：
</p>

<pre>
$ go install example/hello
</pre>

<div class="english">
<p>
To run the program, invoke it by name as you would any other command:
</p>
</div>

<p>
要运行该程序，通过你想用的任何其他命令名调用它：
</p>

<pre>
$ $GOPATH/bin/hello
Hello, world.  Sqrt(2) = 1.414213562373095
</pre>

<div class="english">
<p>
If you added <code>$HOME/mygo/bin</code> to your <code>PATH</code>, you may omit
the path to the executable:
</p>
</div>

<p>
若你已经将 <code>$HOME/mygo/bin</code> 添加到 <code>PATH</code> 中，那么你可以省略该可执行文件的路径：
</p>

<pre>
$ hello
Hello, world.  Sqrt(2) = 1.414213562373095
</pre>

<div class="english">
<p>
The workspace directory tree now looks like this:
</p>
</div>

<p>
工作空间目录树现在看起来像这样：
</p>

<div class="english">
<pre>
bin/
    hello              # command executable
pkg/
    linux_amd64/
        example/
            newmath.a  # package object
src/
    example/
        hello/
            hello.go   # command source
        newmath/
            sqrt.go    # package source
</pre>
</div>

<pre>
bin/
    hello              # 可执行命令
pkg/
    linux_amd64/
        example/
            newmath.a  # 包对象
src/
    example/
        hello/
            hello.go   # 命令源码
        newmath/
            sqrt.go    # 包源码
</pre>

<div class="english">
<p>
The <code>go</code> command also provides a <code>build</code> command, which is
like <code>install</code> except it builds all objects in a temporary directory
and does not install them under <code>pkg</code> or <code>bin</code>.
When building a command an executable named after the last element of the
import path is written to the current directory. When building a package,
<code>go build</code> serves merely to test that the package and its
dependencies can be built. (The resulting package object is thrown away.)
</p>
</div>

<p>
<code>go</code> 命令也提供 <code>build</code> 命令，它像 <code>install</code> 一样，
只不过在一个临时目录中构建所有对象，且并不将它们安装到 <code>pkg</code> 或 <code>bin</code> 中。
当构建一个命令时，以导入路径的最后一个元素命名的可执行文件将会写入到当前目录。
当构建一个包时，<code>go build</code> 仅仅为测试该包及其依赖能否被构建而服务。
（此时产生的包对象会被丢弃。）
</p>


<div class="english">
<h2 id="Testing">Testing</h2>
</div>

<h2 id="测试">测试</h2>

<div class="english">
<p>
Go has a lightweight test framework composed of the <code>go test</code>
command and the <code>testing</code> package.
</p>
</div>

<p>
Go拥有一个轻量级的测试框架，它由 <code>go test</code> 命令与 <code>testing</code> 包构成。
</p>

<div class="english">
<p>
You write a test by creating a file with a name ending in <code>_test.go</code>
that contains functions named <code>TestXXX</code> with signature
<code>func (t *testing.T)</code>.
The test framework runs each such function;
if the function calls a failure function such as <code>t.Error</code> or
<code>t.Fail</code>, the test is considered to have failed.
</p>
</div>

<p>
你可以通过创建一个以 <code>_test.go</code> 结尾的文件来编写一个测试，它包含命名为 <code>TestXXX</code>
的函数与签名 <code>func (t *testing.T)</code>。该测试框架运行每一个这样的函数，若该函数调用一个失败函数，如
<code>t.Error</code> 或 <code>t.Fail</code>，该测试就被认定为失败。
</p>

<div class="english">
<p>
Add a test to the <code>newmath</code> package by creating the file
<code>$GOPATH/src/example/newmath/sqrt_test.go</code> containing the following
Go code.
</p>
</div>

<p>
通过创建包含以下Go代码的文件 <code>$GOPATH/src/example/newmath/sqrt_test.go</code> 来为
<code>newmath</code>包添加一个测试。
</p>

<pre>
package newmath

import "testing"

func TestSqrt(t *testing.T) {
	const in, out = 4, 2
	if x := Sqrt(in); x != out {
		t.Errorf("Sqrt(%v) = %v, want %v", in, x, out)
        }
}
</pre>

<div class="english">
<p>
Now run the test with <code>go test</code>:
</p>
</div>

<p>
现在使用 <code>go test</code> 运行测试：
</p>

<pre>
$ go test example/newmath
ok  	example/newmath 0.165s
</pre>

<div class="english">
<p>
Run <code><a href="/cmd/go/#Test_packages">go help test</a></code> and see the
<a href="/pkg/testing/">testing package documentation</a> for more detail.
</p>
</div>

<p>
更多详情请运行 <code><a href="/cmd/go/#Test_packages">go help test</a></code> 并查看
<a href="/pkg/testing/">测试包文档</a>。
</p>


<div class="english">
<h2 id="remote">Remote packages</h2>
</div>

<h2 id="远程">远程包</h2>

<div class="english">
<p>
An import path can describe how to obtain the package source code using a
revision control system such as Git or Mercurial. The <code>go</code> command uses
this property to automatically fetch packages from remote repositories.
For instance, the examples described in this document are also kept in a
Mercurial repository hosted at Google Code,
<code><a href="http://code.google.com/p/go.example">code.google.com/p/go.example</a></code>.
If you include the repository URL in the package's import path,
<code>go get</code> will fetch, build, and install it automatically:
</p>
</div>

<p>
导入路径可描述如何使用版本控制系统（如Git或Mercurial）来获得包源码。<code>go</code>
命令使用此性质自动从远程仓库来获取包。例如，本文档描述的例子也存放在一个托管于Google Code的Mercurial仓库中，
<code><a href="http://code.google.com/p/go.example">code.google.com/p/go.example</a></code>。
若你在该包的导入路径中包含仓库地址，<code>go get</code> 将自动获取、构建并安装它：
</p>

<pre>
$ go get code.google.com/p/go.example/hello
$ $GOPATH/bin/hello
Hello, world.  Sqrt(2) = 1.414213562373095
</pre>

<div class="english">
<p>
If the specified package is not present in a workspace, <code>go get</code>
will place it inside the first workspace specified by <code>GOPATH</code>.
(If the package does already exist, <code>go get</code> skips the remote
fetch and behaves the same as <code>go install</code>.)
</p>
</div>

<p>
If the specified package is not present in a workspace, <code>go get</code>
will place it inside the first workspace specified by <code>GOPATH</code>.
(If the package does already exist, <code>go get</code> skips the remote
fetch and behaves the same as <code>go install</code>.)
若指定的包在工作空间中并不存在，<code>go get</code> 会将它放在 <code>GOPATH</code> 指定的第一个工作空间中。
（若该包已存在，<code>go get</code> 会跳过远程获取，其行表现与 <code>go install</code> 相同。）
</p>

<div class="english">
<p>
After issuing the above <code>go get</code> command, the workspace directory
tree should now now look like this:
</p>
</div>

<p>
在发出上面的 <code>go get</code> 命令后，工作空间目录树现在看起来像这样：
</p>

<div class="english">
<pre>
bin/
    hello                 # command executable
pkg/
    linux_amd64/
        code.google.com/p/go.example/
            newmath.a     # package object
        example/
            newmath.a     # package object
src/
    code.google.com/p/go.example/
        hello/
            hello.go      # command source
        newmath/
            sqrt.go       # package source
            sqrt_test.go  # test source
    example/
        hello/
            hello.go      # command source
        newmath/
            sqrt.go       # package source
            sqrt_test.go  # test source
</pre>
</div>

<pre>
bin/
    hello                 # 可执行命令
pkg/
    linux_amd64/
        code.google.com/p/go.example/
            newmath.a     # 包对象
        example/
            newmath.a     # 包对象
src/
    code.google.com/p/go.example/
        hello/
            hello.go      # 命令源码
        newmath/
            sqrt.go       # 包源码
            sqrt_test.go  # 测试源码
    example/
        hello/
            hello.go      # 命令源码
        newmath/
            sqrt.go       # 包源码
            sqrt_test.go  # 测试源码
</pre>

<div class="english">
<p>
The <code>hello</code> command hosted at Google Code depends on the
<code>newmath</code> package within the same repository. The imports in
<code>hello.go</code> file use the same import path convention, so the <code>go
get</code> command is able to locate and install the dependent package, too.
</p>
</div>

<p>
<code>hello</code> 命令托管在Google Code上，它依赖相同代码库中的 <code>newmath</code> 包。
<code>hello.go</code> 文件中的导入使用相同的导入路径约定，因此 <code>go get</code> 命令亦可定位并安装该依赖包。
</p>

<pre>
import "code.google.com/p/go.example/newmath"
</pre>

<div class="english">
<p>
This convention is the easiest way to make your Go packages available for
others to use.
The <a href="http://godashboard.appspot.com">Go Project Dashboard</a>
is a list of external Go projects including programs and libraries.
</p>
</div>

<p>
此约定是使你的Go包让别人有效使用最容易的方式。
<a href="http://godashboard.appspot.com">Go项目仪表盘</a>为包括程序与库在内的外部Go项目列表。
</p>

<div class="english">
<p>
For more information on using remote repositories with the <code>go</code> command, see
<code><a href="/cmd/go/#Remote_import_path_syntax">go help remote</a></code>.
</p>
</div>

<p>
更多通过 <code>go</code> 命令使用远程仓库的信息见
<code><a href="/cmd/go/#Remote_import_path_syntax">go help remote</a></code>。
</p>


<div class="english">
<h2 id="more">Further reading</h2>
</div>

<h2 id="more">进一步阅读</h2>

<div class="english">
<p>
See <a href="/doc/effective_go.html">Effective Go</a> for tips on writing
clear, idiomatic Go code.
</p>
</div>

<p>
<a href="/doc/effective_go.html">实效Go编程</a>就编写清晰而地道的Go代码提供了一些技巧。
</p>

<div class="english">
<p>
Take <a href="http://tour.golang.org/">A Tour of Go</a> to learn the language
proper.
</p>
</div>

<p>
通过<a href="http://go-tour-zh.appsp0t.com">Go语言之旅</a>来了解该语言本身。
</p>

<div class="english">
<p>
Visit the <a href="/doc/#articles">documentation page</a> for a set of in-depth
articles about the Go language and its libraries and tools.
</p>
</div>

<p>
访问<a href="/doc/#articles">文档页面</a> 来获取一组关于Go语言及其库与工具的深入性文章。
</p>
