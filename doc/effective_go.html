<!--{
    "Title": "高效Go编程",
    "Template": true
}-->

<!--{
	"Title": "Effective Go",
	"Template": true
}-->

<div class="english">
<h2 id="introduction">Introduction</h2>
</div>

<h2 id="前言">前言</h2>

<div class="english">
<p>
Go is a new language.  Although it borrows ideas from
existing languages,
it has unusual properties that make effective Go programs
different in character from programs written in its relatives.
A straightforward translation of a C++ or Java program into Go
is unlikely to produce a satisfactory result&mdash;Java programs
are written in Java, not Go.
On the other hand, thinking about the problem from a Go
perspective could produce a successful but quite different
program.
In other words,
to write Go well, it's important to understand its properties
and idioms.
It's also important to know the established conventions for
programming in Go, such as naming, formatting, program
construction, and so on, so that programs you write
will be easy for other Go programmers to understand.
</p>
</div>

<p>
Go是一门新的语言。尽管它从已有的语言中借鉴了一些理念，但其出众的特性，
使高效的Go程序不同于其它语言编写的程序。
将C++或Java程序直译为Go并不能产生满意的结果——毕竟Java程序是用Java编写的，而不是Go。
另一方面，以Go的观点考虑问题将产生非常成功但非常不同的程序。换句话说，要将Go程序写得好，
就必须理解其特性和风格。了解使用Go编程的既定规则也十分重要的，例如命名、格式化、
程序结构等等，这样你所编写的程序将更容易被其他程序员所理解。
</p>

<div class="english">
<p>
This document gives tips for writing clear, idiomatic Go code.
It augments the <a href="/ref/spec">language specification</a>,
the <a href="http://tour.golang.org/">Tour of Go</a>,
and <a href="/doc/code.html">How to Write Go Code</a>,
all of which you
should read first.
</p>
</div>

<p>
本文档就如何编写清晰、地道的Go代码提供了一些技巧。它是对<a href="/ref/spec">语言规范</a>，
<a href="http://tour.golang.org/">Go语言之旅</a>以及<a href="/doc/code.html">如何编写Go代码</a>的补充，
在阅读本文档之前，你应该先阅读这些文档。
</p>

<div class="english">
<h3 id="examples">Examples</h3>
</div>

<h3 id="示例">示例</h3>

<div class="english">
<p>
The <a href="/src/pkg/">Go package sources</a>
are intended to serve not
only as the core library but also as examples of how to
use the language.
If you have a question about how to approach a problem or how something
might be implemented, they can provide answers, ideas and
background.
</p>
</div>

<p>
<a href="/src/pkg/">Go包源码</a>不仅是核心库，同时也是如何使用该语言的示例源码。
如果你有关于如何解决问题或某些东西如何实现方面的疑问，它们可以提供答案、思路和背景。
</p>


<div class="english">
<h2 id="formatting">Formatting</h2>
</div>

<h2 id="格式化">格式化</h2>

<div class="english">
<p>
Formatting issues are the most contentious
but the least consequential.
People can adapt to different formatting styles
but it's better if they don't have to, and
less time is devoted to the topic
if everyone adheres to the same style.
The problem is how to approach this Utopia without a long
prescriptive style guide.
</p>
</div>

<p>
格式化总是最具争议性的问题，但很难争论出结果。人们可以采取不同的格式化风格，
但如果不这样做的话会更好，如果所有人都遵循相同的风格，那么花费在该问题上的时间将会更少。
问题在于如何实现这个理想，而无需一个冗长的风格手册。
</p>

<div class="english">
<p>
With Go we take an unusual
approach and let the machine
take care of most formatting issues.
The <code>gofmt</code> program
(also available as <code>go fmt</code>, which
operates at the package level rather than source file level)
reads a Go program
and emits the source in a standard style of indentation
and vertical alignment, retaining and if necessary
reformatting comments.
If you want to know how to handle some new layout
situation, run <code>gofmt</code>; if the answer doesn't
seem right, rearrange your program (or file a bug about <code>gofmt</code>),
don't work around it.
</p>
</div>

<p>
在Go中我们使用了一种特别的方法，即让机器来处理大部分格式化问题。<code>gofmt</code>
程序（也可使用 <code>go fmt</code>，它在包的级别上而非源文件的级别上进行操作）
读取Go程序并按照缩进和对齐的标准风格生成源码，保留并在需要时重新格式化注释。
如果你想知道如何处理一些新的布局情况，请运行 <code>gofmt</code>；如果结果看起来不太对，
请从新调整你的程序（或提交一个关于 <code>gofmt</code> 的Bug），而不要自己去修改它。
</p>

<div class="english">
<p>
As an example, there's no need to spend time lining up
the comments on the fields of a structure.
<code>Gofmt</code> will do that for you.  Given the
declaration
</p>
</div>

<p>
举例来说，对于结构中字段的注释，并不需要花时间将他们对齐。<code>gofmt</code>
会为你做这些事。对于给定的声明
</p>

<div class="english">
<pre>
type T struct {
    name string // name of the object
    value int // its value
}
</pre>
</div>

<pre>
type T struct {
    name string // 对象的名字
    value int // 它的值
}
</pre>

<div class="english">
<p>
<code>gofmt</code> will line up the columns:
</p>
</div>

<p>
<code>gofmt</code> 会按列对齐为：
</p>

<div class="english">
<pre>
type T struct {
    name    string // name of the object
    value   int    // its value
}
</pre>
</div>

<pre>
type T struct {
    name    string // 对象的名字
    value   int    // 它的值
}
</pre>

<div class="english">
<p>
All Go code in the standard packages has been formatted with <code>gofmt</code>.
</p>
</div>

<p>
在标准包中的所有Go代码都已经使用 <code>gofmt</code> 格式化过了。
</p>


<div class="english">
<p>
Some formatting details remain.  Very briefly,
</p>
</div>

<p>
一些格式化细节需要保留。这些都非常简单明了：
</p>

<div class="english">
<dl>
    <dt>Indentation</dt>
    <dd>We use tabs for indentation and <code>gofmt</code> emits them by default.
    Use spaces only if you must.
    </dd>
    <dt>Line length</dt>
    <dd>
    Go has no line length limit.  Don't worry about overflowing a punched card.
    If a line feels too long, wrap it and indent with an extra tab.
    </dd>
    <dt>Parentheses</dt>
    <dd>
    Go needs fewer parentheses: control structures (<code>if</code>,
    <code>for</code>, <code>switch</code>) do not have parentheses in
    their syntax.
    Also, the operator precedence hierarchy is shorter and clearer, so
<pre>
x&lt;&lt;8 + y&lt;&lt;16
</pre>
    means what the spacing implies.
    </dd>
</dl>
</div>

<dl>
    <dt>缩进</dt>
    <dd>我们使用制表符（tab）缩进，<code>gofmt</code> 默认也使用它。你也可以特意使用空格。
    </dd>
    <dt>行的长度</dt>
    <dd>
    Go没有行的长度限制。不要担心代码会在穿孔卡片上溢出。如果一行实在太长，
    可以进行折行并使用一个额外的制表符将其缩进。
    </dd>
    <dt>圆括号</dt>
    <dd>
    Go很少需要括号：控制结构（<code>if</code>、<code>for</code> 和 <code>switch</code>）
    在语法上不需要圆括号。此外，操作符优先级将变得更加简短而清楚，因此
<pre>
x&lt;&lt;8 + y&lt;&lt;16
</pre>
    所表达的意思与其中空格暗示的一样。
    </dd>
</dl>

<div class="english">
<h2 id="commentary">Commentary</h2>
</div>

<h2 id="注释">注释</h2>

<div class="english">
<p>
Go provides C-style <code>/* */</code> block comments
and C++-style <code>//</code> line comments.
Line comments are the norm;
block comments appear mostly as package comments and
are also useful to disable large swaths of code.
</p>
</div>

<p>
Go提供C风格的 <code>/* */</code> 块注释和C++风格的 <code>//</code> 行注释。
行注释是标准的，而块注释大多在包注释，或禁用一大段代码时使用。
</p>

<div class="english">
<p>
The program—and web server—<code>godoc</code> processes
Go source files to extract documentation about the contents of the
package.
Comments that appear before top-level declarations, with no intervening newlines,
are extracted along with the declaration to serve as explanatory text for the item.
The nature and style of these comments determines the
quality of the documentation <code>godoc</code> produces.
</p>
</div>

<p>
<code>godoc</code> 既是一个程序，又是一个Web服务器，它对Go的源码进行处理，提取其包中的文档内容。
出现在顶级声明之前，且中间不包括新行的注释将与该声明一起被提取出来，作为该条目的解释文本。
这些注释的内容和样式决定了 <code>godoc</code> 生成的文档质量。
</p>

<div class="english">
<p>
Every package should have a <i>package comment</i>, a block
comment preceding the package clause.
For multi-file packages, the package comment only needs to be
present in one file, and any one will do.
The package comment should introduce the package and
provide information relevant to the package as a whole.
It will appear first on the <code>godoc</code> page and
should set up the detailed documentation that follows.
</p>
</div>

<p>
每个包都应该有一个<i>包注释</i>，放置在包子句前的一个块注释。对于包含多文件的包，
包注释只需出现在一个文件中，任何一个文件都可以。包注释应在整体上对该包行径介绍，
并提供包的相关信息。它将在 <code>godoc</code> 页面中首先出现，并为其下的内容建立详细的文档。
</p>

<div class="english">
<pre>
/*
    Package regexp implements a simple library for
    regular expressions.

    The syntax of the regular expressions accepted is:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
</pre>
</div>

<pre>
/*
    包regexp为正则表达式实现了一个简单的库。

    该正则表达式接受的语法为：

    正则表达式:
        串联 { '|' 串联 }
    串联:
        { 闭包 }
    闭包:
        条目 [ '*' | '+' | '?' ]
    条目:
        '^'
        '$'
        '.'
        字符
        '[' [ '^' ] 字符遍历 ']'
        '(' 正则表达式 ')'
*/
package regexp
</pre>

<div class="english">
<p>
If the package is simple, the package comment can be brief.
</p>
</div>

<p>
如果包很简单，则该包的注释也可以很简洁。
</p>

<div class="english">
<pre>
// Package path implements utility routines for
// manipulating slash-separated filename paths.
</pre>
</div>

<pre>
// 包path为斜杠分隔的文件名路径的操作实现了实用工具。
</pre>

<div class="english">
<p>
Comments do not need extra formatting such as banners of stars.
The generated output may not even be presented in a fixed-width font, so don't depend
on spacing for alignment&mdash;<code>godoc</code>, like <code>gofmt</code>,
takes care of that.
The comments are uninterpreted plain text, so HTML and other
annotations such as <code>_this_</code> will reproduce <i>verbatim</i> and should
not be used.
Depending on the context, <code>godoc</code> might not even
reformat comments, so make sure they look good straight up:
use correct spelling, punctuation, and sentence structure,
fold long lines, and so on.
</p>
</div>

<p>
注释无需额外的格式化，比如星号横幅。生成的输出甚至可能无法以等宽字体显示，因此不要依赖于空格对齐，
<code>godoc</code> 和 <code>gofmt</code> 一样，会自动对这些进行处理。注释是不被会解析的纯文本，
因此像HTML或其它类似于 <code>_this_</code> 的东西将按<i>原样</i>输出，因此不应使用它们。
根据上下文，<code>godoc</code> 可能不会重新格式化注释，因此必须保证它们看上去是直白的：
使用正确的拼写、标点和语句结构，折叠长行等等。
</p>

<div class="english">
<p>
Inside a package, any comment immediately preceding a top-level declaration
serves as a <i>doc comment</i> for that declaration.
Every exported (capitalized) name in a program should
have a doc comment.
</p>
</div>

<p>
在包中，任何放在顶级声明前面的注释都将作为该声明的<i>文档注释</i>。
在程序中，每个已导出（首字母大写）的名称都应该有文档注释。
</p>

<div class="english">
<p>
Doc comments work best as complete sentences, which allow
a wide variety of automated presentations.
The first sentence should be a one-sentence summary that
starts with the name being declared.
</p>
</div>

<p>
文档注释最好为完整的句子，这样它就能适用于各种自动化展示。第一句应当为一个单句的摘要，
并以被声明的东西开头。
</p>

<div class="english">
<pre>
// Compile parses a regular expression and returns, if successful, a Regexp
// object that can be used to match against text.
func Compile(str string) (regexp *Regexp, err error) {
</pre>
</div>

<pre>
// Compile用于解析正则表达式并返回，如果成功，则Regexp对象就可用于匹配所针对的文本。
func Compile(str string) (regexp *Regexp, err error) {
</pre>

<div class="english">
<p>
Go's declaration syntax allows grouping of declarations.
A single doc comment can introduce a group of related constants or variables.
Since the whole declaration is presented, such a comment can often be perfunctory.
</p>
</div>

<p>
Go的声明语法允许成组声明。单个文档注释可介绍一组相关的常量或变量。
由于是整体声明，这种注释往往是概括性的。
</p>

<div class="english">
<pre>
// Error codes returned by failures to parse an expression.
var (
    ErrInternal      = errors.New("regexp: internal error")
    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
    ...
)
</pre>
</div>

<pre>
// 通过解析表达式失败来返回错误代码。
var (
    ErrInternal      = errors.New("regexp: internal error")
    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
    ...
)
</pre>

<div class="english">
<p>
Even for private names, grouping can also indicate relationships between items,
such as the fact that a set of variables is protected by a mutex.
</p>
</div>

<p>
即便是对于私有名称，也可通过成组声明来表明条目之间的关系，例如实际由互斥体保护的一组变量。
</p>

<pre>
var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
</pre>

<div class="english">
<h2 id="names">Names</h2>
</div>

<h2 id="命名">命名</h2>

<div class="english">
<p>
Names are as important in Go as in any other language.
In some cases they even have semantic effect: for instance,
the visibility of a name outside a package is determined by whether its
first character is upper case.
It's therefore worth spending a little time talking about naming conventions
in Go programs.
</p>
</div>

<p>
命名在Go中与在其他语言中一样重要。在某些情况下，它们甚至会对语义有影响：
例如，一个名称在包外的可见性就由其首个字符是否为大写字母来决定。
因此有必要花点时间来讨论Go程序中的命名约定。
</p>


<div class="english">
<h3 id="package-names">Package names</h3>
</div>

<h3 id="包名">包名</h3>

<div class="english">
<p>
When a package is imported, the package name becomes an accessor for the
contents.  After
</p>
</div>

<p>
当一个包被导入时，该包的包名会成为其内容的访问器。在
</p>

<pre>
import "bytes"
</pre>

<div class="english">
<p>
the importing package can talk about <code>bytes.Buffer</code>.  It's
helpful if everyone using the package can use the same name to refer to
its contents, which implies that the package name should be good:
short, concise, evocative.  By convention, packages are given
lower case, single-word names; there should be no need for underscores
or mixedCaps.
Err on the side of brevity, since everyone using your
package will be typing that name.
And don't worry about collisions <i>a priori</i>.
The package name is only the default name for imports; it need not be unique
across all source code, and in the rare case of a collision the
importing package can choose a different name to use locally.
In any case, confusion is rare because the file name in the import
determines just which package is being used.
</p>
</div>

<p>
之后，被导入的包就可以用 <code>bytes.Buffer</code> 了。
所有使用该包的人都以一个相同的名称来引用其内容是很有益的，这意味着包应该好好地命名：
名字应该简洁明了而易于理解。按照惯例，包应当以小写的单个单词来命名，且不应使用下划线或大小写混合。
Err的命名就是出于简短考虑的，因为任何使用你的包的人都会键入该名称。不必担心它与<i>已有的</i>东西冲突。
包的名称是唯一需要导入的默认名称，它并不需要在所有源码上都是唯一的，即便在少数发生冲突的情况下，
也可选择一个不同的名字导入该包以便于局部地使用。不论如何，由于可通过文件名判定使用的是哪个包，
因此不会产生混淆。
</p>

<div class="english">
<p>
Another convention is that the package name is the base name of
its source directory;
the package in <code>src/pkg/encoding/base64</code>
is imported as <code>"encoding/base64"</code> but has name <code>base64</code>,
not <code>encoding_base64</code> and not <code>encodingBase64</code>.
</p>
</div>

<p>
另一个约定就是包名应为其源码目录的基本名称。在 <code>src/pkg/encoding/base64</code>
中的包应作为 <code>"encoding/base64"</code> 被导入，而其包名应为 <code>base64</code>，
而不是 <code>encoding_base64</code> 或 <code>encodingBase64</code>。
</p>

<div class="english">
<p>
The importer of a package will use the name to refer to its contents
(the <code>import .</code> notation is intended mostly for tests and other
unusual situations and should be avoided unless necessary),
so exported names in the package can use that fact
to avoid stutter.
For instance, the buffered reader type in the <code>bufio</code> package is called <code>Reader</code>,
not <code>BufReader</code>, because users see it as <code>bufio.Reader</code>,
which is a clear, concise name.
Moreover,
because imported entities are always addressed with their package name, <code>bufio.Reader</code>
does not conflict with <code>io.Reader</code>.
Similarly, the function to make new instances of <code>ring.Ring</code>&mdash;which
is the definition of a <em>constructor</em> in Go&mdash;would
normally be called <code>NewRing</code>, but since
<code>Ring</code> is the only type exported by the package, and since the
package is called <code>ring</code>, it's called just <code>New</code>,
which clients of the package see as <code>ring.New</code>.
Use the package structure to help you choose good names.
</p>
</div>

<p>
包的导入者会使用该包的包名来引用其内容（<code>import .</code> 往往只用于测试或其他特殊情况，
若非必要，应尽量避免使用），因此包中的已导出名称就可据此避免冲突。例如，<code>bufio</code>
包中的缓存读取器类型叫做 <code>Reader</code> 而非 <code>BufReader</code>，因为用户看到的其实是
<code>bufio.Reader</code>，这是个清楚而简洁的名称。此外，由于被导入的实体总是通过它们的包名来确定，
因此 <code>bufio.Reader</code> 就不会与 <code>io.Reader</code> 发生冲突。同样，
创建了 <code>ring.Ring</code> 的新实例的函数——这就是Go中的<em>构造器</em>——一般会称之为
<code>NewRing</code>，但由于 <code>Ring</code> 是该包所导出的唯一类型，且该包也叫
<code>ring</code>，因此它可以只成为 <code>New</code>，它跟在包的后面，就像
<code>ring.New</code>。使用包接哦股可以帮助你选择好的名称。
</p>

<div class="english">
<p>
Another short example is <code>once.Do</code>;
<code>once.Do(setup)</code> reads well and would not be improved by
writing <code>once.DoOrWaitUntilDone(setup)</code>.
Long names don't automatically make things more readable.
If the name represents something intricate or subtle, it's usually better
to write a helpful doc comment than to attempt to put all the information
into the name.
</p>
</div>

<p>
另一个简短的例子是 <code>once.Do</code>。<code>once.Do(setup)</code> 读起来很好，
将它写作 <code>once.DoOrWaitUntilDone(setup)</code> 也不会更好。
长的名称并不会自动使事情变得更有可读性。如果该名称所代表的东西比较复杂而微妙，
通常更好的方法是编写一个有帮助的文档注释，而不是将所有信息都放到名称当中。
</p>

<div class="english">
<h3 id="Getters">Getters</h3>
</div>

<h3 id="获取器">获取器</h3>

<div class="english">
<p>
Go doesn't provide automatic support for getters and setters.
There's nothing wrong with providing getters and setters yourself,
and it's often appropriate to do so, but it's neither idiomatic nor necessary
to put <code>Get</code> into the getter's name.  If you have a field called
<code>owner</code> (lower case, unexported), the getter method should be
called <code>Owner</code> (upper case, exported), not <code>GetOwner</code>.
The use of upper-case names for export provides the hook to discriminate
the field from the method.
A setter function, if needed, will likely be called <code>SetOwner</code>.
Both names read well in practice:
</p>
</div>

<p>
Go并不对获取器（getter）和设置器（setter）提供自动的支持。如果你要自己提供获取器和设置器，
这并没有什么不对，而且往往是很恰当的。但要将 <code>Get</code> 放到获取器的名字中，
既不符合习惯，也没有必要。如果你拥有一个称之为 <code>owner</code> （小写，未导出）的字段，
那么该获取器的方法应称为 <code>Owner</code>（大写，已导出）而非 <code>GetOwner</code>。
使用大写字母名称来进行导出提供了一种挂钩，以将字段和方法区别开来。如果需要，
一个设置器函数也应类似于 <code>SetOwner</code>。两种名称在实践中读起来都很好。
</p>

<pre>
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
</pre>

<div class="english">
<h3 id="interface-names">Interface names</h3>
</div>

<h3 id="接口名">接口名</h3>

<div class="english">
<p>
By convention, one-method interfaces are named by
the method name plus the -er suffix: <code>Reader</code>,
<code>Writer</code>, <code>Formatter</code> etc.
</p>
</div>

<p>
按照约定，单方法的结构应以该方法的名称加上-er后缀来命名，如 <code>Reader</code>、
<code>Writer</code>、<code>Formatter</code> 等。
</p>

<div class="english">
<p>
There are a number of such names and it's productive to honor them and the function
names they capture.
<code>Read</code>, <code>Write</code>, <code>Close</code>, <code>Flush</code>,
<code>String</code> and so on have
canonical signatures and meanings.  To avoid confusion,
don't give your method one of those names unless it
has the same signature and meaning.
Conversely, if your type implements a method with the
same meaning as a method on a well-known type,
give it the same name and signature;
call your string-converter method <code>String</code> not <code>ToString</code>.
</p>
</div>

<p>
这类的名称有很多，用这种方法来表示它们自身以及它们所代表的函数名是非常有用的。
<code>Read</code>、<code>Write</code>、<code>Close</code>、<code>Flush</code>、<code>String</code>
等都具有典型的签名和意义。为避免混淆，你的方法请不要使用这些名称，除非它们拥有相同的签名和意义。
相反地，如果你的类型实现了一个与这些知名的类型具有相同意义的方法，请保持它们的名称和签名相同，
请将你的字符串转换方法称为 <code>String</code> 而非 <code>ToString</code>。
</p>

<h3 id="混合大小写">混合大小写</h3>

<div class="english">
<p>
Finally, the convention in Go is to use <code>MixedCaps</code>
or <code>mixedCaps</code> rather than underscores to write
multiword names.
</p>
</div>

<p>
最后，Go中约定使用 <code>MixedCaps</code> 或 <code>mixedCaps</code> 的大小写混合形式，
而非下划线来写多单词名称。
</p>

<div class="english">
<h2 id="semicolons">Semicolons</h2>
</div>

<h2 id="分号">分号</h2>

<div class="english">
<p>
Like C, Go's formal grammar uses semicolons to terminate statements;
unlike C, those semicolons do not appear in the source.
Instead the lexer uses a simple rule to insert semicolons automatically
as it scans, so the input text is mostly free of them.
</p>
</div>

<p>
和C一样，Go的正式语法使用分号来终止语句；和C不同的是，这些分号并在源码中出现。
取而代之，词法分析器在扫描时使用一条简单的规则来自动插入分号，因此输入的文本多数时候就不需要它们了。
</p>

<div class="english">
<p>
The rule is this. If the last token before a newline is an identifier
(which includes words like <code>int</code> and <code>float64</code>),
a basic literal such as a number or string constant, or one of the
tokens
</p>
</div>

<p>
规则是这样的：若在新行前的最后一个标记为标识符（包括像 <code>int</code> 和
<code>float64</code> 这样的文字）、像数值或字符串常量的基本字面或以下标记中的一个
</p>

<pre>
break continue fallthrough return ++ -- ) }
</pre>

<div class="english">
<p>
the lexer always inserts a semicolon after the token.
This could be summarized as, &ldquo;if the newline comes
after a token that could end a statement, insert a semicolon&rdquo;.
</p>
</div>

<p>
则词法分析将始终在该标记后面插入分号。这点可以概括为：
“如果新行前的标记为语句的末尾，则插入分号”。
</p>

<div class="english">
<p>
A semicolon can also be omitted immediately before a closing brace,
so a statement such as
</p>
</div>

<p>
分号也可在闭括号之前直接省略，因此像
</p>

<pre>
    go func() { for { dst &lt;- &lt;-src } }()
</pre>

<div class="english">
<p>
needs no semicolons.
Idiomatic Go programs have semicolons only in places such as
<code>for</code> loop clauses, to separate the initializer, condition, and
continuation elements.  They are also necessary to separate multiple
statements on a line, should you write code that way.
</p>
</div>

<p>
这样的语句无需分号。通常Go程序只在诸如 <code>for</code> 循环子句这样的地方使用分号，
以此来将初始化器、条件及增量元素分开。如果你在一行中写多个语句，也需要用分号隔开。
</p>

<div class="english">
<p>
One caveat. You should never put the opening brace of a
control structure (<code>if</code>, <code>for</code>, <code>switch</code>,
or <code>select</code>) on the next line.  If you do, a semicolon
will be inserted before the brace, which could cause unwanted
effects.  Write them like this
</p>
</div>

<p>
警告：无论如何，你都不应将一个控制结构（<code>if</code>、<code>for</code>、<code>switch</code>
或 <code>select</code>）的左大括号放在下一行。如果这样做，就会在大括号的前方插入一个分号，这可能引起不需要的效果。
你应该这样写
</p>

<div class="english">
<pre>
if i &lt; f() {
    g()
}
</pre>
<p>
not like this
</p>
<pre>
if i &lt; f()  // wrong!
{           // wrong!
    g()
}
</pre>
</div>

<pre>
if i &lt; f() {
    g()
}
</pre>
<p>
而不是这样
</p>
<pre>
if i &lt; f()  // 错！
{           // 错！
    g()
}
</pre>


<div class="english">
<h2 id="control-structures">Control structures</h2>
</div>

<h2 id="控制结构">控制结构</h2>

<div class="english">
<p>
The control structures of Go are related to those of C but differ
in important ways.
There is no <code>do</code> or <code>while</code> loop, only a
slightly generalized
<code>for</code>;
<code>switch</code> is more flexible;
<code>if</code> and <code>switch</code> accept an optional
initialization statement like that of <code>for</code>;
and there are new control structures including a type switch and a
multiway communications multiplexer, <code>select</code>.
The syntax is also slightly different:
there are no parentheses
and the bodies must always be brace-delimited.
</p>
</div>

<p>
Go的控制语句虽然和C有关，但在一些重要的方面又有所不同。其中没有 <code>do</code>
或 <code>while</code> 循环，只有一个更广义的 <code>for</code> 循环；<code>switch</code>
要更灵活一点；<code>if</code> 和 <code>switch</code> 像 <code>for</code>一样可接受可选的初始化语句；
此外，还有一个包含类型选择和多路通信复用器的新控制结构：<code>select</code>。
其语法也有些许不同：没有圆括号，而其主体必须始终使用大括号括住。
</p>

<h3 id="if">If</h3>

<div class="english">
<p>
In Go a simple <code>if</code> looks like this:
</p>
</div>

<p>
在Go中，一个简单的 <code>if</code> 语句看起来像这样：
</p>

<pre>
if x &gt; 0 {
    return y
}
</pre>

<div class="english">
<p>
Mandatory braces encourage writing simple <code>if</code> statements
on multiple lines.  It's good style to do so anyway,
especially when the body contains a control statement such as a
<code>return</code> or <code>break</code>.
</p>
</div>

<p>
强制的大括号鼓励编写简单的多行 <code>if</code> 语句。总之，这是一种好的风格，
特别是在主体包含诸如 <code>return</code> 或 <code>break</code> 这样的控制语句时。
</p>

<div class="english">
<p>
Since <code>if</code> and <code>switch</code> accept an initialization
statement, it's common to see one used to set up a local variable.
</p>
</div>

<p>
由于 <code>if</code> 和 <code>switch</code> 接受初始化与局，因此经常可以看到它们被用于创建局部变量。
</p>

<pre>
if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
</pre>

<div class="english">
<p id="else">
In the Go libraries, you'll find that
when an <code>if</code> statement doesn't flow into the next statement—that is,
the body ends in <code>break</code>, <code>continue</code>,
<code>goto</code>, or <code>return</code>—the unnecessary
<code>else</code> is omitted.
</p>
</div>

<p id="else">
在Go的库中，你会发现当 <code>if</code> 语句不会执行到下一句时——也就是说，
其主体以 <code>break</code>、<code>continue</code>、<code>goto</code> 或
<code>return</code> 结束——不必要的 <code>else</code> 会被省略。
</p>

<pre>
f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
</pre>

<div class="english">
<p>
This is an example of a common situation where code must guard against a
sequence of error conditions.  The code reads well if the
successful flow of control runs down the page, eliminating error cases
as they arise.  Since error cases tend to end in <code>return</code>
statements, the resulting code needs no <code>else</code> statements.
</p>
</div>

<p>
以下为代码必须防止一系列错误条件的例子。如果控制流程成功地向下运行，
在排除错误的情况下，代码读起来很好。由于错误情况常在 <code>return</code>
语句中终止，最终代码也就无需 <code>else</code> 语句了。
</p>

<pre>
f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
</pre>


<div class="english">
<h3 id="redeclaration">Redeclaration</h3>
</div>

<h3 id="重复声明">重复声明</h3>

<p>
顺便说一下：上一节中的最后一个例子展示了短声明形式 <code>:=</code> 的详细工作方式。
调用了 <code>os.Open</code> 的声明语句为
</p>

<pre>
f, err := os.Open(name)
</pre>

<div class="english">
<p>
This statement declares two variables, <code>f</code> and <code>err</code>.
A few lines later, the call to <code>f.Stat</code> reads,
</p>
</div>

<p>
该语句声明了两个变量 <code>f</code> 与 <code>err</code>。在几行之后，又通过以下语句调用了 <code>f.Stat</code>
</p>

<pre>
d, err := f.Stat()
</pre>

<div class="english">
<p>
which looks as if it declares <code>d</code> and <code>err</code>.
Notice, though, that <code>err</code> appears in both statements.
This duplication is legal: <code>err</code> is declared by the first statement,
but only <em>re-assigned</em> in the second.
This means that the call to <code>f.Stat</code> uses the existing
<code>err</code> variable declared above, and just gives it a new value.
</p>
</div>

<p>
该语句看起来是声明了 <code>d</code> 和 <code>err</code>。注意，在两个语句中都出现了
<code>err</code>。这种重复是合法的：<code>err</code> 在第一个语句中被声明，
而在第二个语句中只是被<em>重新赋值</em>了。这意味着对 <code>f.Stat</code>
的调用使用的是前面已声明的 <code>err</code> 变量，这里只是给它一个新的值而已。
</p>

<div class="english">
<p>
In a <code>:=</code> declaration a variable <code>v</code> may appear even
if it has already been declared, provided:
</p>
</div>

<p>
在满足以下条件时，变量 <code>v</code> 可出现在 <code>:=</code> 声明中，即使该变量已被声明：
</p>

<div class="english">
<ul>
<li>this declaration is in the same scope as the existing declaration of <code>v</code>
(if <code>v</code> is already declared in an outer scope, the declaration will create a new variable),</li>
<li>the corresponding value in the initialization is assignable to <code>v</code>, and</li>
<li>there is at least one other variable in the declaration that is being declared anew.</li>
</ul>
</div>

<ul>
<li>该声明的作用域与已存在的 <code>v</code> 的声明作用域相同（若 <code>v</code>
已在外层的作用域中声明，则会创建一个新的变量），</li>
<li>在初始化中相应类型的值才能赋予 <code>v</code>，并且</li>
<li>在声明中至少有另一个变量是新声明的。</li>
</ul>

<div class="english">
<p>
This unusual property is pure pragmatism,
making it easy to use a single <code>err</code> value, for example,
in a long <code>if-else</code> chain.
You'll see it used often.
</p>
</div>

<p>
这种不寻常的特性纯粹是出于实用主义，这使我们可以很方便地只使用一个 <code>err</code>
值，比如说在一个长的 <code>if-else</code> 链中。
</p>

<h3 id="for">For</h3>

<div class="english">
<p>
The Go <code>for</code> loop is similar to&mdash;but not the same as&mdash;C's.
It unifies <code>for</code>
and <code>while</code> and there is no <code>do-while</code>.
There are three forms, only one of which has semicolons.
</p>
</div>

<p>
Go的 <code>for</code> 循环与C的相似却不相同。它统一了 <code>for</code> 和 <code>while</code>，
因此也就不再有 <code>do-while</code> 了。它有三种形式，但只有一种需要分号。
</p>

<div class="english">
<pre>
// Like a C for
for init; condition; post { }

// Like a C while
for condition { }

// Like a C for(;;)
for { }
</pre>
</div>

<pre>
// 如同C的for循环
for init; condition; post { }

// 如同C的while循环
for condition { }

// 如同C的for(;;)循环
for { }
</pre>

<div class="english">
<p>
Short declarations make it easy to declare the index variable right in the loop.
</p>
</div>

<p>
使用简短声明能更够更容易地在循环中声明下表变量。
</p>

<pre>
sum := 0
for i := 0; i &lt; 10; i++ {
    sum += i
}
</pre>

<div class="english">
<p>
If you're looping over an array, slice, string, or map,
or reading from a channel, a <code>range</code> clause can
manage the loop.
</p>
</div>

<p>
若你是在一个数组、切片、字符串或映射中循环遍历，或从一个信道中读取的话，可使用一个
<code>range</code> 子句来管理循环。
</p>

<pre>
for key, value := range oldMap {
    newMap[key] = value
}
</pre>

<div class="english">
<p>
If you only need the first item in the range (the key or index), drop the second:
</p>
</div>

<p>
如果你只需要该遍历中的第一个条目（键或下标），去掉第二个就行了：
</p>

<pre>
for key := range m {
    if expired(key) {
        delete(m, key)
    }
}
</pre>

<div class="english">
<p>
If you only need the second item in the range (the value), use the <em>blank identifier</em>, an underscore, to discard the first:
</p>
</div>

<p>
如果你只需要该遍历中的第二个条目（值），请使用<em>空白标识符</em>，即一个下划线来丢弃第一个：
</p>

<pre>
sum := 0
for _, value := range array {
    sum += value
}
</pre>

<div class="english">
<p>
For strings, the <code>range</code> does more work for you, breaking out individual
Unicode characters by parsing the UTF-8.
Erroneous encodings consume one byte and produce the
replacement rune U+FFFD. The loop
</p>
</div>

<p>
对于字符串，<code>range</code> 能为你做更多的工作，它能通过解析UTF-8来分离单个的Unicode字符。
占用一个字节的错误编码以字符U+FFFD来代替。以下循环
</p>

<pre>
for pos, char := range "日本語" {
    fmt.Printf("character %c starts at byte position %d\n", char, pos)
}
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
将打印
</p>

<pre>
character 日 starts at byte position 0
character 本 starts at byte position 3
character 語 starts at byte position 6
</pre>

<pre>
for pos, char := range "日本語" {
    fmt.Printf("字符 %c 起始于字节位置 %d\n", char, pos)
}
</pre>

<div class="english">
<p>
Finally, Go has no comma operator and <code>++</code> and <code>--</code>
are statements not expressions.
Thus if you want to run multiple variables in a <code>for</code>
you should use parallel assignment.
</p>
<pre>
// Reverse a
for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
</pre>
</div>

<p>
最后，Go没有逗号操作符，而 <code>++</code> 和 <code>--</code> 为语句而非表达式。
因此如果你想要在 <code>for</code> 中使用多变量，就应该使用并列赋值。
</p>

<pre>
// 反转a
for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
</pre>

<h3 id="switch">Switch</h3>

<div class="english">
<p>
Go's <code>switch</code> is more general than C's.
The expressions need not be constants or even integers,
the cases are evaluated top to bottom until a match is found,
and if the <code>switch</code> has no expression it switches on
<code>true</code>.
It's therefore possible&mdash;and idiomatic&mdash;to write an
<code>if</code>-<code>else</code>-<code>if</code>-<code>else</code>
chain as a <code>switch</code>.
</p>
</div>

<p>
Go的 <code>switch</code> 比C的更通用。其表达式无需为常量或整数，它会自上而下地对每种情况进行求值，
直到发现一个匹配的为止，若 <code>switch</code> 后面没有表达式，它将匹配 <code>true</code>。
因此也可以——且习惯于将 <code>if</code>-<code>else</code>-<code>if</code>-<code>else</code>
链写成一个 <code>switch</code>。
</p>

<pre>
func unhex(c byte) byte {
    switch {
    case '0' &lt;= c &amp;&amp; c &lt;= '9':
        return c - '0'
    case 'a' &lt;= c &amp;&amp; c &lt;= 'f':
        return c - 'a' + 10
    case 'A' &lt;= c &amp;&amp; c &lt;= 'F':
        return c - 'A' + 10
    }
    return 0
}
</pre>

<div class="english">
<p>
There is no automatic fall through, but cases can be presented
in comma-separated lists.
</p>
</div>

<p>
switch并不会自动贯穿，但多个分支可通过逗号分隔的列表来呈现。
</p>

<pre>
func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&amp;', '=', '#', '+', '%':
        return true
    }
    return false
}
</pre>

<div class="english">
<p>
Here's a comparison routine for byte arrays that uses two
<code>switch</code> statements:
</p>
<pre>
// Compare returns an integer comparing the two byte arrays,
// lexicographically.
// The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b
func Compare(a, b []byte) int {
    for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ {
        switch {
        case a[i] &gt; b[i]:
            return 1
        case a[i] &lt; b[i]:
            return -1
        }
    }
    switch {
    case len(a) &lt; len(b):
        return -1
    case len(a) &gt; len(b):
        return 1
    }
    return 0
}
</pre>
</div>

<p>
Here's a comparison routine for byte arrays that uses two
<code>switch</code> statements:
以下程序通过使用两个 <code>switch</code> 语句对字节数组进行比较：
</p>
<pre>
// Compare按照字典顺序比较两个字节数组并返回一个整数，若a == b则结果为0，
// 若a &lt; b则结果为-1，若a &gt; b则结果为1
func Compare(a, b []byte) int {
    for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ {
        switch {
        case a[i] &gt; b[i]:
            return 1
        case a[i] &lt; b[i]:
            return -1
        }
    }
    switch {
    case len(a) &lt; len(b):
        return -1
    case len(a) &gt; len(b):
        return 1
    }
    return 0
}
</pre>

<div class="english">
<p>
A switch can also be used to discover the dynamic type of an interface
variable.  Such a <em>type switch</em> uses the syntax of a type
assertion with the keyword <code>type</code> inside the parentheses.
If the switch declares a variable in the expression, the variable will
have the corresponding type in each clause.
</p>
</div>

<p>
switch也可用于获取接口变量的动态类型。如<em>类型选择</em>通过圆括号中的关键字
<code>type</code> 使用类型断言语法。若switch在表达式中声明了一个变量，
在每个自己种都将有该变量对应的类型。
</p>

<pre>
switch t := interfaceValue.(type) {
default:
    fmt.Printf("unexpected type %T", t)  // %T prints type
case bool:
    fmt.Printf("boolean %t\n", t)
case int:
    fmt.Printf("integer %d\n", t)
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t)
case *int:
    fmt.Printf("pointer to integer %d\n", *t)
}
</pre>

<div class="english">
<h2 id="functions">Functions</h2>
</div>

<h2 id="函数">函数</h2>

<div class="english">
<h3 id="multiple-returns">Multiple return values</h3>
</div>

<h3 id="多返回值">多返回值</h3>

<div class="english">
<p>
One of Go's unusual features is that functions and methods
can return multiple values.  This form can be used to
improve on a couple of clumsy idioms in C programs: in-band
error returns (such as <code>-1</code> for <code>EOF</code>)
and modifying an argument.
</p>
</div>

<p>
Go的一个不寻常的特性就是函数和方法可返回多个值。这种形式可用于改善C程序中一对笨拙的习惯：
带内错误返回（例如用 <code>-1</code> 代表 <code>EOF</code>）以及修改实参。
</p>

<div class="english">
<p>
In C, a write error is signaled by a negative count with the
error code secreted away in a volatile location.
In Go, <code>Write</code>
can return a count <i>and</i> an error: &ldquo;Yes, you wrote some
bytes but not all of them because you filled the device&rdquo;.
The signature of <code>File.Write</code> in package <code>os</code> is:
</p>
</div>

<p>
In C, a write error is signaled by a negative count with the
error code secreted away in a volatile location.
在C中，写入操作的错误通过一个负数进行标记，该错误代码隐藏在一个不确定的位置。
在Go中，<code>Write</code> 可以返回一个计数<i>和</i>一个错误：
“是的，您写入了一些字节，但并没有全部写入，因为设备已满”。
在 <code>os</code> 包中，<code>File.Write</code> 的签名为：
</p>

<pre>
func (file *File) Write(b []byte) (n int, err error)
</pre>

<div class="english">
<p>
and as the documentation says, it returns the number of bytes
written and a non-nil <code>error</code> when <code>n</code>
<code>!=</code> <code>len(b)</code>.
This is a common style; see the section on error handling for more examples.
</p>
</div>

<p>
如文档所述，当 <code>n</code> <code>!=</code> <code>len(b)</code>
时，它返回被写入的字节数与一个非nil的 <code>error</code>。这是一种常用的方式，
更多示例见错误处理一节。
</p>

<div class="english">
<p>
A similar approach obviates the need to pass a pointer to a return
value to simulate a reference parameter.
Here's a simple-minded function to
grab a number from a position in a byte array, returning the number
and the next position.
</p>
</div>

<p>
类似的方法无需再将一个指针传至返回值来模拟引用形参。
以下简单的函数可从字节数组中的特定位置获取一个数，它返回该数值和下一个位置。
</p>

<pre>
func nextInt(b []byte, i int) (int, int) {
    for ; i &lt; len(b) &amp;&amp; !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i &lt; len(b) &amp;&amp; isDigit(b[i]); i++ {
        x = x*10 + int(b[i])-'0'
    }
    return x, i
}
</pre>

<div class="english">
<p>
You could use it to scan the numbers in an input array <code>a</code> like this:
</p>
</div>

<p>
你可以使用它从一个输入的数组 <code>a</code> 中扫描获取数字，就像这样：
</p>

<pre>
    for i := 0; i &lt; len(a); {
        x, i = nextInt(a, i)
        fmt.Println(x)
    }
</pre>

<div class="english">
<h3 id="named-results">Named result parameters</h3>
</div>

<h3 id="带名称结果">带名称的结果形参</h3>

<div class="english">
<p>
The return or result "parameters" of a Go function can be given names and
used as regular variables, just like the incoming parameters.
When named, they are initialized to the zero values for their types when
the function begins; if the function executes a <code>return</code> statement
with no arguments, the current values of the result parameters are
used as the returned values.
</p>
</div>

<p>
Go函数的返回值或结果“形参”可给定名称并像常规变量那样使用，就像输入的参数那样。
命名后，一旦该函数开始执行，它们就会被初始化为对应其类型的零值，若该函数执行了
不带实参的 <code>return</code> 语句，则结果形参的当前值将作为返回值返回。
</p>

<div class="english">
<p>
The names are not mandatory but they can make code shorter and clearer:
they're documentation.
If we name the results of <code>nextInt</code> it becomes
obvious which returned <code>int</code>
is which.
</p>
</div>

<p>
此名称不是强制的，但它们能使代码更加简短而清晰：它们就是文档。如果我们命名了
<code>nextInt</code> 的返回值，各个返回的 <code>int</code> 是什么意思就显而易见了。
</p>

<pre>
func nextInt(b []byte, pos int) (value, nextPos int) {
</pre>

<div class="english">
<p>
Because named results are initialized and tied to an unadorned return, they can simplify
as well as clarify.  Here's a version
of <code>io.ReadFull</code> that uses them well:
</p>
</div>

<p>
由于被命名的结果已经初始化，且已关联至一个无参数的返回，它们就可以简化并清晰化代码。
这里的 <code>io.ReadFull</code> 就是使用它们的一个很好的例子。
</p>

<pre>
func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) &gt; 0 &amp;&amp; err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
</pre>

<div class="english">
<h3 id="defer">Defer</h3>
</div>

<h3 id="推迟">推迟</h3>

<div class="english">
<p>
Go's <code>defer</code> statement schedules a function call (the
<i>deferred</i> function) to be run immediately before the function
executing the <code>defer</code> returns.  It's an unusual but
effective way to deal with situations such as resources that must be
released regardless of which path a function takes to return.  The
canonical examples are unlocking a mutex or closing a file.
</p>
</div>

<p>
Go的 <code>defer</code> 语句用于预设一个函数调用（<i>推迟执行</i>的函数），
该函数会在函数执行 <code>defer</code> 返回之前立即执行。它显得不同常规，
但却是处理一些情况的有效方式，例如无论怎样返回，都必须对其进行资源释放的函数。
典型的例子就是解锁一个互斥或关闭一个文件。
</p>

<div class="english">
<pre>
// Contents returns the file's contents as a string.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close will run when we're finished.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append is discussed later.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f will be closed if we return here.
        }
    }
    return string(result), nil // f will be closed if we return here.
}
</pre>
</div>

<pre>
// Contents将文件的内容作为字符串返回。
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close会在我们结束后运行。

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append将在后面讨论。
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // 我们在此返回后，f就会被关闭。
        }
    }
    return string(result), nil // 我们在此返回后，f就会被关闭。
}
</pre>

<div class="english">
<p>
Deferring a call to a function such as <code>Close</code> has two advantages.  First, it
guarantees that you will never forget to close the file, a mistake
that's easy to make if you later edit the function to add a new return
path.  Second, it means that the close sits near the open,
which is much clearer than placing it at the end of the function.
</p>
</div>

<p>
对于像 <code>Close</code> 这种函数的推迟调用有两个优点。其一，它能确保你不会忘记关闭文件，
如果你以后编辑该函数来添加一个新的返回路径时，这种情况往往就会发生。其二，
它意味着关闭离打开很近，这要比将关闭放在函数结尾处更为清楚明了。
</p>

<div class="english">
<p>
The arguments to the deferred function (which include the receiver if
the function is a method) are evaluated when the <i>defer</i>
executes, not when the <i>call</i> executes.  Besides avoiding worries
about variables changing values as the function executes, this means
that a single deferred call site can defer multiple function
executions.  Here's a silly example.
</p>
</div>

<p>
被推迟函数的实参（如果该函数为方法则还包括接收者）在<i>延期</i>执行时就会求值，
而不是在<i>调用</i>执行时才求值。这样不仅无需担心变量值在函数执行时被改变，
同时也意味着单个已推迟的调用可推迟多个函数的执行。下面是个简单的例子。
</p>

<pre>
for i := 0; i &lt; 5; i++ {
    defer fmt.Printf("%d ", i)
}
</pre>

<div class="english">
<p>
Deferred functions are executed in LIFO order, so this code will cause
<code>4 3 2 1 0</code> to be printed when the function returns.  A
more plausible example is a simple way to trace function execution
through the program.  We could write a couple of simple tracing
routines like this:
</p>
</div>

<p>
被推迟的函数按照后进先出（LIFO）的顺序执行，因此以上代码在函数返回时会打印
<code>4 3 2 1 0</code>。一个更合理的例子是用一种简单的方法通过程序来跟踪函数的执行。
我们可以编写一对简单的跟踪例程，就像这样：
</p>

<div class="english">
<pre>
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// Use them like this:
func a() {
    trace("a")
    defer untrace("a")
    // do something....
}
</pre>
</div>

<pre>
func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// 像这样使用它们：
func a() {
    trace("a")
    defer untrace("a")
    // 做一些事情....
}
</pre>

<div class="english">
<p>
We can do better by exploiting the fact that arguments to deferred
functions are evaluated when the <code>defer</code> executes.  The
tracing routine can set up the argument to the untracing routine.
This example:
</p>
</div>

<p>
我们可以通过利用被推迟函数的实参在 <code>defer</code> 执行时求值的特点做得更好。
跟踪例程可针对反跟踪例程建立实参。以下程序：
</p>

<pre>
func trace(s string) string {
    fmt.Println("entering:", s)
    return s
}

func un(s string) {
    fmt.Println("leaving:", s)
}

func a() {
    defer un(trace("a"))
    fmt.Println("in a")
}

func b() {
    defer un(trace("b"))
    fmt.Println("in b")
    a()
}

func main() {
    b()
}
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
会打印
</p>

<pre>
entering: b
in b
entering: a
in a
leaving: a
leaving: b
</pre>

<div class="english">
<p>
For programmers accustomed to block-level resource management from
other languages, <code>defer</code> may seem peculiar, but its most
interesting and powerful applications come precisely from the fact
that it's not block-based but function-based.  In the section on
<code>panic</code> and <code>recover</code> we'll see another
example of its possibilities.
</p>
</div>

<p>
对于习惯其它语言中块级资源管理的程序员，<code>defer</code> 似乎有点怪异，
但它最有趣和强大的应用恰恰来自于其基于函数而非基于块的特点。在 <code>panic</code>
和 <code>recover</code> 两节中我们将看到它另一种应用的例子。
</p>

<div class="english">
<h2 id="data">Data</h2>
</div>

<h2 id="数据">数据</h2>

<div class="english">
<h3 id="allocation_new">Allocation with <code>new</code></h3>
</div>

<h3 id="new分配">使用 <code>new</code> 分配内存</h3>

<div class="english">
<p>
Go has two allocation primitives, the built-in functions
<code>new</code> and <code>make</code>.
They do different things and apply to different types, which can be confusing,
but the rules are simple.
Let's talk about <code>new</code> first.
It's a built-in function that allocates memory, but unlike its namesakes
in some other languages it does not <em>initialize</em> the memory,
it only <em>zeros</em> it.
That is,
<code>new(T)</code> allocates zeroed storage for a new item of type
<code>T</code> and returns its address, a value of type <code>*T</code>.
In Go terminology, it returns a pointer to a newly allocated zero value of type
<code>T</code>.
</p>
</div>

<p>
Go有两种内存分配原语，即内建函数 <code>new</code> 和 <code>make</code>。
它们所做的事情不同，所应用到的类型也不同，这可能引起混淆，但规则却很简单。
让我们先讨论 <code>new</code>。它是一个用来分配内存的函数，但不像其它语言中同名的操作，
它不会<em>初始化</em>内存，只会将内存<em>清零</em>。<code>new(T)</code>
会为一个类型为 <code>T</code> 的新条目分配已清零的存储空间并返回其地址，
也就是一个类型为 <code>*T</code> 的值。用Go的术语来说，它返回一个指向类型为
<code>T</code> 的新分配零值的指针。
</p>

<div class="english">
<p>
Since the memory returned by <code>new</code> is zeroed, it's helpful to arrange
when designing your data structures that the
zero value of each type can be used without further initialization.  This means a user of
the data structure can create one with <code>new</code> and get right to
work.
For example, the documentation for <code>bytes.Buffer</code> states that
"the zero value for <code>Buffer</code> is an empty buffer ready to use."
Similarly, <code>sync.Mutex</code> does not
have an explicit constructor or <code>Init</code> method.
Instead, the zero value for a <code>sync.Mutex</code>
is defined to be an unlocked mutex.
</p>
</div>

<p>
由于通过 <code>new</code> 返回的内存已清零，这样就更便于设计你的数据结构，
因为每个类型的零值不必进一步初始化就可以使用。这意味着该数据结构的使用者只需用
<code>new</code> 创建一个新的就能正确工作。例如，<code>bytes.Buffer</code>
的文档这样表述：“零值的 <code>Buffer</code> 为已准备就绪的缓存器。”
同样，<code>sync.Mutex</code> 并没有显式的构造器或 <code>Init</code> 方法，
不过零值的 <code>sync.Mutex</code> 已经被定义为解锁的互斥了。
</p>

<div class="english">
<p>
The zero-value-is-useful property works transitively. Consider this type declaration.
</p>
</div>

<p>
零值属性是可以传递的。考虑以下类型声明。
</p>

<pre>
type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
</pre>

<div class="english">
<p>
Values of type <code>SyncedBuffer</code> are also ready to use immediately upon allocation
or just declaration.  In the next snippet, both <code>p</code> and <code>v</code> will work
correctly without further arrangement.
</p>
</div>

<p>
类型为 <code>SyncedBuffer</code> 的值也是在声明时就分配好内存并准备就绪了。
在下一个程序片段中，<code>p</code> 和 <code>v</code> 无需进一步处理就可以正确地工作。
</p>

<pre>
p := new(SyncedBuffer)  // type *SyncedBuffer
var v SyncedBuffer      // type  SyncedBuffer
</pre>

<div class="english">
<h3 id="composite_literals">Constructors and composite literals</h3>
</div>

<h3 id="复合字面">构造器与复合字面</h3>

<div class="english">
<p>
Sometimes the zero value isn't good enough and an initializing
constructor is necessary, as in this example derived from
package <code>os</code>.
</p>
</div>

<p>
有时零值并不够好，这时就需要一个初始化构造器，如来自包 <code>os</code> 中的这段代码所示。
</p>

<pre>
func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
</pre>

<div class="english">
<p>
There's a lot of boiler plate in there.  We can simplify it
using a <i>composite literal</i>, which is
an expression that creates a
new instance each time it is evaluated.
</p>
</div>

<p>
这里有很多类似的语句。我们可以使用<i>复合字面</i>来对其进行简化，
这是一个在每次求值时都创建一个新实例的表达式。
</p>

<pre>
func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &amp;f
}
</pre>

<div class="english">
<p>
Note that, unlike in C, it's perfectly OK to return the address of a local variable;
the storage associated with the variable survives after the function
returns.
In fact, taking the address of a composite literal
allocates a fresh instance each time it is evaluated,
so we can combine these last two lines.
</p>
</div>

<p>
请注意，返回一个局部变量的地址完全没有问题，这点与C不同，与此变量对应的存储在函数返回后仍然存在。
实际上，每当获取一个复合字面的地址时，都将为一个新的实例分配内存，
因此我们可以将上面的最后两行代码合并。
</p>

<pre>
    return &amp;File{fd, name, nil, 0}
</pre>

<div class="english">
<p>
The fields of a composite literal are laid out in order and must all be present.
However, by labeling the elements explicitly as <i>field</i><code>:</code><i>value</i>
pairs, the initializers can appear in any
order, with the missing ones left as their respective zero values.  Thus we could say
</p>
</div>

<p>
复合字面的字段必须按顺序全部列出。但如果以 <i>字段</i><code>:</code><i>值</i>
对的形式显式地标出元素，初始化器就可以按任何顺序出现，未给出的字段值则为零值。
因此，我们可以用如下形式：
</p>
<pre>
    return &amp;File{fd: fd, name: name}
</pre>

<div class="english">
<p>
As a limiting case, if a composite literal contains no fields at all, it creates
a zero value for the type.  The expressions <code>new(File)</code> and <code>&amp;File{}</code> are equivalent.
</p>
</div>

<p>
少数情况下，若复合字面不包括任何字段，它将创建该类型的零值。表达式
<code>new(File)</code> 和 <code>&amp;File{}</code> 是等价的。
</p>

<div class="english">
<p>
Composite literals can also be created for arrays, slices, and maps,
with the field labels being indices or map keys as appropriate.
In these examples, the initializations work regardless of the values of <code>Enone</code>,
<code>Eio</code>, and <code>Einval</code>, as long as they are distinct.
</p>
</div>

<p>
复合字面同样可用于创建数组、切片和映射，映射的字段标签是索引还是映射键则视情况而定。
在下面例字的初始化过程中，不管 <code>Enone</code>、<code>Eio</code> 和 <code>Einval</code>
的值是什么，只要它们的标签不同就行。
</p>

<pre>
a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
</pre>

<div class="english">
<h3 id="allocation_make">Allocation with <code>make</code></h3>
</div>

<h3 id="make分配">使用 <code>make</code> 分配内存</h3>

<div class="english">
<p>
Back to allocation.
The built-in function <code>make(T, </code><i>args</i><code>)</code> serves
a purpose different from <code>new(T)</code>.
It creates slices, maps, and channels only, and it returns an <em>initialized</em>
(not <em>zeroed</em>)
value of type <code>T</code> (not <code>*T</code>).
The reason for the distinction
is that these three types are, under the covers, references to data structures that
must be initialized before use.
A slice, for example, is a three-item descriptor
containing a pointer to the data (inside an array), the length, and the
capacity, and until those items are initialized, the slice is <code>nil</code>.
For slices, maps, and channels,
<code>make</code> initializes the internal data structure and prepares
the value for use.
For instance,
</p>
</div>

<p>
再回到内存分配上来。内建函数 <code>make(T, </code><i>args</i><code>)</code>
的目的不同于 <code>new(T)</code>。它只用于创建切片、映射和信道，并返回类型为
<code>T</code>（而非 <code>*T</code>）的一个<em>已初始化</em> （而非<em>清零</em>）的值。
出现这种用差异的原因是由于这三种类型本质上为引用数据类型，它们在使用前必须初始化。
例如，切片是一个具有三项内容的描述符，包含一个指向（数组内部）数据的指针、长度以及容量，
在这三项被初始化之前，该切片为 <code>nil</code>。对于切片、映射和信道，<code>make</code>
用于初始化其内部的数据结构并准备好将要使用的值。例如，
</p>

<pre>
make([]int, 10, 100)
</pre>

<div class="english">
<p>
allocates an array of 100 ints and then creates a slice
structure with length 10 and a capacity of 100 pointing at the first
10 elements of the array.
(When making a slice, the capacity can be omitted; see the section on slices
for more information.)
In contrast, <code>new([]int)</code> returns a pointer to a newly allocated, zeroed slice
structure, that is, a pointer to a <code>nil</code> slice value.
</p>
</div>

<p>
会分配一个具有100个 <code>int</code> 的数组，接着创建一个长度为10，
容量为100并指向该数组中前10个元素的切片构造。（生成切片时，其容量可以省略，更多信息见切片一节。）
与此相反，<code>new([]int)</code> 会返回一个指向新分配的，已清零的切片构造，
即一个指向 <code>nil</code> 切片值的指针。returns a pointer to a newly allocated, zeroed slice
structure, that is, a pointer to a <code>nil</code> slice value.
</p>

<div class="english">
<p>
These examples illustrate the difference between <code>new</code> and
<code>make</code>.
</p>
</div>

<p>
下面的例子阐明了 <code>new</code> 与 <code>make</code> 之间的不同。
</p>

<div class="english">
<pre>
var p *[]int = new([]int)       // allocates slice structure; *p == nil; rarely useful
var v  []int = make([]int, 100) // the slice v now refers to a new array of 100 ints

// Unnecessarily complex:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Idiomatic:
v := make([]int, 100)
</pre>
</div>

<pre>
var p *[]int = new([]int)       // 分配切片构造；*p == nil；基本没用
var v  []int = make([]int, 100) // 切片v现在引用了一个具有100个int元素的新数组

// 不必要地使问题复杂化：
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// 习惯用法：
v := make([]int, 100)
</pre>

<div class="english">
<p>
Remember that <code>make</code> applies only to maps, slices and channels
and does not return a pointer.
To obtain an explicit pointer allocate with <code>new</code>.
</p>
</div>

<p>
请记住，<code>make</code> 只适用于映射、切片和信道且不返回指针。要获得一个明确的指针，
请使用 <code>new</code> 分配内存。
</p>

<div class="english">
<h3 id="arrays">Arrays</h3>
</div>

<h3 id="数组">数组</h3>

<div class="english">
<p>
Arrays are useful when planning the detailed layout of memory and sometimes
can help avoid allocation, but primarily
they are a building block for slices, the subject of the next section.
To lay the foundation for that topic, here are a few words about arrays.
</p>
</div>

<p>
在详细规划内存布局时，数组是非常有用的，有时可帮助避免内存分配，但它们主要用作切片的构件，
这将是下一节的主题。作为对该主题的一个铺垫，这里先对数组说上几句。
</p>

<div class="english">
<p>
There are major differences between the ways arrays work in Go and C.
In Go,
</p>
<ul>
<li>
Arrays are values. Assigning one array to another copies all the elements.
</li>
<li>
In particular, if you pass an array to a function, it
will receive a <i>copy</i> of the array, not a pointer to it.
<li>
The size of an array is part of its type.  The types <code>[10]int</code>
and <code>[20]int</code> are distinct.
</li>
</ul>
</div>

<p>
以下为在Go和C中的数组的主要区别，在Go中，
</p>
<ul>
<li>
数组是值。将一个数组赋予另一个数组将复制其所有元素。
</li>
<li>
特别地，如果你将一个数组传递给一个函数，它将接收到该数组的一个<i>副本</i>，
而不是指向它的指针。
<li>
数组的大小是其类型的一部分。类型 <code>[10]int</code> 和 <code>[20]int</code> 是不同的。
</li>
</ul>

<div class="english">
<p>
The value property can be useful but also expensive; if you want C-like behavior and efficiency,
you can pass a pointer to the array.
</p>
</div>

<p>
数组为值的属性很有用，但代价高昂；如果你想要类似于C的行为和效率，你可以传递一个指向该数组的指针。
</p>

<div class="english">
<pre>
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&amp;array)  // Note the explicit address-of operator
</pre>

<p>
But even this style isn't idiomatic Go.  Slices are.
</p>
</div>

<pre>
func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&amp;array)  // 注意显式的取址操作
</pre>

<div class="english">
<p>
But even this style isn't idiomatic Go.  Slices are.
</p>
</div>

<p>
但这并不是Go的习惯用法，切片才是。
</p>

<div class="english">
<h3 id="slices">Slices</h3>
</div>

<h3 id="切片">切片</h3>

<div class="english">
<p>
Slices wrap arrays to give a more general, powerful, and convenient
interface to sequences of data.  Except for items with explicit
dimension such as transformation matrices, most array programming in
Go is done with slices rather than simple arrays.
</p>
</div>

<p>
切片通过包装数组对数据序列提供了一个更通用、强大和方便的界面。
除了像矩阵变换这种需要明确尺寸的情况外，Go中的数组编程是通过切片而非简单的数组完成的。
</p>

<div class="english">
<p>
Slices are <i>reference types</i>, which means that if you assign one
slice to another, both refer to the same underlying array.  For
instance, if a function takes a slice argument, changes it makes to
the elements of the slice will be visible to the caller, analogous to
passing a pointer to the underlying array.  A <code>Read</code>
function can therefore accept a slice argument rather than a pointer
and a count; the length within the slice sets an upper
limit of how much data to read.  Here is the signature of the
<code>Read</code> method of the <code>File</code> type in package
<code>os</code>:
</p>
</div>

<p>
切片是<i>引用类型</i>，这意味着如果你将一个切片赋予另外一个，这两个切片将引用同一个基本数组。
例如，若一个函数获取了一个切片实参，它对切片元素的修改对于调用者来说是可见的。
类似于传递一个指向其基本数组的指针。因此，<code>Read</code> 函数可接受一个切片实参而非指针或计数；
切片的决定了可读取数据的上限。以下为 <code>os</code> 包中 <code>File</code>
类型的 <code>Read</code> 方法签名：
</p>

<pre>
func (file *File) Read(buf []byte) (n int, err error)
</pre>

<div class="english">
<p>
The method returns the number of bytes read and an error value, if
any.  To read into the first 32 bytes of a larger buffer
<code>b</code>, <i>slice</i> (here used as a verb) the buffer.
</p>
</div>

<p>
该方法返回读取的字节数和一个错误值（若有的话）。要读入一个大型缓存器 <code>b</code>
的前32个字节，只需<i>切分</i>该缓冲区即可。
</p>

<pre>
    n, err := f.Read(buf[0:32])
</pre>

<div class="english">
<p>
Such slicing is common and efficient.  In fact, leaving efficiency aside for
the moment, the following snippet would also read the first 32 bytes of the buffer.
</p>
</div>

<p>
这种切分的方法常用且高效。实际上，暂不考虑效率问题，一下片段同样可读取该缓存器的前32个字节。
</p>

<div class="english">
<pre>
    var n int
    var err error
    for i := 0; i &lt; 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // Read one byte.
        if nbytes == 0 || e != nil {
            err = e
            break
        }
        n += nbytes
    }
</pre>
</div>

<pre>
    var n int
    var err error
    for i := 0; i &lt; 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // 读取一个字节。
        if nbytes == 0 || e != nil {
            err = e
            break
        }
        n += nbytes
    }
</pre>

<div class="english">
<p>
The length of a slice may be changed as long as it still fits within
the limits of the underlying array; just assign it to a slice of
itself.  The <i>capacity</i> of a slice, accessible by the built-in
function <code>cap</code>, reports the maximum length the slice may
assume.  Here is a function to append data to a slice.  If the data
exceeds the capacity, the slice is reallocated.  The
resulting slice is returned.  The function uses the fact that
<code>len</code> and <code>cap</code> are legal when applied to the
<code>nil</code> slice, and return 0.
</p>
</div>

<p>
切片的长度是可改变的，只要它不超出其基本数组的长度极限；只需将该数组的一个切片赋予它便可。
切片的<i>容量</i>可通过内建函数 <code>cap</code> 访问，它将给出该切片可被赋予的最大长度。
以下是为切片追加数据的函数。若数据超出容量其，则会重新分配该切片。返回值即为所得的切片。
该函数中所使用的 <code>len</code> 和 <code>cap</code> 在应用于 <code>nil</code>
切片时是合法的，它会返回0.
</p>

<div class="english">
<pre>
func Append(slice, data[]byte) []byte {
    l := len(slice)
    if l + len(data) &gt; cap(slice) {  // reallocate
        // Allocate double what's needed, for future growth.
        newSlice := make([]byte, (l+len(data))*2)
        // The copy function is predeclared and works for any slice type.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    for i, c := range data {
        slice[l+i] = c
    }
    return slice
}
</pre>
</div>

<pre>
func Append(slice, data[]byte) []byte {
    l := len(slice)
    if l + len(data) &gt; cap(slice) {  // 重新分配
        // 为后面需要的增长分配两份。
        newSlice := make([]byte, (l+len(data))*2)
        //  copy函数是预声明的，且可工作于任何切片类型。
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    for i, c := range data {
        slice[l+i] = c
    }
    return slice
}
</pre>

<div class="english">
<p>
We must return the slice afterwards because, although <code>Append</code>
can modify the elements of <code>slice</code>, the slice itself (the run-time data
structure holding the pointer, length, and capacity) is passed by value.
</p>
</div>

<p>
我们必须在最后返回切片，这是因为尽管 <code>Append</code> 可修改 <code>slice</code>
的元素，但切片自身（其运行时数据结构包含指针、长度和容量）是通过值传递的。
</p>

<div class="english">
<p>
The idea of appending to a slice is so useful it's captured by the
<code>append</code> built-in function.  To understand that function's
design, though, we need a little more information, so we'll return
to it later.
</p>
</div>

<p>
为切片追加东西的想法非常有用，因此有一个专门的内建函数 <code>append</code>。
要理解该函数的设计，我们还需要更多一点的信息，我们将稍后再介绍它。
</p>


<div class="english">
<h3 id="maps">Maps</h3>
</div>

<h3 id="映射">映射</h3>

<div class="english">
<p>
Maps are a convenient and powerful built-in data structure to associate
values of different types.
The key can be of any type for which the equality operator is defined,
such as integers,
floating point and complex numbers,
strings, pointers, interfaces (as long as the dynamic type
supports equality), structs and arrays. Slices cannot be used as map keys,
because equality is not defined on them.
Like slices, maps are a reference type. If you pass a map to a function
that changes the contents of the map, the changes will be visible
in the caller.
</p>
</div>

<p>
映射是方便而强大的内建数据结构，它可以关联不同类型的值。其键可以是任意的已定义了相等性操作符的类型，
如整数、浮点数和复数、字符串、指针、接口（只要其动态类型支持相等性）、结构以及数组。
切片不能用作映射键，因为它们的相等性还未定义。就像切片一样，映射也是引用类型。
若你将一个映射传递给函数，并更改了该映射的内容，则此修改对于调用者来说是可见的。
</p>

<div class="english">
<p>
Maps can be constructed using the usual composite literal syntax
with colon-separated key-value pairs,
so it's easy to build them during initialization.
</p>
</div>

<p>
映射可使用通常的复合字面语法进行构建，其键-值对使用逗号分隔，因此可在初始化时来构建它们
</p>

<pre>
var timeZone = map[string] int {
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
</pre>

<div class="english">
<p>
Assigning and fetching map values looks syntactically just like
doing the same for arrays except that the index doesn't need to
be an integer.
</p>
</div>

<p>
赋值和获取映射值的语法类似于数组，不同的是映射的索引不必为整数。
</p>

<pre>
offset := timeZone["EST"]
</pre>

<div class="english">
<p>
An attempt to fetch a map value with a key that
is not present in the map will return the zero value for the type
of the entries
in the map.  For instance, if the map contains integers, looking
up a non-existent key will return <code>0</code>.
A set can be implemented as a map with value type <code>bool</code>.
Set the map entry to <code>true</code> to put the value in the set, and then
test it by simple indexing.
</p>
</div>

<p>
如果试图使用一个不存在的键来获取映射值，就会返回在该映射对应该条目类型的零值。
例如，若映射包含整数，查找一个不存在的键将返回 <code>0</code>。一个集合可使用一个值类型为
<code>bool</code> 的映射来实现。通过将该映射中的条目置为 <code>true</code>
来将值放入集合中，然后通过简单的索引对齐进行测试。
</p>

<div class="english">
<pre>
attended := map[string] bool {
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // will be false if person is not in the map
    fmt.Println(person, "was at the meeting")
}
</pre>
</div>

<pre>
attended := map[string] bool {
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // 若人不在该映射中，则为false
    fmt.Println(person, "was at the meeting")
}
</pre>

<div class="english">
<p>
Sometimes you need to distinguish a missing entry from
a zero value.  Is there an entry for <code>"UTC"</code>
or is that zero value because it's not in the map at all?
You can discriminate with a form of multiple assignment.
</p>
</div>

<p>
有时你需要从零值中区分出不存在的条目。如对于一个值本应为零的 <code>"UTC"</code>
条目，也可能是由于不存在该项而得到零值。你可以使用多重赋值的形式来分辨这种情况。
</p>

<pre>
var seconds int
var ok bool
seconds, ok = timeZone[tz]
</pre>

<div class="english">
<p>
For obvious reasons this is called the &ldquo;comma ok&rdquo; idiom.
In this example, if <code>tz</code> is present, <code>seconds</code>
will be set appropriately and <code>ok</code> will be true; if not,
<code>seconds</code> will be set to zero and <code>ok</code> will
be false.
Here's a function that puts it together with a nice error report:
</p>
</div>

<p>
显然这种习惯的用法可称作“逗号ok”。在下面的例子中，若 <code>tz</code> 存在，
<code>seconds</code> 就会被恰当地设置，而 <code>ok</code> 将为 <code>true</code>；
若不存在，<code>seconds</code> 将会被置为零，而 <code>ok</code> 将为 <code>false</code>。
</p>

<pre>
func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
}
</pre>

<div class="english">
<p>
To test for presence in the map without worrying about the actual value,
you can use the blank identifier (<code>_</code>).
The blank identifier can be assigned or declared with any value of any type, with the
value discarded harmlessly.  For testing just presence in a map, use the blank
identifier in place of the usual variable for the value.
</p>
</div>

<p>
若只需测试映射中是否存在某项而不关心实际的值，可使用空白标识符（<code>_</code>）。
空白标识符可被赋予或声明任意类型的任意值，这样的值将被丢弃，且并不产生任何问题。
对于只是测试某项是否在映射中而言，可将原本存储值的变量替换为空白标识符。
</p>

<pre>
_, present := timeZone[tz]
</pre>

<div class="english">
<p>
To delete a map entry, use the <code>delete</code>
built-in function, whose arguments are the map and the key to be deleted.
It's safe to do this this even if the key is already absent
from the map.
</p>
</div>

<p>
要删除映射中的一项，可使用内建函数 <code>delete</code>，其实参为该映射以及要被删除的键。
即便对应的键不在该映射中，此操作也是安全的。
</p>

<div class="english">
<pre>
delete(timeZone, "PDT")  // Now on Standard Time
</pre>
</div>

<pre>
delete(timeZone, "PDT")  // 现在是标准时间
</pre>

<div class="english">
<h3 id="printing">Printing</h3>
</div>

<h3 id="打印">打印</h3>

<div class="english">
<p>
Formatted printing in Go uses a style similar to C's <code>printf</code>
family but is richer and more general. The functions live in the <code>fmt</code>
package and have capitalized names: <code>fmt.Printf</code>, <code>fmt.Fprintf</code>,
<code>fmt.Sprintf</code> and so on.  The string functions (<code>Sprintf</code> etc.)
return a string rather than filling in a provided buffer.
</p>
</div>

<p>
Go中格式化打印的风格类似于C的 <code>printf</code> 家族，但却更加丰富和通用。
这些函数位于 <code>fmt</code> 包中，且函数名以答谢字母开头：如
<code>fmt.Printf</code>、<code>fmt.Fprintf</code>，<code>fmt.Sprintf</code> 等。
字符串函数（<code>Sprintf</code> 等）并不是填充一个给定的缓存区，而是返回一个字符串。
</p>

<div class="english">
<p>
You don't need to provide a format string.  For each of <code>Printf</code>,
<code>Fprintf</code> and <code>Sprintf</code> there is another pair
of functions, for instance <code>Print</code> and <code>Println</code>.
These functions do not take a format string but instead generate a default
format for each argument. The <code>Println</code> versions also insert a blank
between arguments and append a newline to the output while
the <code>Print</code> versions add blanks only if the operand on neither side is a string.
In this example each line produces the same output.
</p>
</div>

<p>
你无须提供一个格式字符串。每个 <code>Printf</code>、<code>Fprintf</code> 和
<code>Sprintf</code> 都分别对应另外对函数，如 <code>Print</code> 与 <code>Println</code>。
这些函数并不接受格式字符串，而是为每个实参生成一种么人格式。<code>Println</code>
的版本还会在实参中插入一个空白并在输出时追加一个换行符，而 <code>Print</code>
版本仅在操作数两遍都没有字符串时才添加空白。以下示例中各行产生的输出都是一样的。
</p>

<pre>
fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
</pre>

<div class="english">
<p>
As mentioned in
the <a href="http://tour.golang.org">Tour</a>, <code>fmt.Fprint</code>
and friends take as a first argument any object
that implements the <code>io.Writer</code> interface; the variables <code>os.Stdout</code>
and <code>os.Stderr</code> are familiar instances.
</p>
</div>

<p>
正如<a href="http://tour.golang.org">Go语言之旅</a>中所说，<code>fmt.Fprint</code>
一类的函数可接受任何实现了 <code>io.Writer</code> 接口的对象作为第一个实参；变量
<code>os.Stdout</code> 与 <code>os.Stderr</code> 都是大家熟知的例子。
</p>

<div class="english">
<p>
Here things start to diverge from C.  First, the numeric formats such as <code>%d</code>
do not take flags for signedness or size; instead, the printing routines use the
type of the argument to decide these properties.
</p>
</div>

<p>
这里与C还有些不同。首先，像 <code>%d</code> 这样的数值格式并不接受表示符号或大小的标记，
打印例程会根据实参的类型来决定这些属性。
</p>

<pre>
var x uint64 = 1&lt;&lt;64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
将打印
</p>

<pre>
18446744073709551615 ffffffffffffffff; -1 -1
</pre>

<div class="english">
<p>
If you just want the default conversion, such as decimal for integers, you can use
the catchall format <code>%v</code> (for &ldquo;value&rdquo;); the result is exactly
what <code>Print</code> and <code>Println</code> would produce.
Moreover, that format can print <em>any</em> value, even arrays, structs, and
maps.  Here is a print statement for the time zone map defined in the previous section.
</p>
</div>

<p>
如果你只想要默认的转换，如使用十进制的整数，你可以使用通用的格式
<code>%v</code>（对应“值”）；其结果与 <code>Print</code> 和 <code>Println</code>
产生的输出时完全一样的。此外，这种格式可打印<em>任意</em>值，甚至包括数组、结构和映射。
以下是针对上一节中定义的时区映射的打印语句。
</p>

<div class="english">
<pre>
fmt.Printf("%v\n", timeZone)  // or just fmt.Println(timeZone)
</pre>
</div>

<pre>
fmt.Printf("%v\n", timeZone)  // 或只用 fmt.Println(timeZone)
</pre>

<div class="english">
<p>
which gives output
</p>
</div>

<p>
这会输出
</p>

<pre>
map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]
</pre>

<div class="english">
<p>
For maps the keys may be output in any order, of course.
When printing a struct, the modified format <code>%+v</code> annotates the
fields of the structure with their names, and for any value the alternate
format <code>%#v</code> prints the value in full Go syntax.
</p>
</div>

<p>
当然，映射中的键可能按任意顺序输出。当打印一个结构时，改进的格式 <code>%+v</code>
将使用字段的名称来注解该结构的字段，而另外一个格式将完全按照Go的语法打印任意值。
</p>

<pre>
type T struct {
    a int
    b float64
    c string
}
t := &amp;T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
将打印
</p>

<pre>
&amp;{7 -2.35 abc   def}
&amp;{a:7 b:-2.35 c:abc     def}
&amp;main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string] int{"CST":-21600, "PST":-28800, "EST":-18000, "UTC":0, "MST":-25200}
</pre>

<div class="english">
<p>
(Note the ampersands.)
That quoted string format is also available through <code>%q</code> when
applied to a value of type <code>string</code> or <code>[]byte</code>;
the alternate format <code>%#q</code> will use backquotes instead if possible.
Also, <code>%x</code> works on strings and arrays of bytes as well as on integers,
generating a long hexadecimal string, and with
a space in the format (<code>%&nbsp;x</code>) it puts spaces between the bytes.
</p>
</div>

<p>
（请注意其中的&amp;符号）当遇到 <code>string</code> 或 <code>[]byte</code> 值时，
可使用 <code>%q</code> 产生带引号的字符串；而格式 <code>%#q</code> 将尽可能使用反引号。
另外，<code>%x</code> 还可用于字符串、字节数组以及整数，并生成一个很长的十六进制字符串，
而带空格的格式（<code>%&nbsp;x</code>）还会在字节之间插入空格。
</p>

<div class="english">
<p>
Another handy format is <code>%T</code>, which prints the <em>type</em> of a value.
</p>
</div>

<p>
另一个方便的格式是 <code>%T</code>，它会打印一个值的<em>类型</em>。
</p>

<pre>
fmt.Printf(&quot;%T\n&quot;, timeZone)
</pre>

<div class="english">
<p>
prints
</p>
</div>

<p>
将打印
</p>

<pre>
map[string] int
</pre>

<div class="english">
<p>
If you want to control the default format for a custom type, all that's required is to define
a method with the signature <code>String() string</code> on the type.
For our simple type <code>T</code>, that might look like this.
</p>
</div>

<p>
如果你想要控制一个自定义类型的默认格式，只需为此类型定义一个具有
<code>String() string</code> 签名的方法。对于我们简单的类型 <code>T</code>，
可进行如下操作。
</p>

<pre>
func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
</pre>

<div class="english">
<p>
to print in the format
</p>
</div>

<p>
它将以格式化的形式打印
</p>

<pre>
7/-2.35/"abc\tdef"
</pre>

<div class="english">
<p>
(If you need to print <em>values</em> of type <code>T</code> as well as pointers to <code>T</code>,
the receiver for <code>String</code> must be of value type; this example used a pointer because
that's more efficient and idiomatic for struct types.
See the section below on <a href="#pointers_vs_values">pointers vs. value receivers</a> for more information.)
</p>
</div>

<p>
（如果你需要像指向 <code>T</code> 的指针那样打印类型 <code>T</code> 的<em>值</em>，
<code>String</code> 的接收者就必须是值类型的；上面的例子中接收者是一个指针，
因为这对结构来说更高效和惯用。更多详情见<a href="#指针vs值">指针vs.值接收者</a>一节）
</p>

<p>
Our <code>String</code> method is able to call <code>Sprintf</code> because the
print routines are fully reentrant and can be used recursively.
We can even go one step further and pass a print routine's arguments directly to another such routine.
The signature of <code>Printf</code> uses the type <code>...interface{}</code>
for its final argument to specify that an arbitrary number of parameters (of arbitrary type)
can appear after the format.
</p>
<pre>
func Printf(format string, v ...interface{}) (n int, err error) {
</pre>
<p>
Within the function <code>Printf</code>, <code>v</code> acts like a variable of type
<code>[]interface{}</code> but if it is passed to another variadic function, it acts like
a regular list of arguments.
Here is the implementation of the
function <code>log.Println</code> we used above. It passes its arguments directly to
<code>fmt.Sprintln</code> for the actual formatting.
</p>
<pre>
// Println prints to the standard logger in the manner of fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Output takes parameters (int, string)
}
</pre>
<p>
We write <code>...</code> after <code>v</code> in the nested call to <code>Sprintln</code> to tell the
compiler to treat <code>v</code> as a list of arguments; otherwise it would just pass
<code>v</code> as a single slice argument.
<p>
There's even more to printing than we've covered here.  See the <code>godoc</code> documentation
for package <code>fmt</code> for the details.
</p>
<p>
By the way, a <code>...</code> parameter can be of a specific type, for instance <code>...int</code>
for a min function that chooses the least of a list of integers:
</p>
<pre>
func Min(a ...int) int {
    min := int(^uint(0) >> 1)  // largest int
    for _, i := range a {
        if i &lt; min {
            min = i
        }
    }
    return min
}
</pre>

<div class="english">
<h3 id="append">Append</h3>
</div>

<h3 id="追加">追加</h3>

<p>
Now we have the missing piece we needed to explain the design of
the <code>append</code> built-in function.  The signature of <code>append</code>
is different from our custom <code>Append</code> function above.
Schematically, it's like this:
</p>
<pre>
func append(slice []<i>T</i>, elements...T) []<i>T</i>
</pre>
<p>
where <i>T</i> is a placeholder for any given type.  You can't
actually write a function in Go where the type <code>T</code>
is determined by the caller.
That's why <code>append</code> is built in: it needs support from the
compiler.
</p>
<p>
What <code>append</code> does is append the elements to the end of
the slice and return the result.  The result needs to be returned
because, as with our hand-written <code>Append</code>, the underlying
array may change.  This simple example
</p>
<pre>
x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
</pre>
<p>
prints <code>[1 2 3 4 5 6]</code>.  So <code>append</code> works a
little like <code>Printf</code>, collecting an arbitrary number of
arguments.
</p>
<p>
But what if we wanted to do what our <code>Append</code> does and
append a slice to a slice?  Easy: use <code>...</code> at the call
site, just as we did in the call to <code>Output</code> above.  This
snippet produces identical output to the one above.
</p>
<pre>
x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
</pre>
<p>
Without that <code>...</code>, it wouldn't compile because the types
would be wrong; <code>y</code> is not of type <code>int</code>.
</p>

<div class="english">
<h2 id="initialization">Initialization</h2>
</div>

<h2 id="初始化">初始化</h2>

<p>
Although it doesn't look superficially very different from
initialization in C or C++, initialization in Go is more powerful.
Complex structures can be built during initialization and the ordering
issues between initialized objects in different packages are handled
correctly.
</p>

<div class="english">
<h3 id="constants">Constants</h3>
</div>

<h3 id="常量">常量</h3>

<p>
Constants in Go are just that&mdash;constant.
They are created at compile time, even when defined as
locals in functions,
and can only be numbers, strings or booleans.
Because of the compile-time restriction, the expressions
that define them must be constant expressions,
evaluatable by the compiler.  For instance,
<code>1&lt;&lt;3</code> is a constant expression, while
<code>math.Sin(math.Pi/4)</code> is not because
the function call to <code>math.Sin</code> needs
to happen at run time.
</p>

<p>
In Go, enumerated constants are created using the <code>iota</code>
enumerator.  Since <code>iota</code> can be part of an expression and
expressions can be implicitly repeated, it is easy to build intricate
sets of values.
</p>
{{code "/doc/progs/eff_bytesize.go" `/^type ByteSize/` `/^\)/`}}
<p>
The ability to attach a method such as <code>String</code> to a
type makes it possible for such values to format themselves
automatically for printing, even as part of a general type.
</p>
{{code "/doc/progs/eff_bytesize.go" `/^func.*ByteSize.*String/` `/^}/`}}
<p>
The expression <code>YB</code> prints as <code>1.00YB</code>,
while <code>ByteSize(1e13)</code> prints as <code>9.09TB</code>.
</p>

<p>
Note that it's fine to call <code>Sprintf</code> and friends in the
implementation of <code>String</code> methods, but beware of
recurring into the <code>String</code> method through the nested
<code>Sprintf</code> call using a string format
(<code>%s</code>, <code>%q</code>, <code>%v</code>, <code>%x</code> or <code>%X</code>).
The <code>ByteSize</code> implementation of <code>String</code> is safe
because it calls <code>Sprintf</code> with <code>%f</code>.
</p>

<div class="english">
<h3 id="variables">Variables</h3>
</div>

<h3 id="变量">变量</h3>

<p>
Variables can be initialized just like constants but the
initializer can be a general expression computed at run time.
</p>
<pre>
var (
    HOME = os.Getenv("HOME")
    USER = os.Getenv("USER")
    GOROOT = os.Getenv("GOROOT")
)
</pre>

<div class="english">
<h3 id="init">The init function</h3>
</div>

<h3 id="init函数">init函数</h3>

<p>
Finally, each source file can define its own niladic <code>init</code> function to
set up whatever state is required.  (Actually each file can have multiple
<code>init</code> functions.)
And finally means finally: <code>init</code> is called after all the
variable declarations in the package have evaluated their initializers,
and those are evaluated only after all the imported packages have been
initialized.
</p>
<p>
Besides initializations that cannot be expressed as declarations,
a common use of <code>init</code> functions is to verify or repair
correctness of the program state before real execution begins.
</p>

<pre>
func init() {
    if USER == "" {
        log.Fatal("$USER not set")
    }
    if HOME == "" {
        HOME = "/usr/" + USER
    }
    if GOROOT == "" {
        GOROOT = HOME + "/go"
    }
    // GOROOT may be overridden by --goroot flag on command line.
    flag.StringVar(&amp;GOROOT, "goroot", GOROOT, "Go root directory")
}
</pre>

<div class="english">
<h2 id="methods">Methods</h2>
</div>

<h2 id="方法">方法</h2>

<div class="english">
<h3 id="pointers_vs_values">Pointers vs. Values</h3>
</div>

<h3 id="指针vs值">指针vs.值</h3>

<p>
Methods can be defined for any named type that is not a pointer or an interface;
the receiver does not have to be a struct.
<p>
In the discussion of slices above, we wrote an <code>Append</code>
function.  We can define it as a method on slices instead.  To do
this, we first declare a named type to which we can bind the method, and
then make the receiver for the method a value of that type.
</p>
<pre>
type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // Body exactly the same as above
}
</pre>
<p>
This still requires the method to return the updated slice.  We can
eliminate that clumsiness by redefining the method to take a
<i>pointer</i> to a <code>ByteSlice</code> as its receiver, so the
method can overwrite the caller's slice.
</p>
<pre>
func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // Body as above, without the return.
    *p = slice
}
</pre>
<p>
In fact, we can do even better.  If we modify our function so it looks
like a standard <code>Write</code> method, like this,
</p>
<pre>
func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // Again as above.
    *p = slice
    return len(data), nil
}
</pre>
<p>
then the type <code>*ByteSlice</code> satisfies the standard interface
<code>io.Writer</code>, which is handy.  For instance, we can
print into one.
</p>
<pre>
    var b ByteSlice
    fmt.Fprintf(&amp;b, "This hour has %d days\n", 7)
</pre>
<p>
We pass the address of a <code>ByteSlice</code>
because only <code>*ByteSlice</code> satisfies <code>io.Writer</code>.
The rule about pointers vs. values for receivers is that value methods
can be invoked on pointers and values, but pointer methods can only be
invoked on pointers.  This is because pointer methods can modify the
receiver; invoking them on a copy of the value would cause those
modifications to be discarded.
</p>
<p>
By the way, the idea of using <code>Write</code> on a slice of bytes
is implemented by <code>bytes.Buffer</code>.
</p>

<div class="english">
<h2 id="interfaces_and_types">Interfaces and other types</h2>
</div>

<h2 id="接口与类型">接口与其它类型</h2>

<div class="english">
<h3 id="interfaces">Interfaces</h3>
</div>

<h3 id="接口">接口</h3>

<p>
Interfaces in Go provide a way to specify the behavior of an
object: if something can do <em>this</em>, then it can be used
<em>here</em>.  We've seen a couple of simple examples already;
custom printers can be implemented by a <code>String</code> method
while <code>Fprintf</code> can generate output to anything
with a <code>Write</code> method.
Interfaces with only one or two methods are common in Go code, and are
usually given a name derived from the method, such as <code>io.Writer</code>
for something that implements <code>Write</code>.
</p>
<p>
A type can implement multiple interfaces.
For instance, a collection can be sorted
by the routines in package <code>sort</code> if it implements
<code>sort.Interface</code>, which contains <code>Len()</code>,
<code>Less(i, j int) bool</code>, and <code>Swap(i, j int)</code>,
and it could also have a custom formatter.
In this contrived example <code>Sequence</code> satisfies both.
</p>
{{code "/doc/progs/eff_sequence.go" `/^type/` "$"}}

<div class="english">
<h3 id="conversions">Conversions</h3>
</div>

<h3 id="转换">转换</h3>

<p>
The <code>String</code> method of <code>Sequence</code> is recreating the
work that <code>Sprint</code> already does for slices.  We can share the
effort if we convert the <code>Sequence</code> to a plain
<code>[]int</code> before calling <code>Sprint</code>.
</p>
<pre>
func (s Sequence) String() string {
    sort.Sort(s)
    return fmt.Sprint([]int(s))
}
</pre>
<p>
The conversion causes <code>s</code> to be treated as an ordinary slice
and therefore receive the default formatting.
Without the conversion, <code>Sprint</code> would find the
<code>String</code> method of <code>Sequence</code> and recur indefinitely.
Because the two types (<code>Sequence</code> and <code>[]int</code>)
are the same if we ignore the type name, it's legal to convert between them.
The conversion doesn't create a new value, it just temporarily acts
as though the existing value has a new type.
(There are other legal conversions, such as from integer to floating point, that
do create a new value.)
</p>
<p>
It's an idiom in Go programs to convert the
type of an expression to access a different
set of methods. As an example, we could use the existing
type <code>sort.IntSlice</code> to reduce the entire example
to this:
</p>
<pre>
type Sequence []int

// Method for printing - sorts the elements before printing
func (s Sequence) String() string {
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
</pre>
<p>
Now, instead of having <code>Sequence</code> implement multiple
interfaces (sorting and printing), we're using the ability of a data item to be
converted to multiple types (<code>Sequence</code>, <code>sort.IntSlice</code>
and <code>[]int</code>), each of which does some part of the job.
That's more unusual in practice but can be effective.
</p>

<div class="english">
<h3 id="generality">Generality</h3>
</div>

<h3 id="一般性">一般性</h3>

<p>
If a type exists only to implement an interface
and has no exported methods beyond that interface,
there is no need to export the type itself.
Exporting just the interface makes it clear that
it's the behavior that matters, not the implementation,
and that other implementations with different properties
can mirror the behavior of the original type.
It also avoids the need to repeat the documentation
on every instance of a common method.
</p>
<p>
In such cases, the constructor should return an interface value
rather than the implementing type.
As an example, in the hash libraries
both <code>crc32.NewIEEE</code> and <code>adler32.New</code>
return the interface type <code>hash.Hash32</code>.
Substituting the CRC-32 algorithm for Adler-32 in a Go program
requires only changing the constructor call;
the rest of the code is unaffected by the change of algorithm.
</p>
<p>
A similar approach allows the streaming cipher algorithms
in the various <code>crypto</code> packages to be
separated from the block ciphers they chain together.
The <code>Block</code> interface
in the <code>crypto/cipher</code> package specifies the
behavior of a block cipher, which provides encryption
of a single block of data.
Then, by analogy with the <code>bufio</code> package,
cipher packages that implement this interface
can be used to construct streaming ciphers, represented
by the <code>Stream</code> interface, without
knowing the details of the block encryption.
</p>
<p>
The  <code>crypto/cipher</code> interfaces look like this:
</p>
<pre>
type Block interface {
    BlockSize() int
    Encrypt(src, dst []byte)
    Decrypt(src, dst []byte)
}

type Stream interface {
    XORKeyStream(dst, src []byte)
}
</pre>

<p>
Here's the definition of the counter mode (CTR) stream,
which turns a block cipher into a streaming cipher; notice
that the block cipher's details are abstracted away:
</p>

<pre>
// NewCTR returns a Stream that encrypts/decrypts using the given Block in
// counter mode. The length of iv must be the same as the Block's block size.
func NewCTR(block Block, iv []byte) Stream
</pre>
<p>
<code>NewCTR</code> applies not
just to one specific encryption algorithm and data source but to any
implementation of the <code>Block</code> interface and any
<code>Stream</code>.  Because they return
interface values, replacing CTR
encryption with other encryption modes is a localized change.  The constructor
calls must be edited, but because the surrounding code must treat the result only
as a <code>Stream</code>, it won't notice the difference.
</p>

<div class="english">
<h3 id="interface_methods">Interfaces and methods</h3>
</div>

<h3 id="接口方法">接口与方法</h3>

<p>
Since almost anything can have methods attached, almost anything can
satisfy an interface.  One illustrative example is in the <code>http</code>
package, which defines the <code>Handler</code> interface.  Any object
that implements <code>Handler</code> can serve HTTP requests.
</p>
<pre>
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
</pre>
<p>
<code>ResponseWriter</code> is itself an interface that provides access
to the methods needed to return the response to the client.
Those methods include the standard <code>Write</code> method, so an
<code>http.ResponseWriter</code> can be used wherever an <code>io.Writer</code>
can be used.
<code>Request</code> is a struct containing a parsed representation
of the request from the client.
<p>
For brevity, let's ignore POSTs and assume HTTP requests are always
GETs; that simplification does not affect the way the handlers are
set up.  Here's a trivial but complete implementation of a handler to
count the number of times the
page is visited.
</p>
<pre>
// Simple counter server.
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "counter = %d\n", ctr.n)
}
</pre>
<p>
(Keeping with our theme, note how <code>Fprintf</code> can print to an
<code>http.ResponseWriter</code>.)
For reference, here's how to attach such a server to a node on the URL tree.
<pre>
import "net/http"
...
ctr := new(Counter)
http.Handle("/counter", ctr)
</pre>
<p>
But why make <code>Counter</code> a struct?  An integer is all that's needed.
(The receiver needs to be a pointer so the increment is visible to the caller.)
</p>
<pre>
// Simpler counter server.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    *ctr++
    fmt.Fprintf(w, "counter = %d\n", *ctr)
}
</pre>
<p>
What if your program has some internal state that needs to be notified that a page
has been visited?  Tie a channel to the web page.
</p>
<pre>
// A channel that sends a notification on each visit.
// (Probably want the channel to be buffered.)
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ch &lt;- req
    fmt.Fprint(w, "notification sent")
}
</pre>
<p>
Finally, let's say we wanted to present on <code>/args</code> the arguments
used when invoking the server binary.
It's easy to write a function to print the arguments.
</p>
<pre>
func ArgServer() {
    for _, s := range os.Args {
        fmt.Println(s)
    }
}
</pre>
<p>
How do we turn that into an HTTP server?  We could make <code>ArgServer</code>
a method of some type whose value we ignore, but there's a cleaner way.
Since we can define a method for any type except pointers and interfaces,
we can write a method for a function.
The <code>http</code> package contains this code:
</p>
<pre>
// The HandlerFunc type is an adapter to allow the use of
// ordinary functions as HTTP handlers.  If f is a function
// with the appropriate signature, HandlerFunc(f) is a
// Handler object that calls f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP calls f(c, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
    f(w, req)
}
</pre>
<p>
<code>HandlerFunc</code> is a type with a method, <code>ServeHTTP</code>,
so values of that type can serve HTTP requests.  Look at the implementation
of the method: the receiver is a function, <code>f</code>, and the method
calls <code>f</code>.  That may seem odd but it's not that different from, say,
the receiver being a channel and the method sending on the channel.
</p>
<p>
To make <code>ArgServer</code> into an HTTP server, we first modify it
to have the right signature.
</p>
<pre>
// Argument server.
func ArgServer(w http.ResponseWriter, req *http.Request) {
    for _, s := range os.Args {
        fmt.Fprintln(w, s)
    }
}
</pre>
<p>
<code>ArgServer</code> now has same signature as <code>HandlerFunc</code>,
so it can be converted to that type to access its methods,
just as we converted <code>Sequence</code> to <code>IntSlice</code>
to access <code>IntSlice.Sort</code>.
The code to set it up is concise:
</p>
<pre>
http.Handle("/args", http.HandlerFunc(ArgServer))
</pre>
<p>
When someone visits the page <code>/args</code>,
the handler installed at that page has value <code>ArgServer</code>
and type <code>HandlerFunc</code>.
The HTTP server will invoke the method <code>ServeHTTP</code>
of that type, with <code>ArgServer</code> as the receiver, which will in turn call
<code>ArgServer</code> (via the invocation <code>f(c, req)</code>
inside <code>HandlerFunc.ServeHTTP</code>).
The arguments will then be displayed.
</p>
<p>
In this section we have made an HTTP server from a struct, an integer,
a channel, and a function, all because interfaces are just sets of
methods, which can be defined for (almost) any type.
</p>

<div class="english">
<h2 id="embedding">Embedding</h2>
</div>

<h2 id="嵌入">嵌入</h2>

<p>
Go does not provide the typical, type-driven notion of subclassing,
but it does have the ability to &ldquo;borrow&rdquo; pieces of an
implementation by <em>embedding</em> types within a struct or
interface.
</p>
<p>
Interface embedding is very simple.
We've mentioned the <code>io.Reader</code> and <code>io.Writer</code> interfaces before;
here are their definitions.
</p>
<pre>
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
</pre>
<p>
The <code>io</code> package also exports several other interfaces
that specify objects that can implement several such methods.
For instance, there is <code>io.ReadWriter</code>, an interface
containing both <code>Read</code> and <code>Write</code>.
We could specify <code>io.ReadWriter</code> by listing the
two methods explicitly, but it's easier and more evocative
to embed the two interfaces to form the new one, like this:
</p>
<pre>
// ReadWriter is the interface that combines the Reader and Writer interfaces.
type ReadWriter interface {
    Reader
    Writer
}
</pre>
<p>
This says just what it looks like: A <code>ReadWriter</code> can do
what a <code>Reader</code> does <em>and</em> what a <code>Writer</code>
does; it is a union of the embedded interfaces (which must be disjoint
sets of methods).
Only interfaces can be embedded within interfaces.
<p>
The same basic idea applies to structs, but with more far-reaching
implications.  The <code>bufio</code> package has two struct types,
<code>bufio.Reader</code> and <code>bufio.Writer</code>, each of
which of course implements the analogous interfaces from package
<code>io</code>.
And <code>bufio</code> also implements a buffered reader/writer,
which it does by combining a reader and a writer into one struct
using embedding: it lists the types within the struct
but does not give them field names.
</p>
<pre>
// ReadWriter stores pointers to a Reader and a Writer.
// It implements io.ReadWriter.
type ReadWriter struct {
    *Reader  // *bufio.Reader
    *Writer  // *bufio.Writer
}
</pre>
<p>
The embedded elements are pointers to structs and of course
must be initialized to point to valid structs before they
can be used.
The <code>ReadWriter</code> struct could be written as
</p>
<pre>
type ReadWriter struct {
    reader *Reader
    writer *Writer
}
</pre>
<p>
but then to promote the methods of the fields and to
satisfy the <code>io</code> interfaces, we would also need
to provide forwarding methods, like this:
</p>
<pre>
func (rw *ReadWriter) Read(p []byte) (n int, err error) {
    return rw.reader.Read(p)
}
</pre>
<p>
By embedding the structs directly, we avoid this bookkeeping.
The methods of embedded types come along for free, which means that <code>bufio.ReadWriter</code>
not only has the methods of <code>bufio.Reader</code> and <code>bufio.Writer</code>,
it also satisfies all three interfaces:
<code>io.Reader</code>,
<code>io.Writer</code>, and
<code>io.ReadWriter</code>.
</p>
<p>
There's an important way in which embedding differs from subclassing.  When we embed a type,
the methods of that type become methods of the outer type,
but when they are invoked the receiver of the method is the inner type, not the outer one.
In our example, when the <code>Read</code> method of a <code>bufio.ReadWriter</code> is
invoked, it has exactly the same effect as the forwarding method written out above;
the receiver is the <code>reader</code> field of the <code>ReadWriter</code>, not the
<code>ReadWriter</code> itself.
</p>
<p>
Embedding can also be a simple convenience.
This example shows an embedded field alongside a regular, named field.
</p>
<pre>
type Job struct {
    Command string
    *log.Logger
}
</pre>
<p>
The <code>Job</code> type now has the <code>Log</code>, <code>Logf</code>
and other
methods of <code>*log.Logger</code>.  We could have given the <code>Logger</code>
a field name, of course, but it's not necessary to do so.  And now, once
initialized, we can
log to the <code>Job</code>:
</p>
<pre>
job.Log("starting now...")
</pre>
<p>
The <code>Logger</code> is a regular field of the struct and we can initialize
it in the usual way with a constructor,
</p>
<pre>
func NewJob(command string, logger *log.Logger) *Job {
    return &amp;Job{command, logger}
}
</pre>
<p>
or with a composite literal,
</p>
<pre>
job := &amp;Job{command, log.New(os.Stderr, "Job: ", log.Ldate)}
</pre>
<p>
If we need to refer to an embedded field directly, the type name of the field,
ignoring the package qualifier, serves as a field name.  If we needed to access the
<code>*log.Logger</code> of a <code>Job</code> variable <code>job</code>,
we would write <code>job.Logger</code>.
This would be useful if we wanted to refine the methods of <code>Logger</code>.
</p>
<pre>
func (job *Job) Logf(format string, args ...interface{}) {
    job.Logger.Logf("%q: %s", job.Command, fmt.Sprintf(format, args...))
}
</pre>
<p>
Embedding types introduces the problem of name conflicts but the rules to resolve
them are simple.
First, a field or method <code>X</code> hides any other item <code>X</code> in a more deeply
nested part of the type.
If <code>log.Logger</code> contained a field or method called <code>Command</code>, the <code>Command</code> field
of <code>Job</code> would dominate it.
</p>
<p>
Second, if the same name appears at the same nesting level, it is usually an error;
it would be erroneous to embed <code>log.Logger</code> if the <code>Job</code> struct
contained another field or method called <code>Logger</code>.
However, if the duplicate name is never mentioned in the program outside the type definition, it is OK.
This qualification provides some protection against changes made to types embedded from outside; there
is no problem if a field is added that conflicts with another field in another subtype if neither field
is ever used.
</p>


<div class="english">
<h2 id="concurrency">Concurrency</h2>
</div>

<h2 id="并发">并发</h2>

<div class="english">
<h3 id="sharing">Share by communicating</h3>
</div>

<h3 id="共享">通过通信共享</h3>

<p>
Concurrent programming is a large topic and there is space only for some
Go-specific highlights here.
</p>
<p>
Concurrent programming in many environments is made difficult by the
subtleties required to implement correct access to shared variables.  Go encourages
a different approach in which shared values are passed around on channels
and, in fact, never actively shared by separate threads of execution.
Only one goroutine has access to the value at any given time.
Data races cannot occur, by design.
To encourage this way of thinking we have reduced it to a slogan:
</p>
<blockquote>
Do not communicate by sharing memory;
instead, share memory by communicating.
</blockquote>
<p>
This approach can be taken too far.  Reference counts may be best done
by putting a mutex around an integer variable, for instance.  But as a
high-level approach, using channels to control access makes it easier
to write clear, correct programs.
</p>
<p>
One way to think about this model is to consider a typical single-threaded
program running on one CPU. It has no need for synchronization primitives.
Now run another such instance; it too needs no synchronization.  Now let those
two communicate; if the communication is the synchronizer, there's still no need
for other synchronization.  Unix pipelines, for example, fit this model
perfectly.  Although Go's approach to concurrency originates in Hoare's
Communicating Sequential Processes (CSP),
it can also be seen as a type-safe generalization of Unix pipes.
</p>

<div class="english">
<h3 id="goroutines">Goroutines</h3>
</div>

<h3 id="Go程">Go程</h3>

<p>
They're called <em>goroutines</em> because the existing
terms&mdash;threads, coroutines, processes, and so on&mdash;convey
inaccurate connotations.  A goroutine has a simple model: it is a
function executing concurrently with other goroutines in the same
address space.  It is lightweight, costing little more than the
allocation of stack space.
And the stacks start small, so they are cheap, and grow
by allocating (and freeing) heap storage as required.
</p>
<p>
Goroutines are multiplexed onto multiple OS threads so if one should
block, such as while waiting for I/O, others continue to run.  Their
design hides many of the complexities of thread creation and
management.
</p>
<p>
Prefix a function or method call with the <code>go</code>
keyword to run the call in a new goroutine.
When the call completes, the goroutine
exits, silently.  (The effect is similar to the Unix shell's
<code>&amp;</code> notation for running a command in the
background.)
</p>
<pre>
go list.Sort()  // run list.Sort concurrently; don't wait for it.
</pre>
<p>
A function literal can be handy in a goroutine invocation.
<pre>
func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // Note the parentheses - must call the function.
}
</pre>
<p>
In Go, function literals are closures: the implementation makes
sure the variables referred to by the function survive as long as they are active.
<p>
These examples aren't too practical because the functions have no way of signaling
completion.  For that, we need channels.
</p>

<div class="english">
<h3 id="channels">Channels</h3>
</div>

<h3 id="信道">信道</h3>

<p>
Like maps, channels are a reference type and are allocated with <code>make</code>.
If an optional integer parameter is provided, it sets the buffer size for the channel.
The default is zero, for an unbuffered or synchronous channel.
</p>
<pre>
ci := make(chan int)            // unbuffered channel of integers
cj := make(chan int, 0)         // unbuffered channel of integers
cs := make(chan *os.File, 100)  // buffered channel of pointers to Files
</pre>
<p>
Channels combine communication&mdash;the exchange of a value&mdash;with
synchronization&mdash;guaranteeing that two calculations (goroutines) are in
a known state.
</p>
<p>
There are lots of nice idioms using channels.  Here's one to get us started.
In the previous section we launched a sort in the background. A channel
can allow the launching goroutine to wait for the sort to complete.
</p>
<pre>
c := make(chan int)  // Allocate a channel.
// Start the sort in a goroutine; when it completes, signal on the channel.
go func() {
    list.Sort()
    c &lt;- 1  // Send a signal; value does not matter.
}()
doSomethingForAWhile()
&lt;-c   // Wait for sort to finish; discard sent value.
</pre>
<p>
Receivers always block until there is data to receive.
If the channel is unbuffered, the sender blocks until the receiver has
received the value.
If the channel has a buffer, the sender blocks only until the
value has been copied to the buffer; if the buffer is full, this
means waiting until some receiver has retrieved a value.
</p>
<p>
A buffered channel can be used like a semaphore, for instance to
limit throughput.  In this example, incoming requests are passed
to <code>handle</code>, which sends a value into the channel, processes
the request, and then receives a value from the channel.
The capacity of the channel buffer limits the number of
simultaneous calls to <code>process</code>.
</p>
<pre>
var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem &lt;- 1    // Wait for active queue to drain.
    process(r)  // May take a long time.
    &lt;-sem       // Done; enable next request to run.
}

func Serve(queue chan *Request) {
    for {
        req := &lt;-queue
        go handle(req)  // Don't wait for handle to finish.
    }
}
</pre>
<p>
Here's the same idea implemented by starting a fixed
number of <code>handle</code> goroutines all reading from the request
channel.
The number of goroutines limits the number of simultaneous
calls to <code>process</code>.
This <code>Serve</code> function also accepts a channel on which
it will be told to exit; after launching the goroutines it blocks
receiving from that channel.
</p>
<pre>
func handle(queue chan *Request) {
    for r := range queue {
        process(r)
    }
}

func Serve(clientRequests chan *Request, quit chan bool) {
    // Start handlers
    for i := 0; i &lt; MaxOutstanding; i++ {
        go handle(clientRequests)
    }
    &lt;-quit  // Wait to be told to exit.
}
</pre>

<div class="english">
<h3 id="chan_of_chan">Channels of channels</h3>
</div>

<h3 id="信道的信道">信道的信道</h3>

<p>
One of the most important properties of Go is that
a channel is a first-class value that can be allocated and passed
around like any other.  A common use of this property is
to implement safe, parallel demultiplexing.
<p>
In the example in the previous section, <code>handle</code> was
an idealized handler for a request but we didn't define the
type it was handling.  If that type includes a channel on which
to reply, each client can provide its own path for the answer.
Here's a schematic definition of type <code>Request</code>.
</p>
<pre>
type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
</pre>
<p>
The client provides a function and its arguments, as well as
a channel inside the request object on which to receive the answer.
</p>
<pre>
func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &amp;Request{[]int{3, 4, 5}, sum, make(chan int)}
// Send request
clientRequests &lt;- request
// Wait for response.
fmt.Printf("answer: %d\n", &lt;-request.resultChan)
</pre>
<p>
On the server side, the handler function is the only thing that changes.
</p>
<pre>
func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan &lt;- req.f(req.args)
    }
}
</pre>
<p>
There's clearly a lot more to do to make it realistic, but this
code is a framework for a rate-limited, parallel, non-blocking RPC
system, and there's not a mutex in sight.
</p>

<div class="english">
<h3 id="parallel">Parallelization</h3>
</div>

<h3 id="并行">并行</h3>

<p>
Another application of these ideas is to parallelize a calculation
across multiple CPU cores.  If the calculation can be broken into
separate pieces that can execute independently, it can be parallelized,
with a channel to signal when each piece completes.
</p>
<p>
Let's say we have an expensive operation to perform on a vector of items,
and that the value of the operation on each item is independent,
as in this idealized example.
</p>
<pre>
type Vector []float64

// Apply the operation to v[i], v[i+1] ... up to v[n-1].
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i &lt; n; i++ {
        v[i] += u.Op(v[i])
    }
    c &lt;- 1    // signal that this piece is done
}
</pre>
<p>
We launch the pieces independently in a loop, one per CPU.
They can complete in any order but it doesn't matter; we just
count the completion signals by draining the channel after
launching all the goroutines.
</p>
<pre>
const NCPU = 4  // number of CPU cores

func (v Vector) DoAll(u Vector) {
    c := make(chan int, NCPU)  // Buffering optional but sensible.
    for i := 0; i &lt; NCPU; i++ {
        go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)
    }
    // Drain the channel.
    for i := 0; i &lt; NCPU; i++ {
        &lt;-c    // wait for one task to complete
    }
    // All done.
}

</pre>

<p>
The current implementation of the Go runtime
will not parallelize this code by default.
It dedicates only a single core to user-level processing.  An
arbitrary number of goroutines can be blocked in system calls, but
by default only one can be executing user-level code at any time.
It should be smarter and one day it will be smarter, but until it
is if you want CPU parallelism you must tell the run-time
how many goroutines you want executing code simultaneously.  There
are two related ways to do this.  Either run your job with environment
variable <code>GOMAXPROCS</code> set to the number of cores to use
or import the <code>runtime</code> package and call
<code>runtime.GOMAXPROCS(NCPU)</code>.
A helpful value might be <code>runtime.NumCPU()</code>, which reports the number
of logical CPUs on the local machine.
Again, this requirement is expected to be retired as the scheduling and run-time improve.
</p>

<div class="english">
<h3 id="leaky_buffer">A leaky buffer</h3>
</div>

<h3 id="漏桶缓存">漏桶缓存</h3>

<p>
The tools of concurrent programming can even make non-concurrent
ideas easier to express.  Here's an example abstracted from an RPC
package.  The client goroutine loops receiving data from some source,
perhaps a network.  To avoid allocating and freeing buffers, it keeps
a free list, and uses a buffered channel to represent it.  If the
channel is empty, a new buffer gets allocated.
Once the message buffer is ready, it's sent to the server on
<code>serverChan</code>.
</p>
<pre>
var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
    for {
        var b *Buffer
        // Grab a buffer if available; allocate if not.
        select {
        case b = &lt;-freeList:
            // Got one; nothing more to do.
        default:
            // None free, so allocate a new one.
            b = new(Buffer)
        }
        load(b)              // Read next message from the net.
        serverChan &lt;- b      // Send to server.
    }
}
</pre>
<p>
The server loop receives each message from the client, processes it,
and returns the buffer to the free list.
</p>
<pre>
func server() {
    for {
        b := &lt;-serverChan    // Wait for work.
        process(b)
        // Reuse buffer if there's room.
        select {
        case freeList &lt;- b:
            // Buffer on free list; nothing more to do.
        default:
            // Free list full, just carry on.
        }
    }
}
</pre>
<p>
The client attempts to retrieve a buffer from <code>freeList</code>;
if none is available, it allocates a fresh one.
The server's send to <code>freeList</code> puts <code>b</code> back
on the free list unless the list is full, in which case the
buffer is dropped on the floor to be reclaimed by
the garbage collector.
(The <code>default</code> clauses in the <code>select</code>
statements execute when no other case is ready,
meaning that the <code>selects</code> never block.)
This implementation builds a leaky bucket free list
in just a few lines, relying on the buffered channel and
the garbage collector for bookkeeping.
</p>

<div class="english">
<h2 id="errors">Errors</h2>
</div>

<h2 id="错误">错误</h2>

<p>
Library routines must often return some sort of error indication to
the caller.  As mentioned earlier, Go's multivalue return makes it
easy to return a detailed error description alongside the normal
return value.  By convention, errors have type <code>error</code>,
a simple built-in interface.
</p>
<pre>
type error interface {
    Error() string
}
</pre>
<p>
A library writer is free to implement this interface with a
richer model under the covers, making it possible not only
to see the error but also to provide some context.
For example, <code>os.Open</code> returns an <code>os.PathError</code>.
</p>
<pre>
// PathError records an error and the operation and
// file path that caused it.
type PathError struct {
    Op string    // "open", "unlink", etc.
    Path string  // The associated file.
    Err error    // Returned by the system call.
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
</pre>
<p>
<code>PathError</code>'s <code>Error</code> generates
a string like this:
</p>
<pre>
open /etc/passwx: no such file or directory
</pre>
<p>
Such an error, which includes the problematic file name, the
operation, and the operating system error it triggered, is useful even
if printed far from the call that caused it;
it is much more informative than the plain
"no such file or directory".
</p>

<p>
When feasible, error strings should identify their origin, such as by having
a prefix naming the package that generated the error.  For example, in package
<code>image</code>, the string representation for a decoding error due to an
unknown format is "image: unknown format".
</p>

<p>
Callers that care about the precise error details can
use a type switch or a type assertion to look for specific
errors and extract details.  For <code>PathErrors</code>
this might include examining the internal <code>Err</code>
field for recoverable failures.
</p>

<pre>
for try := 0; try &lt; 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Recover some space.
        continue
    }
    return
}
</pre>

<p>
The second <code>if</code> statement here is idiomatic Go.
The type assertion <code>err.(*os.PathError)</code> is
checked with the "comma ok" idiom (mentioned <a href="#maps">earlier</a>
in the context of examining maps).
If the type assertion fails, <code>ok</code> will be false, and <code>e</code>
will be <code>nil</code>.
If it succeeds,  <code>ok</code> will be true, which means the
error was of type <code>*os.PathError</code>, and then so is <code>e</code>,
which we can examine for more information about the error.
</p>

<div class="english">
<h3 id="panic">Panic</h3>
</div>

<h3 id="恐慌">恐慌</h3>

<p>
The usual way to report an error to a caller is to return an
<code>error</code> as an extra return value.  The canonical
<code>Read</code> method is a well-known instance; it returns a byte
count and an <code>error</code>.  But what if the error is
unrecoverable?  Sometimes the program simply cannot continue.
</p>

<p>
For this purpose, there is a built-in function <code>panic</code>
that in effect creates a run-time error that will stop the program
(but see the next section).  The function takes a single argument
of arbitrary type&mdash;often a string&mdash;to be printed as the
program dies.  It's also a way to indicate that something impossible has
happened, such as exiting an infinite loop.  In fact, the compiler
recognizes a <code>panic</code> at the end of a function and
suppresses the usual check for a <code>return</code> statement.
</p>


<pre>
// A toy implementation of cube root using Newton's method.
func CubeRoot(x float64) float64 {
    z := x/3   // Arbitrary initial value
    for i := 0; i &lt; 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // A million iterations has not converged; something is wrong.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
</pre>

<p>
This is only an example but real library functions should
avoid <code>panic</code>.  If the problem can be masked or worked
around, it's always better to let things continue to run rather
than taking down the whole program.  One possible counterexample
is during initialization: if the library truly cannot set itself up,
it might be reasonable to panic, so to speak.
</p>

<pre>
var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("no value for $USER")
    }
}
</pre>

<div class="english">
<h3 id="recover">Recover</h3>
</div>

<h3 id="恢复">恢复</h3>

<p>
When <code>panic</code> is called, including implicitly for run-time
errors such as indexing an array out of bounds or failing a type
assertion, it immediately stops execution of the current function
and begins unwinding the stack of the goroutine, running any deferred
functions along the way.  If that unwinding reaches the top of the
goroutine's stack, the program dies.  However, it is possible to
use the built-in function <code>recover</code> to regain control
of the goroutine and resume normal execution.
</p>

<p>
A call to <code>recover</code> stops the unwinding and returns the
argument passed to <code>panic</code>.  Because the only code that
runs while unwinding is inside deferred functions, <code>recover</code>
is only useful inside deferred functions.
</p>

<p>
One application of <code>recover</code> is to shut down a failing goroutine
inside a server without killing the other executing goroutines.
</p>

<pre>
func server(workChan &lt;-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
</pre>

<p>
In this example, if <code>do(work)</code> panics, the result will be
logged and the goroutine will exit cleanly without disturbing the
others.  There's no need to do anything else in the deferred closure;
calling <code>recover</code> handles the condition completely.
</p>

<p>
Because <code>recover</code> always returns <code>nil</code> unless called directly
from a deferred function, deferred code can call library routines that themselves
use <code>panic</code> and <code>recover</code> without failing.  As an example,
the deferred function in <code>safelyDo</code> might call a logging function before
calling <code>recover</code>, and that logging code would run unaffected
by the panicking state.
</p>

<p>
With our recovery pattern in place, the <code>do</code>
function (and anything it calls) can get out of any bad situation
cleanly by calling <code>panic</code>.  We can use that idea to
simplify error handling in complex software.  Let's look at an
idealized excerpt from the <code>regexp</code> package, which reports
parsing errors by calling <code>panic</code> with a local
error type.  Here's the definition of <code>Error</code>,
an <code>error</code> method, and the <code>Compile</code> function.
</p>

<pre>
// Error is the type of a parse error; it satisfies the error interface.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error is a method of *Regexp that reports parsing errors by
// panicking with an Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile returns a parsed representation of the regular expression.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse will panic if there is a parse error.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Clear return value.
            err = e.(Error) // Will re-panic if not a parse error.
        }
    }()
    return regexp.doParse(str), nil
}
</pre>

<p>
If <code>doParse</code> panics, the recovery block will set the
return value to <code>nil</code>&mdash;deferred functions can modify
named return values.  It then will then check, in the assignment
to <code>err</code>, that the problem was a parse error by asserting
that it has the local type <code>Error</code>.
If it does not, the type assertion will fail, causing a run-time error
that continues the stack unwinding as though nothing had interrupted
it.  This check means that if something unexpected happens, such
as an array index out of bounds, the code will fail even though we
are using <code>panic</code> and <code>recover</code> to handle
user-triggered errors.
</p>

<p>
With error handling in place, the <code>error</code> method
makes it easy to report parse errors without worrying about unwinding
the parse stack by hand.
</p>

<p>
Useful though this pattern is, it should be used only within a package.
<code>Parse</code> turns its internal <code>panic</code> calls into
<code>error</code> values; it does not expose <code>panics</code>
to its client.  That is a good rule to follow.
</p>

<p>
By the way, this re-panic idiom changes the panic value if an actual
error occurs.  However, both the original and new failures will be
presented in the crash report, so the root cause of the problem will
still be visible.  Thus this simple re-panic approach is usually
sufficient&mdash;it's a crash after all&mdash;but if you want to
display only the original value, you can write a little more code to
filter unexpected problems and re-panic with the original error.
That's left as an exercise for the reader.
</p>


<div class="english">
<h2 id="web_server">A web server</h2>
</div>

<h2 id="Web服务器">Web服务器</h2>

<p>
Let's finish with a complete Go program, a web server.
This one is actually a kind of web re-server.
Google provides a service at
<a href="http://chart.apis.google.com">http://chart.apis.google.com</a>
that does automatic formatting of data into charts and graphs.
It's hard to use interactively, though,
because you need to put the data into the URL as a query.
The program here provides a nicer interface to one form of data: given a short piece of text,
it calls on the chart server to produce a QR code, a matrix of boxes that encode the
text.
That image can be grabbed with your cell phone's camera and interpreted as,
for instance, a URL, saving you typing the URL into the phone's tiny keyboard.
</p>
<p>
Here's the complete program.
An explanation follows.
</p>
{{code "/doc/progs/eff_qr.go" `/package/` `$`}}
<p>
The pieces up to <code>main</code> should be easy to follow.
The one flag sets a default HTTP port for our server.  The template
variable <code>templ</code> is where the fun happens. It builds an HTML template
that will be executed by the server to display the page; more about
that in a moment.
</p>
<p>
The <code>main</code> function parses the flags and, using the mechanism
we talked about above, binds the function <code>QR</code> to the root path
for the server.  Then <code>http.ListenAndServe</code> is called to start the
server; it blocks while the server runs.
</p>
<p>
<code>QR</code> just receives the request, which contains form data, and
executes the template on the data in the form value named <code>s</code>.
</p>
<p>
The template package is powerful;
this program just touches on its capabilities.
In essence, it rewrites a piece of text on the fly by substituting elements derived
from data items passed to <code>templ.Execute</code>, in this case the
form value.
Within the template text (<code>templateStr</code>),
double-brace-delimited pieces denote template actions.
The piece from <code>{{html "{{if .}}"}}</code>
to <code>{{html "{{end}}"}}</code> executes only if the value of the current data item, called <code>.</code> (dot),
is non-empty.
That is, when the string is empty, this piece of the template is suppressed.
</p>
<p>
The snippet <code>{{html "{{urlquery .}}"}}</code> says to process the data with the function
<code>urlquery</code>, which sanitizes the query string
for safe display on the web page.
</p>
<p>
The rest of the template string is just the HTML to show when the page loads.
If this is too quick an explanation, see the <a href="/pkg/text/template/">documentation</a>
for the template package for a more thorough discussion.
</p>
<p>
And there you have it: a useful web server in a few lines of code plus some
data-driven HTML text.
Go is powerful enough to make a lot happen in a few lines.
</p>

<!--
TODO
<pre>
verifying implementation
type Color uint32

// Check that Color implements image.Color and image.Image
var _ image.Color = Black
var _ image.Image = Black
</pre>
-->

