<!--{
	"Title": "Go编程语言规范",
	"Subtitle": "版本：2012年3月17日	译者：Oling Cat <olingcat@gmail.com>",
	"Path": "/ref/spec"
}-->

<!--
TODO
[ ] need language about function/method calls and parameter passing rules
[ ] last paragraph of #Assignments (constant promotion) should be elsewhere
    and mention assignment to empty interface.
[ ] need to say something about "scope" of selectors?
[ ] clarify what a field name is in struct declarations
    (struct{T} vs struct {T T} vs struct {t T})
[ ] need explicit language about the result type of operations
[ ] should probably write something about evaluation order of statements even
	though obvious
[ ] review language on implicit dereferencing
-->

<!--
TODO
[ ] 需要语言中关于函数/方法调用和参数传递的规则
[ ] #赋值（常量推广）的最后一段应在别处
    且应在空接口中提及赋值。
[ ] 需要说一些关于选择器“作用域”的事？
[ ] 阐明在结构声明中什么是字段名
    (struct{T} 与 struct {T T} 与 struct {t T})
[ ] 关于操作符的结果类型需要详尽的语言描述
[ ] 或许应当写一些关于语句求值顺序的东西，
    尽管它很明显
[ ] 复审语言的隐式间接引用
-->


<div class="english">
<h2 id="Introduction">Introduction</h2>
</div>

<h2 id="前言">前言</h2>

<div class="english">
<p>
This is a reference manual for the Go programming language. For
more information and other documents, see <a href="http://golang.org/">http://golang.org</a>.
</p>
</div>

<p>
这是一份关于Go语言的参考手册。欲获取更多信息与文档，
请访问<a href="http://golang.org/">http://golang.org</a>。
</p>

<div class="english">
<p>
Go is a general-purpose language designed with systems programming
in mind. It is strongly typed and garbage-collected and has explicit
support for concurrent programming.  Programs are constructed from
<i>packages</i>, whose properties allow efficient management of
dependencies. The existing implementations use a traditional
compile/link model to generate executable binaries.
</p>
</div>

<p>
Go是通用型编程语言，为系统编程而设计。它是强类型的语言，具有垃圾回收机制并显示支持并发编程。
程序由 <i>包</i> 构造，以此提供高效的依赖管理功能。当前实现使用传统的 编译/链接 模型生成可执行二进制文件。
</p>

<div class="english">
<p>
The grammar is compact and regular, allowing for easy analysis by
automatic tools such as integrated development environments.
</p>
</div>

<p>
其语法紧凑而严谨，便于IDE等自动化工具分析。
</p>

<div class="english">
<h2 id="Notation">Notation</h2>
</div>

<h2 id="表示法">表示法</h2>

<div class="english">
<p>
The syntax is specified using Extended Backus-Naur Form (EBNF):
</p>

<pre class="grammar">
Production  = production_name "=" [ Expression ] "." .
Expression  = Alternative { "|" Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ "…" token ] | Group | Option | Repetition .
Group       = "(" Expression ")" .
Option      = "[" Expression "]" .
Repetition  = "{" Expression "}" .
</pre>
</div>

<p>
语法使用扩展巴克斯-诺尔范式（EBNF）实现：
</p>
<pre class="grammar">
生成式 = 生成式名 "=" [ 表达式 ] "." .
表达式 = 选择项 { "|" 选择项 } .
选择项 = 条目 { 条目 } .
条目   = 生成式名 | 标记 [ "…" 标记 ] | 组 | 可选项 | 重复项 .
组     = "(" 表达式 ")" .
可选项 = "[" 表达式 "]" .
重复项 = "{" 表达式 "}" .
</pre>

<div class="english">
<p>
Productions are expressions constructed from terms and the following
operators, in increasing precedence:
</p>
<pre class="grammar">
|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
</pre>
</div>

<p>
生成式由表达式构造，表达式通过术语及以下操作符构成，自上而下优先级递增（低=>高）：
</p>
<pre class="grammar">
|   选择
()  分组
[]  可选 （0 或 1 次）
{}  重复 （0 到 n 次）
</pre>

<div class="english">
<p>
Lower-case production names are used to identify lexical tokens.
Non-terminals are in CamelCase. Lexical tokens are enclosed in
double quotes <code>""</code> or back quotes <code>``</code>.
</p>
</div>

<p>
小写生成式名用于识别词法标记。非终止符使用驼峰记法。
词法符号由双引号 <code>""</code> 或反引号 <code>``</code> 围绕。
</p>

<div class="english">
<p>
The form <code>a … b</code> represents the set of characters from
<code>a</code> through <code>b</code> as alternatives. The horizontal
ellipsis <code>…</code> is also used elsewhere in the spec to informally denote various
enumerations or code snippets that are not further specified. The character <code>…</code>
(as opposed to the three characters <code>...</code>) is not a token of the Go
language.
</p>
</div>

<p>
形式 <code>a … b</code> 表示把从 <code>a</code> 到 <code>b</code>的字符集作为选择项。
横向的省略号 <code>…</code> 也在本文档的其它地方非正式地表示各种列举或简略的代码片断。
单个字符 <code>…</code>（不同于三个字符 <code>...</code>）并非Go语言本身的标记。
</p>

<div class="english">
<h2 id="Source_code_representation">Source code representation</h2>
</div>

<h2 id="源码的表示">源码的表示</h2>

<div class="english">
<p>
Source code is Unicode text encoded in
<a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a>. The text is not
canonicalized, so a single accented code point is distinct from the
same character constructed from combining an accent and a letter;
those are treated as two code points.  For simplicity, this document
will use the term <i>character</i> to refer to a Unicode code point.
</p>
<p>
Each code point is distinct; for instance, upper and lower case letters
are different characters.
</p>
<p>
Implementation restriction: For compatibility with other tools, a
compiler may disallow the NUL character (U+0000) in the source text.
</p>
</div>

<p>
源代码是采用
<a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a>编码的Unicode文本。
该文本是非商业化的，因此单一的着重号码点不同于结合字母与着重号的字符结构；
那些应当视为两个代码点。 为简单起见，本文档将使用术语 <i>字符</i> 替代Unicode码点。
</p>
<p>
每个码点都是不同的；例如，大写与小写的字母就是不同的字符。
</p>
<p>
实现限制：为兼容其它工具，编译器会阻止字符NUL（U+0000）出现在源代码文本中。
</p>

<div class="english">
<h3 id="Characters">Characters</h3>
</div>

<h3 id="字符">字符</h3>

<div class="english">
<p>
The following terms are used to denote specific Unicode character classes:
</p>
<pre class="ebnf">
newline        = /* the Unicode code point U+000A */ .
unicode_char   = /* an arbitrary Unicode code point except newline */ .
unicode_letter = /* a Unicode code point classified as "Letter" */ .
unicode_digit  = /* a Unicode code point classified as "Decimal Digit" */ .
</pre>
</div>

<p>
具体的Unicode字符类别由以下术语表示：
</p>
<pre class="ebnf">
换行符      = /* Unicode码点 U+000A */ .
Unicode字符 = /* 除newline以外的任意Unicode码点 */ .
Unicode字母 = /* 类型为“字母”的Unicode码点 */ .
Unicode数字 = /* 类型为“十进制数字”的Unicode码点 */ .
</pre>

<div class="english">
<p>
In <a href="http://www.unicode.org/versions/Unicode6.0.0/">The Unicode Standard 6.0</a>,
Section 4.5 "General Category"
defines a set of character categories.  Go treats
those characters in category Lu, Ll, Lt, Lm, or Lo as Unicode letters,
and those in category Nd as Unicode digits.
</p>
</div>

<p>
在<a href="http://www.unicode.org/versions/Unicode6.0.0/">Unicode标准6.0</a>,
章节4.5 “一般类别” 中定义了字符集类别。
其中类别Lu，Ll，Lt，Lm及Lo被视为Unicode字母，类别Nd被视为Unicode数字。
</p>

<div class="english">
<h3 id="Letters_and_digits">Letters and digits</h3>
</div>

<h3 id="字母和数字">字母和数字</h3>

<div class="english">
<p>
The underscore character <code>_</code> (U+005F) is considered a letter.
</p>
<pre class="ebnf">
letter        = unicode_letter | "_" .
decimal_digit = "0" … "9" .
octal_digit   = "0" … "7" .
hex_digit     = "0" … "9" | "A" … "F" | "a" … "f" .
</pre>
</div>

<p>
下划线字符<code>_</code>（U+005F）被视为一个字母。
</p>
<pre class="ebnf">
字母         = Unicode字母 | "_" .
十进制数字   = "0" … "9" .
八进制数字   = "0" … "7" .
十六进制数字 = "0" … "9" | "A" … "F" | "a" … "f" .
</pre>

<div class="english">
<h2 id="Lexical_elements">Lexical elements</h2>
</div>

<h2 id="词法元素">词法元素</h2>

<div class="english">
<h3 id="Comments">Comments</h3>
</div>

<h3 id="注释">注释</h3>

<div class="english">
<p>
There are two forms of comments:
</p>
</div>

<p>
注释有两种形式：
</p>

<div class="english">
<ol>
<li>
<i>Line comments</i> start with the character sequence <code>//</code>
and stop at the end of the line. A line comment acts like a newline.
</li>
<li>
<i>General comments</i> start with the character sequence <code>/*</code>
and continue through the character sequence <code>*/</code>. A general
comment containing one or more newlines acts like a newline, otherwise it acts
like a space.
</li>
</ol>
</div>

<ol>
<li>
<i>行注释</i> 以<code>//</code> 开始，至行尾结束。一条行注释视为一个换行符。
</li>
<li>
<i>块注释</i> 以 <code>/*</code> 开始，至 <code>*/</code> 结束。
块注释在包含多行时视为一个换行符，否则视为一个空格。
</li>
</ol>

<div class="english">
<p>
Comments do not nest.
</p>
</div>

<p>
注释不可嵌套。
</p>

<div class="english">
<h3 id="Tokens">Tokens</h3>
</div>

<h3 id="标记">标记</h3>

<div class="english">
<p>
Tokens form the vocabulary of the Go language.
There are four classes: <i>identifiers</i>, <i>keywords</i>, <i>operators
and delimiters</i>, and <i>literals</i>.  <i>White space</i>, formed from
spaces (U+0020), horizontal tabs (U+0009),
carriage returns (U+000D), and newlines (U+000A),
is ignored except as it separates tokens
that would otherwise combine into a single token. Also, a newline or end of file
may trigger the insertion of a <a href="#Semicolons">semicolon</a>.
While breaking the input into tokens,
the next token is the longest sequence of characters that form a
valid token.
</p>
</div>

<p>
标记形成Go语言的词汇。它有4种类型：<i>标识符</i>，<i>关键字</i>，
<i>运算符与分隔符</i>以及<i>文字</i>。<i>空白部分</i>由空格（U+0020），
横向制表符（U+0009），回车符（U+000D）和换行符（U+000A）组成，除非其间有分隔标记，
否则将合并为单个标记。此外，换行符或EOF（文件结束符）会触发<a href="#分号">分号</a>的插入。
当中断输入标记时，可形成有效标记的最长字符序列将作为下一个标记。
</p>

<div class="english">
<h3 id="Semicolons">Semicolons</h3>
</div>

<h3 id="分号">分号</h3>

<div class="english">
<p>
The formal grammar uses semicolons <code>";"</code> as terminators in
a number of productions. Go programs may omit most of these semicolons
using the following two rules:
</p>
</div>

<p>
正式语法使用分号 <code>";"</code> 作为一些生成式的结尾。Go程序会使用以下两条规则来省略大多数分号：
</p>

<div class="english">
<ol>
<li>
<p>
When the input is broken into tokens, a semicolon is automatically inserted
into the token stream at the end of a non-blank line if the line's final
token is
</p>
<ul>
	<li>an
	    <a href="#Identifiers">identifier</a>
	</li>

	<li>an
	    <a href="#Integer_literals">integer</a>,
	    <a href="#Floating-point_literals">floating-point</a>,
	    <a href="#Imaginary_literals">imaginary</a>,
	    <a href="#Character_literals">character</a>, or
	    <a href="#String_literals">string</a> literal
	</li>

	<li>one of the <a href="#Keywords">keywords</a>
	    <code>break</code>,
	    <code>continue</code>,
	    <code>fallthrough</code>, or
	    <code>return</code>
	</li>

	<li>one of the <a href="#Operators_and_Delimiters">operators and delimiters</a>
	    <code>++</code>,
	    <code>--</code>,
	    <code>)</code>,
	    <code>]</code>, or
	    <code>}</code>
	</li>
</ul>
</li>

<li>
To allow complex statements to occupy a single line, a semicolon
may be omitted before a closing <code>")"</code> or <code>"}"</code>.
</li>
</ol>
</div>

<ol>
<li>
<p>
当输入标记被中断后，若此行的行尾标记为以下标记流之一，一个分号就会被自动插入在非空行之后：
</p>
<ul>
	<li>
	    <a href="#标识符">标识符</a>
	</li>

	<li>
	    <a href="#整数">整数</a>,
	    <a href="#浮点数">浮点数</a>,
	    <a href="#虚数">虚数</a>,
	    <a href="#字符">字符</a>或
	    <a href="#字符串">字符串</a>文字
	</li>

	<li><a href="#关键字">关键字</a>
	    <code>break</code>,
	    <code>continue</code>,
	    <code>fallthrough</code>或
	    <code>return</code>
	</li>

	<li><a href="#运算符与分隔符">运算符与分隔符</a>
	    <code>++</code>,
	    <code>--</code>,
	    <code>)</code>,
	    <code>]</code>或
	    <code>}</code>
	</li>
</ul>
</li>

<li>
为允许复合语句占据单行，分号会在终止符 <code>")"</code> 或 <code>"}"</code> 之后被省略。
</li>
</ol>

<div class="english">
<p>
To reflect idiomatic use, code examples in this document elide semicolons
using these rules.
</p>
</div>

<p>
为了符合习惯用法，代码示例将使用这些规则在本文档中省略分号。
</p>


<div class="english">
<h3 id="Identifiers">Identifiers</h3>
</div>

<h3 id="标识符">标识符</h3>

<div class="english">
<p>
Identifiers name program entities such as variables and types.
An identifier is a sequence of one or more letters and digits.
The first character in an identifier must be a letter.
</p>
<pre class="ebnf">
identifier = letter { letter | unicode_digit } .
</pre>
</div>

<p>
标识符被用来命名程序实体，例如变量和类型。一个标识符由一个或多个字母和数字组成。
标识符的第一个字符必须是字母。
</p>
<pre class="ebnf">
标识符 = 字母 { 字母 | Unicode数字 } .
</pre>
<pre>
a
_x9
ThisVariableIsExported
αβ
</pre>

<div class="english">
<p>
Some identifiers are <a href="#Predeclared_identifiers">predeclared</a>.
</p>
</div>

<p>
一些标识符是<a href="#预声明">预声明</a>的。
</p>


<div class="english">
<h3 id="Keywords">Keywords</h3>
</div>

<h3 id="关键字">关键字</h3>

<div class="english">
<p>
The following keywords are reserved and may not be used as identifiers.
</p>
</div>

<p>
以下为保留关键字，不能用作标识符。
</p>

<pre class="grammar">
break        default      func         interface    select
case         defer        go           map          struct
chan         else         goto         package      switch
const        fallthrough  if           range        type
continue     for          import       return       var
</pre>

<div class="english">
<h3 id="Operators_and_Delimiters">Operators and Delimiters</h3>
</div>

<h3 id="运算符与分隔符">运算符与分隔符</h3>

<div class="english">
<p>
The following character sequences represent <a href="#Operators">operators</a>, delimiters, and other special tokens:
</p>
</div>

<p>
以下字符序列表示<a href="#运算符">运算符</a>，分隔符和其它特殊标记：
</p>

<pre class="grammar">
+    &amp;     +=    &amp;=     &amp;&amp;    ==    !=    (    )
-    |     -=    |=     ||    &lt;     &lt;=    [    ]
*    ^     *=    ^=     &lt;-    &gt;     &gt;=    {    }
/    &lt;&lt;    /=    &lt;&lt;=    ++    =     :=    ,    ;
%    &gt;&gt;    %=    &gt;&gt;=    --    !     ...   .    :
     &amp;^          &amp;^=
</pre>

<div class="english">
<h3 id="Integer_literals">Integer literals</h3>
</div>

<h3 id="整数字面">整数字面</h3>

<div class="english">
<p>
An integer literal is a sequence of digits representing an
<a href="#Constants">integer constant</a>.
An optional prefix sets a non-decimal base: <code>0</code> for octal, <code>0x</code> or
<code>0X</code> for hexadecimal.  In hexadecimal literals, letters
<code>a-f</code> and <code>A-F</code> represent values 10 through 15.
</p>
<pre class="ebnf">
int_lit     = decimal_lit | octal_lit | hex_lit .
decimal_lit = ( "1" … "9" ) { decimal_digit } .
octal_lit   = "0" { octal_digit } .
hex_lit     = "0" ( "x" | "X" ) hex_digit { hex_digit } .
</pre>
</div>

<p>
整数字面由数字序列组成，代表<a href="#常量">整数常量</a> 。非十进制数由这些前缀定义：
<code>0</code> 为八进制数前缀，<code>0x</code> 或 <code>0X</code>为十六进制数前缀。
在十六进制数字面中，字母 <code>a-f</code> 或 <code>A-F</code> 表示值10到15。
</p>
<pre class="ebnf">
整数字面      = 十进制数字面 | 八进制数字面 | 十六进制数字面 .
十进制数字面   = ( "1" … "9" ) { 十进制数字 } .
八进制数字面   = "0" { 八进制数字 } .
十六进制数字面 = "0" ( "x" | "X" ) 十六进制数字 { 十六进制数字 } .
</pre>

<pre>
42
0600
0xBadFace
170141183460469231731687303715884105727
</pre>

<div class="english">
<h3 id="Floating-point_literals">Floating-point literals</h3>
</div>

<h3 id="浮点数字面">浮点数字面</h3>

<div class="english">
<p>
A floating-point literal is a decimal representation of a
<a href="#Constants">floating-point constant</a>.
It has an integer part, a decimal point, a fractional part,
and an exponent part.  The integer and fractional part comprise
decimal digits; the exponent part is an <code>e</code> or <code>E</code>
followed by an optionally signed decimal exponent.  One of the
integer part or the fractional part may be elided; one of the decimal
point or the exponent may be elided.
</p>
<pre class="ebnf">
float_lit = decimals "." [ decimals ] [ exponent ] |
            decimals exponent |
            "." decimals [ exponent ] .
decimals  = decimal_digit { decimal_digit } .
exponent  = ( "e" | "E" ) [ "+" | "-" ] decimals .
</pre>
</div>

<p>
浮点数字面由十进制<a href="#常量">浮点常量</a>表示。
它由整数部分，小数点，小数部分和指数部分构成。整数部分与小数部分由十进制数字组成；
指数部分由一个 <code>e</code> 或 <code>E</code> 紧跟一个带可选正负号的十进制指数构成。
整数部分或小数部分可以省略；小数点或指数亦可省略。
</p>
<pre class="ebnf">
浮点数字面   = 十进制数 "." [ 十进制数 ] [ 指数 ] |
           十进制指数 |
           "." 十进制数 [ 指数 ] .
十进制数 = 十进制数字 { 十进制数字 } .
指数     = ( "e" | "E" ) [ "+" | "-" ] 十进制数 .
</pre>

<pre>
0.
72.40
072.40  // == 72.40
2.71828
1.e+0
6.67428e-11
1E6
.25
.12345E+5
</pre>

<div class="english">
<h3 id="Imaginary_literals">Imaginary literals</h3>
</div>

<h3 id="虚数字面">虚数字面</h3>

<div class="english">
<p>
An imaginary literal is a decimal representation of the imaginary part of a
<a href="#Constants">complex constant</a>.
It consists of a
<a href="#Floating-point_literals">floating-point literal</a>
or decimal integer followed
by the lower-case letter <code>i</code>.
</p>
<pre class="ebnf">
imaginary_lit = (decimals | float_lit) "i" .
</pre>
</div>

<p>
虚数字面由十进制<a href="#常量">复数常量</a>的虚部表示。它由
<a href="#浮点数字面">浮点数字面</a>或十进制整数紧跟小写字母 <code>i</code> 构成。
</p>
<pre class="ebnf">
虚数字面 = (十进制数 | 浮点数字面) "i" .
</pre>

<pre>
0i
011i  // == 11i
0.i
2.71828i
1.e+0i
6.67428e-11i
1E6i
.25i
.12345E+5i
</pre>


<div class="english">
<h3 id="Character_literals">Character literals</h3>
</div>

<h3 id="字符字面">字符字面</h3>

<div class="english">
<p>
A character literal represents a <a href="#Constants">character constant</a>,
typically a Unicode code point, as one or more characters enclosed in single
quotes.  Within the quotes, any character may appear except single
quote and newline. A single quoted character represents itself,
while multi-character sequences beginning with a backslash encode
values in various formats.
</p>
</div>

<p>
字符字面由一个<a href="#常量">字符常量</a>表示，通常一个Unicode码点作为一个或更多字符围绕在单引号中。
在引号内，除单引号和换行符外的任何字符都可出现。
单引号内的字符通常代表其自身，而以反斜杠开头的多字符序列则会编码为不同的形式。
</p>

<div class="english">
<p>
The simplest form represents the single character within the quotes;
since Go source text is Unicode characters encoded in UTF-8, multiple
UTF-8-encoded bytes may represent a single integer value.  For
instance, the literal <code>'a'</code> holds a single byte representing
a literal <code>a</code>, Unicode U+0061, value <code>0x61</code>, while
<code>'ä'</code> holds two bytes (<code>0xc3</code> <code>0xa4</code>) representing
a literal <code>a</code>-dieresis, U+00E4, value <code>0xe4</code>.
</p>
</div>

<p>
最简单的形式就是引号内只有一个字符；由于Go源码文本是UTF-8编码的Unicode字符，
因此多个UTF-8编码的字节可能只表示一个单一的整数值。例如，字面 <code>'a'</code> 包含一个字节，
表示一个字面 <code>a</code>，Unicode字符U+0061，值 <code>0x61</code>，而 <code>'ä'</code>
则包含两个字节（<code>0xc3</code> <code>0xa4</code>），表示一个字面 <code>a</code> 及其分音符，
Unicode字符U+00E4，值 <code>0xe4</code>。
</p>

<div class="english">
<p>
Several backslash escapes allow arbitrary values to be represented
as ASCII text.  There are four ways to represent the integer value
as a numeric constant: <code>\x</code> followed by exactly two hexadecimal
digits; <code>\u</code> followed by exactly four hexadecimal digits;
<code>\U</code> followed by exactly eight hexadecimal digits, and a
plain backslash <code>\</code> followed by exactly three octal digits.
In each case the value of the literal is the value represented by
the digits in the corresponding base.
</p>
</div>

<p>
反斜杠转义允许用ASCII文本来表示任意值。将整数值表示为数字常量有4种方法：
<code>\x</code> 紧跟2个十六进制数字；<code>\u</code> 紧跟4个十六进制数字；
<code>\U</code> 紧跟8个十六进制数字；单个<code>\</code>紧跟3个八进制数字。
在任何情况下，字面的值都是其相应的基数值。
</p>

<div class="english">
<p>
Although these representations all result in an integer, they have
different valid ranges.  Octal escapes must represent a value between
0 and 255 inclusive.  Hexadecimal escapes satisfy this condition
by construction. The escapes <code>\u</code> and <code>\U</code>
represent Unicode code points so within them some values are illegal,
in particular those above <code>0x10FFFF</code> and surrogate halves.
</p>
</div>

<p>
尽管这些表示方式的值都是整数，其有效范围却不相同。八进制转义只能表示 0 到 255 之间的值。
十六进制转义则视其结构而定。转义符 <code>\u</code> 和 <code>\U</code> 表示Unicode码点，
因此其中的一些值是非法的，特别是那些大于 <code>0x10FFFF</code> 的值和半替代值。
</p>

<div class="english">
<p>
After a backslash, certain single-character escapes represent special values:
</p>
<pre class="grammar">
\a   U+0007 alert or bell
\b   U+0008 backspace
\f   U+000C form feed
\n   U+000A line feed or newline
\r   U+000D carriage return
\t   U+0009 horizontal tab
\v   U+000b vertical tab
\\   U+005c backslash
\'   U+0027 single quote  (valid escape only within character literals)
\"   U+0022 double quote  (valid escape only within string literals)
</pre>
</div>

<p>
在反斜杠后，某些单字符转义表示特殊值：
</p>
<pre class="grammar">
\a   U+0007 警报或铃声
\b   U+0008 退格
\f   U+000C 换页
\n   U+000A 换行
\r   U+000D 回车
\t   U+0009 横向制表
\v   U+000b 纵向制表
\\   U+005c 反斜杠
\'   U+0027 单引号(仅在字符字面中有效)
\"   U+0022 双引号(仅在字符串字面中有效)
</pre>

<div class="english">
<p>
All other sequences starting with a backslash are illegal inside character literals.
</p>
<pre class="ebnf">
char_lit         = "'" ( unicode_value | byte_value ) "'" .
unicode_value    = unicode_char | little_u_value | big_u_value | escaped_char .
byte_value       = octal_byte_value | hex_byte_value .
octal_byte_value = `\` octal_digit octal_digit octal_digit .
hex_byte_value   = `\` "x" hex_digit hex_digit .
little_u_value   = `\` "u" hex_digit hex_digit hex_digit hex_digit .
big_u_value      = `\` "U" hex_digit hex_digit hex_digit hex_digit
                           hex_digit hex_digit hex_digit hex_digit .
escaped_char     = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
</pre>
</div>

<p>
在字符字面中，所有以反斜杠开始的序列都是非法的。
</p>
<pre class="ebnf">
字符字面       = "'" ( Unicode值 | 字节值 ) "'" .
Unicode值  = Unicode字符 | 小Unicode值 | 大Unicode值 | 转义字符 .
字节值      = 八进制字节值 | 十六进制字节值 .
八进制字节值 = `\` 八进制数字 八进制数字 八进制数字 .
十六进制字节值 = `\` "x" 十六进制数字 十六进制数字 .
小Unicode值 = `\` "u" 十六进制数字 十六进制数字 十六进制数字 十六进制数字 .
大Unicode值 = `\` "U" 十六进制数字 十六进制数字 十六进制数字 十六进制数字
                      十六进制数字 十六进制数字 十六进制数字 十六进制数字 .
转义字符    = `\` ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | `\` | "'" | `"` ) .
</pre>

<pre>
'a'
'ä'
'本'
'\t'
'\000'
'\007'
'\377'
'\x07'
'\xff'
'\u12e4'
'\U00101234'
</pre>


<div class="english">
<h3 id="String_literals">String literals</h3>
</div>

<h3 id="字符串字面">字符串字面</h3>

<div class="english">
<p>
A string literal represents a <a href="#Constants">string constant</a>
obtained from concatenating a sequence of characters. There are two forms:
raw string literals and interpreted string literals.
</p>
</div>

<p>
字符串字面由通过连结字符序列所得的<a href="#常量">字符串常量</a>表示。
它有两种形式：原始字符串字面和解译字符串字面。
</p>

<div class="english">
<p>
Raw string literals are character sequences between back quotes
<code>``</code>.  Within the quotes, any character is legal except
back quote. The value of a raw string literal is the
string composed of the uninterpreted characters between the quotes;
in particular, backslashes have no special meaning and the string may
contain newlines.
Carriage returns inside raw string literals
are discarded from the raw string value.
</p>
</div>

<p>
原始字符串字面为反引号 <code>``</code> 之间的字符序列。在该引号内，
除反引号外的任何字符都是合法的。原始字符串字面的值为此引号之间的无解译字符组成的字符串；
另外，反斜杠没有特殊意义且字符串可包含换行符。原始字符串字面中的回车符将会被原始字符串值丢弃。
</p>

<div class="english">
<p>
Interpreted string literals are character sequences between double
quotes <code>&quot;&quot;</code>. The text between the quotes,
which may not contain newlines, forms the
value of the literal, with backslash escapes interpreted as they
are in character literals (except that <code>\'</code> is illegal and
<code>\"</code> is legal).  The three-digit octal (<code>\</code><i>nnn</i>)
and two-digit hexadecimal (<code>\x</code><i>nn</i>) escapes represent individual
<i>bytes</i> of the resulting string; all other escapes represent
the (possibly multi-byte) UTF-8 encoding of individual <i>characters</i>.
Thus inside a string literal <code>\377</code> and <code>\xFF</code> represent
a single byte of value <code>0xFF</code>=255, while <code>ÿ</code>,
<code>\u00FF</code>, <code>\U000000FF</code> and <code>\xc3\xbf</code> represent
the two bytes <code>0xc3</code> <code>0xbf</code> of the UTF-8 encoding of character
U+00FF.
</p>
</div>

<p>
解译字符串字面为双引号 <code>&quot;&quot;</code> 之间的字符序列。
在该引号内，文本不可包含换行符，形成字面的值，由反斜杠转义解释为字符字面
（其中<code>\'</code>是非法的，而 <code>\"</code> 是合法的）。
3位八进制（<code>\</code><i>nnn</i>）和2位十六进制（<code>\x</code><i>nn</i>）
转义表示个别字符串值的 <i>字节</i> ；其它转义符表示（可多字节）UTF-8编码的个别 <i>字符</i>。
因此在字符串字面中，<code>\377</code> 和 <code>\xFF</code> 表示值为 <code>0xFF</code>=255的单个字节，
而<code>ÿ</code>、<code>\u00FF</code>、<code>\U000000FF</code> 和 <code>\xc3\xbf</code>
则表示UTF-8编码的字符U+00FF的两个字节<code>0xc3</code> <code>0xbf</code>。
</p>

<div class="english">
<pre class="ebnf">
string_lit             = raw_string_lit | interpreted_string_lit .
raw_string_lit         = "`" { unicode_char | newline } "`" .
interpreted_string_lit = `"` { unicode_value | byte_value } `"` .
</pre>

<pre>
`abc`  // same as "abc"
`\n
\n`    // same as "\\n\n\\n"
"\n"
""
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
</pre>
</div>

<pre class="ebnf">
字符串字面     = 原始字符串字面 | 解译字符串字面 .
原始字符串字面 = "`" { Unicode字符 | 换行符 } "`" .
解译字符串字面 = `"` { Unicode值 | 字节值 } `"` .
</pre>

<pre>
`abc`  // 等价于 "abc"
`\n
\n`    // 等价于 "\\n\n\\n"
"\n"
""
"Hello, world!\n"
"日本語"
"\u65e5本\U00008a9e"
"\xff\u00FF"
</pre>

<div class="english">
<p>
These examples all represent the same string:
</p>

<pre>
"日本語"                                 // UTF-8 input text
`日本語`                                 // UTF-8 input text as a raw literal
"\u65e5\u672c\u8a9e"                    // The explicit Unicode code points
"\U000065e5\U0000672c\U00008a9e"        // The explicit Unicode code points
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // The explicit UTF-8 bytes
</pre>
</div>

<p>
这些例子都表示相同的字符串：
</p>

<pre>
"日本語"                                // UTF-8输入的文本
`日本語`                                // UTF-8输入的原始字面文本
"\u65e5\u672c\u8a9e"                    // 显式的Unicode码点
"\U000065e5\U0000672c\U00008a9e"        // 显式的Unicode码点
"\xe6\x97\xa5\xe6\x9c\xac\xe8\xaa\x9e"  // 显式的UTF-8字节
</pre>

<div class="english">
<p>
If the source code represents a character as two code points, such as
a combining form involving an accent and a letter, the result will be
an error if placed in a character literal (it is not a single code
point), and will appear as two code points if placed in a string
literal.
</p>
</div>

<p>
如果源码将两个码点表示为一个字符，例如包含着重号和字母的结合形式，那么放置在
（非单一码点的）字符字面中就会产生一个错误，而放置在字符串字面中则会显示为两个码点。
</p>

<div class="english">
<h2 id="Constants">Constants</h2>
</div>

<h2 id="常量">常量</h2>

<div class="english">
<p>There are <i>boolean constants</i>,
<i>character constants</i>,
<i>integer constants</i>,
<i>floating-point constants</i>, <i>complex constants</i>,
and <i>string constants</i>. Character, integer, floating-point,
and complex constants are
collectively called <i>numeric constants</i>.
</p>
</div>

<p>
常量包含<i>布尔常量</i>，<i>字符常量</i>，
<i>整数常量</i>，<i>浮点数常量</i>，
<i>复数常量</i>和<i>字符串常量</i>。
字符，整数，浮点数和复数常量统称为<i>数值常量</i>.
</p>

<div class="english">
<p>
A constant value is represented by a
<a href="#Character_literals">character</a>,
<a href="#Integer_literals">integer</a>,
<a href="#Floating-point_literals">floating-point</a>,
<a href="#Imaginary_literals">imaginary</a>,
or
<a href="#String_literals">string</a> literal,
an identifier denoting a constant,
a <a href="#Constant_expressions">constant expression</a>,
a <a href="#Conversions">conversion</a> with a result that is a constant, or
the result value of some built-in functions such as
<code>unsafe.Sizeof</code> applied to any value,
<code>cap</code> or <code>len</code> applied to
<a href="#Length_and_capacity">some expressions</a>,
<code>real</code> and <code>imag</code> applied to a complex constant
and <code>complex</code> applied to numeric constants.
The boolean truth values are represented by the predeclared constants
<code>true</code> and <code>false</code>. The predeclared identifier
<a href="#Iota">iota</a> denotes an integer constant.
</p>
</div>

<p>
常量的值可由
<a href="#字符字面">字符</a>，
<a href="#整数字面">整数</a>，
<a href="#浮点数字面">浮点数</a>，
<a href="#虚数字面">虚数</a>或
<a href="#字符串字面">字符串</a>字面表示，
一个标识符可代表一个常量，一个<a href="#常量表达式">常量表达式</a>，
一个结果为常量的<a href="#强制转换">强制转换</a>，或一些内建函数所产生的值。
例如 <code>unsafe.Sizeof</code> 作用于任何值时产生的值，
<code>cap</code> 或 <code>len</code> 作用于
<a href="#长度与容量">一些表达式</a>，时产生的值，
<code>real</code> 和 <code>imag</code> 作用于复数常量时产生的值，以及
<code>complex</code> 作用于数值常量所产生的值。
布尔值由预声明的常量 <code>true</code> 和 <code>false</code> 来表示。
预声明标识符 <a href="#Iota">iota</a> 表示一个整数常量。
</p>

<div class="english">
<p>
In general, complex constants are a form of
<a href="#Constant_expressions">constant expression</a>
and are discussed in that section.
</p>
</div>

<p>
通常，复数常量的形式为
<a href="#常量表达式">常量表达式</a>，这一点将在该节中讨论。
</p>

<div class="english">
<p>
Numeric constants represent values of arbitrary precision and do not overflow.
</p>
</div>

<p>
数值常量可表示任意精度的值而不会溢出。
</p>

<div class="english">
<p>
Constants may be <a href="#Types">typed</a> or untyped.
Literal constants, <code>true</code>, <code>false</code>, <code>iota</code>,
and certain <a href="#Constant_expressions">constant expressions</a>
containing only untyped constant operands are untyped.
</p>
</div>

<p>
常量可以是<a href="#类型">有类型声明</a>的或无类型声明的。
字面常量，<code>true</code>，<code>false</code>，<code>iota</code>
和确定的<a href="#常量表达式">常量表达式</a>
只包含无类型声明常量和无类型声明操作数。
</p>

<div class="english">
<p>
A constant may be given a type explicitly by a <a href="#Constant_declarations">constant declaration</a>
or <a href="#Conversions">conversion</a>, or implicitly when used in a
<a href="#Variable_declarations">variable declaration</a> or an
<a href="#Assignments">assignment</a> or as an
operand in an <a href="#Expressions">expression</a>.
It is an error if the constant value
cannot be represented as a value of the respective type.
For instance, <code>3.0</code> can be given any integer or any
floating-point type, while <code>2147483648.0</code> (equal to <code>1&lt;&lt;31</code>)
can be given the types <code>float32</code>, <code>float64</code>, or <code>uint32</code> but
not <code>int32</code> or <code>string</code>.
</p>
</div>

<p>
常量可由<a href="#常量声明">常量声明</a>或<a href="#强制转换">强制转换</a>显式地赋予其类型，
也可由<a href="#变量声明">变量声明</a>或<a href="#赋值">赋值</a>以及作为
<a href="#表达式">表达式</a>中的操作数隐式地赋予其类型。若常量的值不能由其类型表示就会产生一个错误。
例如，<code>3.0</code> 可赋予任何整数或浮点数类型的常量，而 <code>2147483648.0</code>
（等价于 <code>1&lt;&lt;31</code>）则只能赋予 <code>float32</code>, <code>float64</code>
或 <code>uint32</code> 类型的常量，而不能赋予 <code>int32</code> 或 <code>string</code>类型的常量。
</p>

<div class="english">
<p>
There are no constants denoting the IEEE-754 infinity and not-a-number values,
but the <a href="/pkg/math/"><code>math</code> package</a>'s
<a href="/pkg/math/#Inf">Inf</a>,
<a href="/pkg/math/#NaN">NaN</a>,
<a href="/pkg/math/#IsInf">IsInf</a>, and
<a href="/pkg/math/#IsNaN">IsNaN</a>
functions return and test for those values at run time.
</p>
</div>

<p>
Go语言中没有代表 IEEE-754 无穷大和 NaN 值（非数值）的常量，然而
<a href="/pkg/math/"> <code>math</code> 包</a>中的
<a href="/pkg/math/#Inf">Inf</a>，
<a href="/pkg/math/#NaN">NaN</a>，
<a href="/pkg/math/#IsInf">IsInf</a> 和
<a href="/pkg/math/#IsNaN">IsNaN</a>
函数会在运行时返回并检验这些值。
</p>

<div class="english">
<p>
Implementation restriction: Although numeric constants have arbitrary
precision in the language, a compiler may implement them using an
internal representation with limited precision.  That said, every
implementation must:
</p>
<ul>
	<li>Represent integer constants with at least 256 bits.</li>

	<li>Represent floating-point constants, including the parts of
	    a complex constant, with a mantissa of at least 256 bits
	    and a signed exponent of at least 32 bits.</li>

	<li>Give an error if unable to represent an integer constant
	    precisely.</li>

	<li>Give an error if unable to represent a floating-point or
	    complex constant due to overflow.</li>

	<li>Round to the nearest representable constant if unable to
	    represent a floating-point or complex constant due to limits
	    on precision.</li>
</ul>
<p>
These requirements apply both to literal constants and to the result
of evaluating <a href="#Constant_expressions">constant
expressions</a>.
</p>
</div>

<p>
实现限制：尽管数值常量在该语言中可拥有任意精度，
但编译器可能使用其有限精度的内部表示来实现它们。即，每个实现必须：
</p>
<ul>
	<li>使用至少256位表示整数常量。</li>

	<li>使用至少256位表示浮点常量，包括复数常量及尾数部分；
		使用至少32位表示指数符号。</li>

	<li>若无法精确表示一个整数常量，则给出一个错误。</li>

	<li>若由于溢出而无法表示一个浮点或复数常量，则给出一个错误。</li>

	<li>若由于精度限制而无法表示一个浮点或复数常量，则舍入为最近似的可表示常量。</li>
</ul>
<p>
这些要求适用于字面常量和<a href="#常量表达式">常量表达式</a>的求值结果。
</p>

<div class="english">
<h2 id="Types">Types</h2>
</div>

<h2 id="类型">类型</h2>

<div class="english">
<p>
A type determines the set of values and operations specific to values of that
type.  A type may be specified by a (possibly qualified) <i>type name</i>
(§<a href="#Qualified_identifiers">Qualified identifier</a>, §<a href="#Type_declarations">Type declarations</a>) or a <i>type literal</i>,
which composes a new type from previously declared types.
</p>
</div>

<p>
类型决定值的集合与该类型值的具体操作。类型可（有限制地）通过<i>类型名</i>
（§<a href="#限定标识符">限定标识符</a>， §<a href="#类型声明">类型声明</a>）
或<i>类型字面</i>指定，它将根据之前声明的类型组成新的类型。
</p>

<div class="english">
<pre class="ebnf">
Type      = TypeName | TypeLit | "(" Type ")" .
TypeName  = QualifiedIdent .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType |
	    SliceType | MapType | ChannelType .
</pre>
</div>

<pre class="ebnf">
类型     = 类型名 | 类型字面 | "(" 类型 ")" .
类型名   = 限定标识符 .
类型字面 = 数组类型 | 结构类型 | 指针类型 | 函数类型 | 接口类型 |
           切片类型 | 映射类型 | 信道类型 .
</pre>

<div class="english">
<p>
Named instances of the boolean, numeric, and string types are
<a href="#Predeclared_identifiers">predeclared</a>.
<i>Composite types</i>&mdash;array, struct, pointer, function,
interface, slice, map, and channel types&mdash;may be constructed using
type literals.
</p>
</div>

<p>
布尔值，数值与字符串类型的实例的命名是<a href="#预声明标识符">预声明</a>的。
数组，结构，指针，函数，接口，切片，映射和信道这些<i>复合类型</i>可由类型字面构造。
</p>

<div class="english">
<p>
The <i>static type</i> (or just <i>type</i>) of a variable is the
type defined by its declaration.  Variables of interface type
also have a distinct <i>dynamic type</i>, which
is the actual type of the value stored in the variable at run-time.
The dynamic type may vary during execution but is always
<a href="#Assignability">assignable</a>
to the static type of the interface variable.  For non-interface
types, the dynamic type is always the static type.
</p>
</div>

<p>
变量的<i>静态类型</i>（或<i>类型</i>）是通过其声明定义的类型。
接口类型的变量也有一个独特的<i>动态类型</i>，这是在运行时存储在变量中的值的实际类型。
动态类型在执行过程中可能会有所不同，但接口变量的静态类型总是<a href="#可赋值性">可赋值</a>的。
对于非接口类型，其动态类型始终为其静态类型。
</p>

<div class="english">
<p>
Each type <code>T</code> has an <i>underlying type</i>: If <code>T</code>
is a predeclared type or a type literal, the corresponding underlying
type is <code>T</code> itself. Otherwise, <code>T</code>'s underlying type
is the underlying type of the type to which <code>T</code> refers in its
<a href="#Type_declarations">type declaration</a>.
</p>
</div>

<p>
每个类型 <code>T</code> 都有一个 <i>基本类型</i>：若 <code>T</code> 为预声明类型或类型字面，
其相应的基本类型为 <code>T</code> 本身。否则，<code>T</code>的基本类型为其
<a href="#类型声明">声明</a>类型的基本类型。
</p>

<pre>
   type T1 string
   type T2 T1
   type T3 []T1
   type T4 T3
</pre>

<div class="english">
<p>
The underlying type of <code>string</code>, <code>T1</code>, and <code>T2</code>
is <code>string</code>. The underlying type of <code>[]T1</code>, <code>T3</code>,
and <code>T4</code> is <code>[]T1</code>.
</p>
</div>

<p>
以上 <code>string</code>，<code>T1</code> 和 <code>T2</code> 的基本类型为 <code>string</code>。
<code>[]T1</code>，<code>T3</code> 和 <code>T4</code> 的基本类型为 <code>[]T1</code> 。
</p>

<div class="english">
<h3 id="Method_sets">Method sets</h3>
</div>

<h3 id="方法集">方法集</h3>

<div class="english">
<p>
A type may have a <i>method set</i> associated with it
(§<a href="#Interface_types">Interface types</a>, §<a href="#Method_declarations">Method declarations</a>).
The method set of an <a href="#Interface_types">interface type</a> is its interface.
The method set of any other type <code>T</code>
consists of all methods with receiver type <code>T</code>.
The method set of the corresponding pointer type <code>*T</code>
is the set of all methods with receiver <code>*T</code> or <code>T</code>
(that is, it also contains the method set of <code>T</code>).
Any other type has an empty method set.
In a method set, each method must have a
<a href="#Uniqueness_of_identifiers">unique</a> <a href="#MethodName">method name</a>.
</p>
</div>

<p>
类型可拥有一个与其相关联的 <i>方法集</i>（§<a href="#接口类型">接口类型</a>，§<a href="#方法声明">方法声明</a>）。
<a href="#接口类型">接口类型</a>的方法集为其接口。其它命名为类型 <code>T</code> 的方法集由所有带接收器类型
<code>T</code> 的方法组成。与指针类型 <code>*T</code> 相应的方法集为所有带接收器 <code>*T</code> 或 <code>T</code>
的方法的集（就是说，它也包含 <code>T</code> 的方法集）。任何类型都有一个空方法集。
在方法集中，每个方法都必须有<a href="#标识符的唯一性">唯一</a>的<a href="#方法名">方法名</a>。
</p>

<div class="english">
<p>
The method set of a type determines the interfaces that the
type <a href="#Interface_types">implements</a>
and the methods that can be <a href="#Calls">called</a>
using a receiver of that type.
</p>
</div>

<p>
方法集的类型决定了其接口的类型<a href="#接口类型">实现</a>
与可使用该类型接收器<a href="#调用">调用</a>的方法。
</p>

<div class="english">
<h3 id="Boolean_types">Boolean types</h3>
</div>

<h3 id="布尔类型">布尔类型</h3>

<div class="english">
<p>
A <i>boolean type</i> represents the set of Boolean truth values
denoted by the predeclared constants <code>true</code>
and <code>false</code>. The predeclared boolean type is <code>bool</code>.
</p>
</div>

<p>
<i>布尔类型</i> 表示由预声明常量 <code>true</code> 和 <code>false</code>所代表的布尔值的集。
预声明的布尔类型为 <code>bool</code>。
</p>

<div class="english">
<h3 id="Numeric_types">Numeric types</h3>
</div>

<h3 id="数值类型">数值类型</h3>

<div class="english">
<p>
A <i>numeric type</i> represents sets of integer or floating-point values.
The predeclared architecture-independent numeric types are:
</p>
</div>

<p>
<i>数值类型</i> 表示整数值和浮点数值的集。
架构中立的预声明数值类型为：
</p>

<div class="english">
<pre class="grammar">
uint8       the set of all unsigned  8-bit integers (0 to 255)
uint16      the set of all unsigned 16-bit integers (0 to 65535)
uint32      the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        alias for uint8
rune        alias for int32
</pre>
</div>

<pre class="grammar">
uint8       所有无符号 8位整数集（0 到 255）
uint16      所有无符号16位整数集（0 到 65535）
uint32      所有无符号32位整数集（0 到 4294967295）
uint64      所有无符号64位整数集（0 到 18446744073709551615）

int8        所有带符号 8位整数集（-128 到 127）
int16       所有带符号16位整数集（-32768 到 32767）
int32       所有带符号32位整数集（-2147483648 到 2147483647）
int64       所有带符号64位整数集（-9223372036854775808 到 9223372036854775807）

float32     所有IEEE-754 32位浮点数集
float64     所有IEEE-754 64位浮点数集

complex64   所有带float32实部和虚部的复数集
complex128  所有带float64实部和虚部的复数集

byte        uint8的别名
rune        int32的别名
</pre>

<div class="english">
<p>
The value of an <i>n</i>-bit integer is <i>n</i> bits wide and represented using
<a href="http://en.wikipedia.org/wiki/Two's_complement">two's complement arithmetic</a>.
</p>
</div>

<p>
<i>n</i> 位的整数值由 <i>n</i> 位宽的
<a href="http://en.wikipedia.org/wiki/Two's_complement">二进制补码运算</a>表示。
</p>

<div class="english">
<p>
There is also a set of predeclared numeric types with implementation-specific sizes:
</p>
</div>

<p>
取决于具体实现的预声明数值类型的集：
</p>

<div class="english">
<pre class="grammar">
uint     either 32 or 64 bits
int      same size as uint
uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value
</pre>
</div>

<pre class="grammar">
uint     32或64位
int      大小与uint相同
uintptr  大到足以存储指针值无解释位的无符号整数
</pre>

<div class="english">
<p>
To avoid portability issues all numeric types are distinct except
<code>byte</code>, which is an alias for <code>uint8</code>, and
<code>rune</code>, which is an alias for <code>int32</code>.
Conversions
are required when different numeric types are mixed in an expression
or assignment. For instance, <code>int32</code> and <code>int</code>
are not the same type even though they may have the same size on a
particular architecture.
</p>
</div>

<p>
为避免可移植性问题，除 <code>byte</code> 为 <code>uint8</code> 的别名以及
<code>rune</code> 为 <code>int32</code> 的别名外，所有数值类型都是不同的。
当不同的数值类型混合在一个表达式或赋值操作中时，必须进行强制转换。
例如，<code>int32</code> 与 <code>int</code> 是不同的类型，
尽管它们在特定架构上可能有相同的大小。
</p>

<div class="english">
<h3 id="String_types">String types</h3>
</div>

<h3 id="字符串类型">字符串类型</h3>

<div class="english">
<p>
A <i>string type</i> represents the set of string values.
Strings behave like slices of bytes but are immutable: once created,
it is impossible to change the contents of a string.
The predeclared string type is <code>string</code>.
</p>
</div>

<p>
<i>字符串类型</i> 表示字符串值的集。字符串的行为类似于字节数组，但它是不可变的：
一旦被创建，字符串的内容就不能更改。预声明的字符串类型为 <code>string</code>。
</p>

<div class="english">
<p>
The elements of strings have type <code>byte</code> and may be
accessed using the usual <a href="#Indexes">indexing operations</a>.  It is
illegal to take the address of such an element; if
<code>s[i]</code> is the <i>i</i>th byte of a
string, <code>&amp;s[i]</code> is invalid.  The length of string
<code>s</code> can be discovered using the built-in function
<code>len</code>. The length is a compile-time constant if <code>s</code>
is a string literal.
</p>
</div>

<p>
字符串元素的类型为 <code>byte</code>，通常使用<a href="#下标">下标操作</a>访问。
要获取这种元素的地址是非法的；若 <code>s[i]</code> 为字符串中的第 <i>i</i>个字节，
<code>&amp;s[i]</code> 操作是无效的。字符串 <code>s</code> 的长度可使用内建函数
<code>len</code>获取。若 <code>s</code> 为一个字符串字面，其长度则为一个编译时常量。
</p>


<div class="english">
<h3 id="Array_types">Array types</h3>
</div>

<h3 id="数组类型">数组类型</h3>

<div class="english">
<p>
An array is a numbered sequence of elements of a single
type, called the element type.
The number of elements is called the length and is never
negative.
</p>
</div>

<p>
数组是单类型元素的编号序列，称为元素类型。元素的数量称为长度且为非负数。
</p>

<div class="english">
<pre class="ebnf">
ArrayType   = "[" ArrayLength "]" ElementType .
ArrayLength = Expression .
ElementType = Type .
</pre>
</div>

<pre class="ebnf">
数组类型 = "[" 数组长度 "]" 元素类型 .
数组长度 = 表达式 .
元素类型 = 类型 .
</pre>

<div class="english">
<p>
The length is part of the array's type and must be a
<a href="#Constant_expressions">constant expression</a> that evaluates to a non-negative
integer value.  The length of array <code>a</code> can be discovered
using the built-in function <a href="#Length_and_capacity"><code>len(a)</code></a>.
The elements can be indexed by integer
indices 0 through <code>len(a)-1</code> (§<a href="#Indexes">Indexes</a>).
Array types are always one-dimensional but may be composed to form
multi-dimensional types.
</p>
</div>

<p>
长度是数组类型的一部分，且必须是求值结果为非负整数值的<a href="#常量表达式">常量表达式</a>。
数组 <code>a</code> 的长度可使用内建函数 <a href="#长度与容量"><code>len(a)</code></a>获取，
其元素可通过整数下标 0 到 <code>len(a)-1</code> 索引（§<a href="#下标">下标</a>）。
数组类型总是一维的，但可组成多维形式的类型。
</p>

<div class="english">
<pre>
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // same as [2]([2]([2]float64))
</pre>
</div>

<pre>
[32]byte
[2*N] struct { x, y int32 }
[1000]*float64
[3][5]int
[2][2][2]float64  // 等价于[2]([2]([2]float64))
</pre>

<div class="english">
<h3 id="Slice_types">Slice types</h3>
</div>

<h3 id="切片类型">切片类型</h3>

<div class="english">
<p>
A slice is a reference to a contiguous segment of an array and
contains a numbered sequence of elements from that array.  A slice
type denotes the set of all slices of arrays of its element type.
The value of an uninitialized slice is <code>nil</code>.
</p>
</div>

<p>
切片是数组连续段的引用及包含此数组的元素的编号序列。
切片类型表示数组元素类型所有切片的集。未初始化切片的值为 <code>nil</code>。
</p>

<div class="english">
<pre class="ebnf">
SliceType = "[" "]" ElementType .
</pre>
</div>

<pre class="ebnf">
切片类型 = "[" "]" 元素类型 .
</pre>

<div class="english">
<p>
Like arrays, slices are indexable and have a length.  The length of a
slice <code>s</code> can be discovered by the built-in function
<a href="#Length_and_capacity"><code>len(s)</code></a>; unlike with arrays it may change during
execution.  The elements can be addressed by integer indices 0
through <code>len(s)-1</code> (§<a href="#Indexes">Indexes</a>).  The slice index of a
given element may be less than the index of the same element in the
underlying array.
</p>
</div>

<p>
类似于数组，切片是可索引的且拥有一个长度。切片 <code>s</code> 的长度可通过内建函数
<a href="#长度与容量"><code>len(s)</code></a>获取；不同于数组的是，切片可在执行过程中被改变，
其元素可通过整数下标 0 到 <code>len(s)-1</code> 寻址（§<a href="#下标">下标</a>）。
给定元素的切片下标可能小于它在其基本数组中的下标。
</p>

<div class="english">
<p>
A slice, once initialized, is always associated with an underlying
array that holds its elements.  A slice therefore shares storage
with its array and with other slices of the same array; by contrast,
distinct arrays always represent distinct storage.
</p>
</div>

<p>
切片一旦初始化，就总是伴随着一个包含其元素的基本数组。
因此，切片与其数组及其它本数组的切片共享存储器；
与此相反，不同的数组总是表示其不同的存储器。
</p>

<div class="english">
<p>
The array underlying a slice may extend past the end of the slice.
The <i>capacity</i> is a measure of that extent: it is the sum of
the length of the slice and the length of the array beyond the slice;
a slice of length up to that capacity can be created by `slicing' a new
one from the original slice (§<a href="#Slices">Slices</a>).
The capacity of a slice <code>a</code> can be discovered using the
built-in function <a href="#Length_and_capacity"><code>cap(a)</code></a>.
</p>
</div>

<p>
切片的基本数组可扩展其原先的结尾。<i>容量</i> 是其大小的量度：
它是切片的长度和切片往后数组的长度之和；长度达到其容量的切片可通过从原切片
（§<a href="#Slices">Slices</a>）‘切下’一个新的来创建。
切片 <code>a</code> 的容量可使用内建函数 <a href="#长度与容量"><code>cap(a)</code></a> 获取。
</p>

<div class="english">
<p>
A new, initialized slice value for a given element type <code>T</code> is
made using the built-in function
<a href="#Making_slices_maps_and_channels"><code>make</code></a>,
which takes a slice type
and parameters specifying the length and optionally the capacity:
</p>
</div>

<p>
给定元素类型 <code>T</code> 的一个新的，已初始化的切片值使用内建函数
<a href="#创建切片、映射与信道"><code>make</code></a>创建，
它需要一个切片类型和具体长度参数以及可选的容量：
</p>

<pre>
make([]T, length)
make([]T, length, capacity)
</pre>

<div class="english">
<p>
A call to <code>make</code> allocates a new, hidden array to which the returned
slice value refers. That is, executing
</p>
</div>

<p>
返回切片值的 <code>make</code>调用将分配一个新的，隐藏的数组。即，执行
</p>

<pre>
make([]T, length, capacity)
</pre>

<div class="english">
<p>
produces the same slice as allocating an array and slicing it, so these two examples
result in the same slice:
</p>
</div>

<p>
分配一个数组和切下它将产生相同的切片，因此这两个例子的结果为相同的切片：
</p>

<pre>
make([]int, 50, 100)
new([100]int)[0:50]
</pre>

<div class="english">
<p>
Like arrays, slices are always one-dimensional but may be composed to construct
higher-dimensional objects.
With arrays of arrays, the inner arrays are, by construction, always the same length;
however with slices of slices (or arrays of slices), the lengths may vary dynamically.
Moreover, the inner slices must be allocated individually (with <code>make</code>).
</p>
</div>

<p>
类似于数组，切片总是一维的，但可构造更高维的对象。元素为数组的数组，
其内部数组，因其结构，长度始终相同；
然而元素为切片的切片（或元素为数组的切片），其长度会动态地改变。
此外，其内部的切片必须单独地（通过 <code>make</code>）分配。
</p>

<div class="english">
<h3 id="Struct_types">Struct types</h3>
</div>

<h3 id="结构类型">结构类型</h3>

<div class="english">
<p>
A struct is a sequence of named elements, called fields, each of which has a
name and a type. Field names may be specified explicitly (IdentifierList) or
implicitly (AnonymousField).
Within a struct, non-<a href="#Blank_identifier">blank</a> field names must
be <a href="#Uniqueness_of_identifiers">unique</a>.
</p>
</div>

<p>
结构是已命名的元素序列，被称为字段，其中每一个元素都有一个名字和类型。
字段名可显示地指定（标识符列表）或隐式地指定（匿名字段）。
在结构中，非<a href="#空白标识符">空白</a>字段名必须是<a href="#标识符的唯一性">唯一</a>的。
</p>

<div class="english">
<pre class="ebnf">
StructType     = "struct" "{" { FieldDecl ";" } "}" .
FieldDecl      = (IdentifierList Type | AnonymousField) [ Tag ] .
AnonymousField = [ "*" ] TypeName .
Tag            = string_lit .
</pre>
</div>

<pre class="ebnf">
结构类型 = "struct" "{" { 字段声明 ";" } "}" .
字段声明 = (标识符列表 类型 | 匿名字段) [ 标签 ] .
匿名字段 = [ "*" ] 类型名 .
标签     = 字符串字面 .
</pre>

<div class="english">
<pre>
// An empty struct.
struct {}

// A struct with 6 fields.
struct {
	x, y int
	u float32
	_ float32  // padding
	A *[]int
	F func()
}
</pre>
</div>

<pre>
// 空结构.
struct {}

// 带6个字段的结构
struct {
	x, y int
	u float32
	_ float32  // 填充
	A *[]int
	F func()
}
</pre>

<div class="english">
<p>
A field declared with a type but no explicit field name is an <i>anonymous field</i>,
also called an <i>embedded</i> field or an embedding of the type in the struct.
An embedded type must be specified as
a type name <code>T</code> or as a pointer to a non-interface type name <code>*T</code>,
and <code>T</code> itself may not be
a pointer type. The unqualified type name acts as the field name.
</p>
</div>

<p>
有类型无显式字段名的已声明字段为 <i>匿名字段</i>，亦称为 <i>嵌入式</i> 字段或该结构中此种类型的嵌入。
这种字段类型必须作为一个类型名 <code>T</code> 或一个非接口类型名的指针 <code>*T</code>来实现，
且 <code>T</code> 本身不能为指针类型。未限定类型名的行为类似于字段名。
</p>

<div class="english">
<pre>
// A struct with four anonymous fields of type T1, *T2, P.T3 and *P.T4
struct {
	T1        // field name is T1
	*T2       // field name is T2
	P.T3      // field name is T3
	*P.T4     // field name is T4
	x, y int  // field names are x and y
}
</pre>
</div>

<pre>
// 带类型为T1，*T2，P.T3和*P.T4的4个匿名字段的结构
struct {
	T1        // 字段名为T1
	*T2       // 字段名为T2
	P.T3      // 字段名为T3
	*P.T4     // 字段名为T4
	x, y int  // 字段名为x和y
}
</pre>

<div class="english">
<p>
The following declaration is illegal because field names must be unique
in a struct type:
</p>
</div>

<p>
以下为非法声明，因为字段名在结构类型中必须是唯一的：
</p>

<div class="english">
<pre>
struct {
	T     // conflicts with anonymous field *T and *P.T
	*T    // conflicts with anonymous field T and *P.T
	*P.T  // conflicts with anonymous field T and *T
}
</pre>
</div>

<pre>
struct {
	T     // 与匿名字段*T及*P.T相冲突
	*T    // 与匿名字段T及*P.T相冲突
	*P.T  // 与匿名字段T及*T相冲突
}
</pre>

<div class="english">
<p>
Fields and methods (§<a href="#Method_declarations">Method declarations</a>) of an anonymous field are
promoted to be ordinary fields and methods of the struct (§<a href="#Selectors">Selectors</a>).
The following rules apply for a struct type <code>S</code> and
a type named <code>T</code>:
</p>
<ul>
	<li>If <code>S</code> contains an anonymous field <code>T</code>, the
	    <a href="#Method_sets">method set</a> of <code>S</code> includes the
	    method set of <code>T</code>.
	</li>

	<li>If <code>S</code> contains an anonymous field <code>*T</code>, the
	    method set of <code>S</code> includes the method set of <code>*T</code>
	    (which itself includes the method set of <code>T</code>).
	</li>

	<li>If <code>S</code> contains an anonymous field <code>T</code> or
	    <code>*T</code>, the method set of <code>*S</code> includes the
	    method set of <code>*T</code> (which itself includes the method
	    set of <code>T</code>).
	</li>
</ul>
</div>

<p>
匿名字段的字段和方法（§<a href="#方法声明">方法声明</a>）
可升级为结构的普通字段和方法（§<a href="#选择器">选择器</a>）。
以下规则适用于名为 <code>S</code> 的结构类型和名为 <code>T</code> 的类型：
</p>
<ul>
	<li>若 <code>S</code> 包含一个匿名字段 <code>T</code>，
		则<a href="#方法集">方法集</a> <code>S</code> 包含方法集 <code>T</code>。
	</li>

	<li>若 <code>S</code> 包含一个匿名字段 <code>*T</code>，
		则方法集 <code>S</code> 包含方法集 <code>*T</code>
	    （它本身就包含方法集 <code>T</code>）。
	</li>

	<li>若 <code>S</code> 包含一个匿名字段 <code>T</code> 或 <code>*T</code>，
		则方法集 <code>*S</code> 包含方法集 <code>*T</code> (它本身就包含方法集 <code>T</code>）。
	</li>
</ul>

<div class="english">
<p>
A field declaration may be followed by an optional string literal <i>tag</i>,
which becomes an attribute for all the fields in the corresponding
field declaration. The tags are made
visible through a <a href="#Package_unsafe">reflection interface</a>
but are otherwise ignored.
</p>
</div>

<p>
字段声明可后跟一个可选的字符串字面 <i>tag</i>，成为所有相应字段声明中字段的标志。
标签可通过 <a href="#包unsafe">反射接口</a> 获得，否则就会被忽略。
</p>

<div class="english">
<pre>
// A struct corresponding to the TimeStamp protocol buffer.
// The tag strings define the protocol buffer field numbers.
struct {
	microsec  uint64 "field 1"
	serverIP6 uint64 "field 2"
	process   string "field 3"
}
</pre>
</div>

<pre>
// 一个对应于时间戳协议缓冲区的结构.
// 标签字符串定义了协议缓冲区的字段号.
struct {
	microsec  uint64 "field 1"
	serverIP6 uint64 "field 2"
	process   string "field 3"
}
</pre>

<div class="english">
<h3 id="Pointer_types">Pointer types</h3>
</div>

<h3 id="指针类型">指针类型</h3>

<div class="english">
<p>
A pointer type denotes the set of all pointers to variables of a given
type, called the <i>base type</i> of the pointer.
The value of an uninitialized pointer is <code>nil</code>.
</p>
</div>

<p>
指针类型表示一个所有给定类型变量的指针的集，称为指针的 <i>基础类型</i>。
未初始化的指针的值为 <code>nil</code>。
</p>

<div class="english">
<pre class="ebnf">
PointerType = "*" BaseType .
BaseType = Type .
</pre>
</div>

<pre class="ebnf">
指针类型 = "*" 基础类型 .
基础类型 = 类型 .
</pre>

<pre>
*Point
*[4]int
</pre>

<div class="english">
<h3 id="Function_types">Function types</h3>
</div>

<h3 id="函数类型">函数类型</h3>

<div class="english">
<p>
A function type denotes the set of all functions with the same parameter
and result types. The value of an uninitialized variable of function type
is <code>nil</code>.
</p>
</div>

<p>
函数类型表示所有带相同参数和值的类型的集。未初始化的函数类型变量的的值为 <code>nil</code>。
</p>

<div class="english">
<pre class="ebnf">
FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
ParameterList  = ParameterDecl { "," ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
</pre>
</div>

<pre class="ebnf">
函数类型 = "func" 签名 .
签名     = 参数 [ 值 ] .
值       = 参数 | 类型 .
参数     = "(" [ 参数列表 [ "," ] ] ")" .
参数列表 = 参数声明 { "," 参数声明 } .
参数声明 = [ 标识符列表 ] [ "..." ] 类型 .
</pre>

<div class="english">
<p>
Within a list of parameters or results, the names (IdentifierList)
must either all be present or all be absent. If present, each name
stands for one item (parameter or result) of the specified type; if absent, each
type stands for one item of that type.  Parameter and result
lists are always parenthesized except that if there is exactly
one unnamed result it may be written as an unparenthesized type.
</p>
</div>

<p>
在参数或值的列表中，其名称（标识符列表）必须都存在或都不存在。
若存在，则每个名称代表一个指定类型的项（参数或结果），
若不存在，则每个类型代表一个此类型的项。若恰好有一个未命名的值，它可能写作一个不加括号的类型，
除此之外，参数和值的列表总是在括号中。
</p>

<div class="english">
<p>
The final parameter in a function signature may have
a type prefixed with <code>...</code>.
A function with such a parameter is called <i>variadic</i> and
may be invoked with zero or more arguments for that parameter.
</p>
</div>

<p>
函数标记中的最后一个参数可能有一个带 <code>...</code> 前缀的类型。
带这样参数的函数被称为 <i>variadic</i> 且可带零个或多个参数的函数。
</p>

<pre>
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
</pre>


<div class="english">
<h3 id="Interface_types">Interface types</h3>
</div>

<h3 id="接口类型">接口类型</h3>

<div class="english">
<p>
An interface type specifies a <a href="#Method_sets">method set</a> called its <i>interface</i>.
A variable of interface type can store a value of any type with a method set
that is any superset of the interface. Such a type is said to
<i>implement the interface</i>.
The value of an uninitialized variable of interface type is <code>nil</code>.
</p>
</div>

<p>
接口类型指定一个称为 <i>接口</i> 的 <a href="#方法集">方法集</a>。
接口类型变量可存储任何带方法集类型的值，该方法集为此接口的超集。
这种类型表示 <i>实现此接口</i>。未初始化的接口类型变量的值为 <code>nil</code>。
</p>

<div class="english">
<pre class="ebnf">
InterfaceType      = "interface" "{" { MethodSpec ";" } "}" .
MethodSpec         = MethodName Signature | InterfaceTypeName .
MethodName         = identifier .
InterfaceTypeName  = TypeName .
</pre>
</div>

<pre class="ebnf">
接口类型   = "interface" "{" { 方法实现 ";" } "}" .
方法实现   = 方法名 签名 | 接口类型名 .
方法名     = 标识符 .
接口类型名 = 类型名 .
</pre>

<div class="english">
<p>
As with all method sets, in an interface type, each method must have a
<a href="#Uniqueness_of_identifiers">unique</a> name.
</p>
</div>

<p>
对于所有的方法集，在一个接口类型中，每个方法必须有<a href="#标识符的唯一性">唯一的</a>名字。
</p>

<div class="english">
<pre>
// A simple File interface
interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
	Close()
}
</pre>
</div>

<pre>
// 一个简单的File接口
interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
	Close()
}
</pre>

<div class="english">
<p>
More than one type may implement an interface.
For instance, if two types <code>S1</code> and <code>S2</code>
have the method set
</p>
</div>

<p>
不止一个类型可实现同一接口。例如，若两个类型 <code>S1</code> 和 <code>S2</code> 拥有方法集
</p>

<pre>
func (p T) Read(b Buffer) bool { return … }
func (p T) Write(b Buffer) bool { return … }
func (p T) Close() { … }
</pre>

<div class="english">
<p>
(where <code>T</code> stands for either <code>S1</code> or <code>S2</code>)
then the <code>File</code> interface is implemented by both <code>S1</code> and
<code>S2</code>, regardless of what other methods
<code>S1</code> and <code>S2</code> may have or share.
</p>
</div>

<p>
（其中 <code>T</code> 代表 <code>S1</code> 或 <code>S2</code>）
那么 <code>File</code> 接口都将被 <code>S1</code> 和 <code>S2</code>所实现，
不论如何，方法 <code>S1</code> 和 <code>S2</code> 都会拥有或共享它。
</p>

<div class="english">
<p>
A type implements any interface comprising any subset of its methods
and may therefore implement several distinct interfaces. For
instance, all types implement the <i>empty interface</i>:
</p>
</div>

<p>
类型可实现任何接口，包括任何其方法的子集，因此可能实现几个不同的接口。
例如，所有类型都实现了 <i>空接口</i>：
</p>

<pre>
interface{}
</pre>

<div class="english">
<p>
Similarly, consider this interface specification,
which appears within a <a href="#Type_declarations">type declaration</a>
to define an interface called <code>Lock</code>:
</p>
</div>

<p>
同样，考虑此接口的实现，它出现在<a href="#类型声明">类型声明</a>
中以定义一个名为 <code>Lock</code> 的接口：
</p>

<pre>
type Lock interface {
	Lock()
	Unlock()
}
</pre>

<div class="english">
<p>
If <code>S1</code> and <code>S2</code> also implement
</p>
</div>

<p>
若 <code>S1</code> 和 <code>S2</code> 也实现
</p>

<pre>
func (p T) Lock() { … }
func (p T) Unlock() { … }
</pre>

<div class="english">
<p>
they implement the <code>Lock</code> interface as well
as the <code>File</code> interface.
</p>
</div>

<p>
它们不仅会实现 <code>Lock</code> 还会实现 <code>File</code> 接口
</p>

<div class="english">
<p>
An interface may use an interface type name <code>T</code>
in place of a method specification.
The effect, called embedding an interface,
is equivalent to enumerating the methods of <code>T</code> explicitly
in the interface.
</p>
</div>

<p>
一个接口可通过包含一个名为 <code>T</code> 的接口类型来代替一个方法的实现。
这称之为嵌入接口，其效果等价于在接口中显式枚举出 <code>T</code> 中的方法。
</p>

<div class="english">
<pre>
type ReadWrite interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
}

type File interface {
	ReadWrite  // same as enumerating the methods in ReadWrite
	Lock       // same as enumerating the methods in Lock
	Close()
}
</pre>
</div>

<pre>
type ReadWrite interface {
	Read(b Buffer) bool
	Write(b Buffer) bool
}

type File interface {
	ReadWrite  // 等价于枚举ReadWrite中的方法
	Lock       // 等价于枚举Lock中的方法
	Close()
}
</pre>

<div class="english">
<p>
An interface type <code>T</code> may not embed itself
or any interface type that embeds <code>T</code>, recursively.
</p>
</div>

<p>
接口类型 <code>T</code> 不能嵌入其自身或任何递归地嵌入 <code>T</code> 的接口类型。
</p>

<div class="english">
<pre>
// illegal: Bad cannot embed itself
type Bad interface {
	Bad
}

// illegal: Bad1 cannot embed itself using Bad2
type Bad1 interface {
	Bad2
}
type Bad2 interface {
	Bad1
}
</pre>
</div>

<pre>
// 非法：Bad不能嵌入其自身
type Bad interface {
	Bad
}

// 非法：Bad1不能通过Bad2嵌入其自身
type Bad1 interface {
	Bad2
}
type Bad2 interface {
	Bad1
}
</pre>

<div class="english">
<h3 id="Map_types">Map types</h3>
</div>

<h3 id="映射类型">映射类型</h3>

<div class="english">
<p>
A map is an unordered group of elements of one type, called the
element type, indexed by a set of unique <i>keys</i> of another type,
called the key type.
The value of an uninitialized map is <code>nil</code>.
</p>
</div>

<p>
映射是一个同种类型元素的无序组，该类型称为元素类型；
映射通过另一类型唯一的 <i>键</i> 集索引，该类型称为键类型。
未初始化的映射值为 <code>nil</code>。
</p>

<div class="english">
<pre class="ebnf">
MapType     = "map" "[" KeyType "]" ElementType .
KeyType     = Type .
</pre>
</div>

<pre class="ebnf">
映射类型    = "map" "[" 键类型 "]" 元素类型 .
键类型      = 类型 .
</pre>

<div class="english">
<p>
The comparison operators <code>==</code> and <code>!=</code>
(§<a href="#Comparison_operators">Comparison operators</a>) must be fully defined
for operands of the key type; thus the key type must not be a function, map, or
slice.
If the key type is an interface type, these
comparison operators must be defined for the dynamic key values;
failure will cause a <a href="#Run_time_panics">run-time panic</a>.

</p>
</div>

<p>
比较操作符 <code>==</code> 和 <code>!=</code>
（§<a href="#比较操作符">比较操作符</a>）必须由键类型的操作数完全定义；
因此键类型不能是函数，映射或切片。若该键类型为接口类型，这些比较运算符必须由动态键值定义；
失败将导致一个 <a href="#运行时异常">运行时异常</a>.
</p>

<pre>
map[string]int
map[*T]struct{ x, y float64 }
map[string]interface{}
</pre>

<div class="english">
<p>
The number of map elements is called its length.
For a map <code>m</code>, it can be discovered using the
built-in function <a href="#Length_and_capacity"><code>len(m)</code></a>
and may change during execution. Elements may be added during execution
using <a href="#Assignments">assignments</a> and retrieved with
<a href="#Indexes">index</a> expressions; they may be removed with the
<a href="#Deletion_of_map_elements"><code>delete</code></a> built-in function.
</p>
</div>

<p>
元素的数量称为长度。
对于映射 <code>m</code>，其长度可使用内建函数 <a href="#长度与容量"><code>len(m)</code></a>
获取并可在执行时更改。元素可在执行时使用<a href="#赋值">赋值</a>来添加并通过
<a href="#索引">索引</a> 表达式来检索；它们也可通过内建函数
<a href="#映射元素的删除"><code>delete</code></a> 删除。
</p>

<div class="english">
<p>
A new, empty map value is made using the built-in
function <a href="#Making_slices_maps_and_channels"><code>make</code></a>,
which takes the map type and an optional capacity hint as arguments:
</p>
</div>

<p>
一个新的，空的映射值使用内建函数 <a href="#创建切片、映射与信道"><code>make</code></a> 创建，
它使该映射类型和可选容量作为参数提示：
</p>

<pre>
make(map[string]int)
make(map[string]int, 100)
</pre>

<div class="english">
<p>
The initial capacity does not bound its size:
maps grow to accommodate the number of items
stored in them, with the exception of <code>nil</code> maps.
A <code>nil</code> map is equivalent to an empty map except that no elements
may be added.
</p>
</div>

<p>
初始容量不能限定它的大小：映射通过增长来适应存储在其中的条目数量，包括 <code>nil</code> 映射的异常。
一个 <code>nil</code> 映射等价于一个空映射除非它没有元素被添加。
</p>

<div class="english">
<h3 id="Channel_types">Channel types</h3>
</div>

<h3 id="信道类型">信道类型</h3>

<div class="english">
<p>
A channel provides a mechanism for two concurrently executing functions
to synchronize execution and communicate by passing a value of a
specified element type.
The value of an uninitialized channel is <code>nil</code>.
</p>
</div>

<p>
信道提供一种机制使两个并发执行的函数同步执行，并通过传递具体元素类型的值来通信。
未初始化的信道值为 <code>nil</code>。
</p>

<div class="english">
<pre class="ebnf">
ChannelType = ( "chan" [ "&lt;-" ] | "&lt;-" "chan" ) ElementType .
</pre>
</div>

<pre class="ebnf">
信道类型 = ( "chan" [ "&lt;-" ] | "&lt;-" "chan" ) 元素类型 .
</pre>

<div class="english">
<p>
The <code>&lt;-</code> operator specifies the channel <i>direction</i>,
<i>send</i> or <i>receive</i>. If no direction is given, the channel is
<i>bi-directional</i>.
A channel may be constrained only to send or only to receive by
<a href="#Conversions">conversion</a> or <a href="#Assignments">assignment</a>.
</p>
</div>

<p>
<code>&lt;-</code> 操作符指定信道的 <i>方向</i>，<i>发送</i> 或 <i>接收</i>。
若没有给定方向，那么该信道就是 <i>双向的</i>。
信道可通过<a href="#强制转换">强制转换</a> 或 <a href="#赋值">赋值</a>被强制为只发送或只接收。
</p>

<div class="english">
<pre>
chan T          // can be used to send and receive values of type T
chan&lt;- float64  // can only be used to send float64s
&lt;-chan int      // can only be used to receive ints
</pre>
</div>

<pre>
chan T          // 可以被用来发送和接收类型T的值
chan&lt;- float64  // 只能被用来发送浮点数
&lt;-chan int      // 只能被用来接收整数
</pre>

<div class="english">
<p>
The <code>&lt;-</code> operator associates with the leftmost <code>chan</code>
possible:
</p>
</div>

<p>
<code>&lt;-</code> 操作符结合最左边的 <code>chan</code> 可能的方式：
</p>

<div class="english">
<pre>
chan&lt;- chan int    // same as chan&lt;- (chan int)
chan&lt;- &lt;-chan int  // same as chan&lt;- (&lt;-chan int)
&lt;-chan &lt;-chan int  // same as &lt;-chan (&lt;-chan int)
chan (&lt;-chan int)
</pre>
</div>

<pre>
chan&lt;- chan int    // 等价于 chan&lt;- (chan int)
chan&lt;- &lt;-chan int  // 等价于 chan&lt;- (&lt;-chan int)
&lt;-chan &lt;-chan int  // 等价于 &lt;-chan (&lt;-chan int)
chan (&lt;-chan int)
</pre>

<div class="english">
<p>
A new, initialized channel
value can be made using the built-in function
<a href="#Making_slices_maps_and_channels"><code>make</code></a>,
which takes the channel type and an optional capacity as arguments:
</p>
</div>

<p>
一个新的，已初始化的信道值可使用内建函数 <a href="#创建切片、映射与信道"><code>make</code></a> 创建，
它接受信道类型和一个可选的容量作为参数：
</p>

<pre>
make(chan int, 100)
</pre>

<div class="english">
<p>
The capacity, in number of elements, sets the size of the buffer in the channel. If the
capacity is greater than zero, the channel is asynchronous: communication operations
succeed without blocking if the buffer is not full (sends) or not empty (receives),
and elements are received in the order they are sent.
If the capacity is zero or absent, the communication succeeds only when both a sender and
receiver are ready.
A <code>nil</code> channel is never ready for communication.
</p>
</div>

<p>
容量根据元素的数量设置信道中缓冲区的大小。若容量大于零，则信道是异步的：
若缓冲区未满（发送）或非空（接收），则通信操作无阻塞成功，且元素在发送序列中被接收。
若容量为零或无，则只有当发送器和接收器都做好准备时通信才会成功。
<code>nil</code> 信道永远不会准备好通信。
</p>

<div class="english">
<p>
A channel may be closed with the built-in function
<a href="#Close"><code>close</code></a>; the
multi-valued assignment form of the
<a href="#Receive_operator">receive operator</a>
tests whether a channel has been closed.
</p>
</div>

<p>
信道可通过内建函数<a href="#关闭"><code>close</code></a>关闭；
<a href="#接收操作符">接收操作符</a>的多值赋值形式可测试信道是否关闭。
</p>

<div class="english">
<h2 id="Properties_of_types_and_values">Properties of types and values</h2>
</div>

<h2 id="类型与值的性质">类型与值的性质</h2>

<div class="english">
<h3 id="Type_identity">Type identity</h3>
</div>

<h3 id="类型标识">类型标识</h3>

<div class="english">
<p>
Two types are either <i>identical</i> or <i>different</i>.
</p>
</div>

<p>
两个类型若非 <i>相同</i> 即为 <i>不同</i>。
</p>

<div class="english">
<p>
Two named types are identical if their type names originate in the same
<a href="#Type_declarations">TypeSpec</a>.
A named and an unnamed type are always different. Two unnamed types are identical
if the corresponding type literals are identical, that is, if they have the same
literal structure and corresponding components have identical types. In detail:
</p>
</div>

<p>
若两个已命名类型的类型名源自相同的<a href="#类型声明">类型声明</a>。
一个已命名类型和一个未命名类型总不相同。若两个未命名类型其相应的类型字面相同，那么它们的类型相同，
即，它们的字面结构是否相同且其相应的组件类型是否相同。细节详述：
</p>

<div class="english">
<ul>
	<li>Two array types are identical if they have identical element types and
	    the same array length.</li>

	<li>Two slice types are identical if they have identical element types.</li>

	<li>Two struct types are identical if they have the same sequence of fields,
	    and if corresponding fields have the same names, and identical types,
	    and identical tags.
	    Two anonymous fields are considered to have the same name. Lower-case field
	    names from different packages are always different.</li>

	<li>Two pointer types are identical if they have identical base types.</li>

	<li>Two function types are identical if they have the same number of parameters
	    and result values, corresponding parameter and result types are
	    identical, and either both functions are variadic or neither is.
	    Parameter and result names are not required to match.</li>

	<li>Two interface types are identical if they have the same set of methods
	    with the same names and identical function types. Lower-case method names from
	    different packages are always different. The order of the methods is irrelevant.</li>

	<li>Two map types are identical if they have identical key and value types.</li>

	<li>Two channel types are identical if they have identical value types and
	    the same direction.</li>
</ul>
</div>

<ul>
	<li>若两个数组类型其元素类型相同且长度相同，那么它们的类型相同。</li>

	<li>若两个切片类型其元素类型相同，那么它们的类型相同。</li>

	<li>若两个结构类型其字段序列相同，相应字段名相同，类型相同，标签相同，那么它们的类型相同。
		两个匿名字段其名字被认为相同。出自不同包的小写字段名总不相同。</li>

	<li>若两个指针类型其基本类型相同，那么它们的类型相同。</li>

	<li>若两个函数类型其参数数目相同，返回值相同，相应参数类型相同，返回值类型相同，
		两函数都可变或都不可变，那么它们的类型相同。参数和返回值名无需匹配。</li>

	<li>若两个接口类型其方法集相同，名字相同，函数类型相同，那么它们的类型相同。
		出自不同包的小写方法名总不相同。两接口类型是否相同与方法的次序无关。</li>

	<li>若两个映射类型其键值类型相同，那么它们的类型相同。</li>

	<li>若两个信道类型其值类型相同，方向相同，那么他们的类型相同。</li>
</ul>

<div class="english">
<p>
Given the declarations
</p>
</div>

<p>
给定声明
</p>

<pre>
type (
	T0 []string
	T1 []string
	T2 struct{ a, b int }
	T3 struct{ a, c int }
	T4 func(int, float64) *T0
	T5 func(x int, y float64) *[]string
)
</pre>

<div class="english">
<p>
these types are identical:
</p>
</div>

<p>
这些类型是相同的：
</p>

<div class="english">
<pre>
T0 and T0
[]int and []int
struct{ a, b *T5 } and struct{ a, b *T5 }
func(x int, y float64) *[]string and func(int, float64) (result *[]string)
</pre>
</div>

<pre>
T0 和 T0
[]int 和 []int
struct{ a, b *T5 } 和 struct{ a, b *T5 }
func(x int, y float64) *[]string 和 func(int, float64) (result *[]string)
</pre>

<div class="english">
<p>
<code>T0</code> and <code>T1</code> are different because they are named types
with distinct declarations; <code>func(int, float64) *T0</code> and
<code>func(x int, y float64) *[]string</code> are different because <code>T0</code>
is different from <code>[]string</code>.
</p>
</div>

<p>
<code>T0</code> 和 <code>T1</code> 是不同的，因为它们由不同声明的类型命名；
<code>func(int, float64) *T0</code> 和 <code>func(x int, y float64) *[]string</code> 是不同的，
因为 <code>T0</code> 不同于 <code>[]string</code>。
</p>


<div class="english">
<h3 id="Assignability">Assignability</h3>
</div>

<h3 id="可赋值性">可赋值性</h3>

<div class="english">
<p>
A value <code>x</code> is <i>assignable</i> to a variable of type <code>T</code>
("<code>x</code> is assignable to <code>T</code>") in any of these cases:
</p>
</div>

<p>
在下列情况下，值 <code>x</code> <i>可赋予</i> 类型为 <code>T</code> 的变量
（"<code>x</code> 可赋予 <code>T</code>"）：
</p>

<div class="english">
<ul>
<li>
<code>x</code>'s type is identical to <code>T</code>.
</li>
<li>
<code>x</code>'s type <code>V</code> and <code>T</code> have identical
<a href="#Types">underlying types</a> and at least one of <code>V</code>
or <code>T</code> is not a named type.
</li>
<li>
<code>T</code> is an interface type and
<code>x</code> <a href="#Interface_types">implements</a> <code>T</code>.
</li>
<li>
<code>x</code> is a bidirectional channel value, <code>T</code> is a channel type,
<code>x</code>'s type <code>V</code> and <code>T</code> have identical element types,
and at least one of <code>V</code> or <code>T</code> is not a named type.
</li>
<li>
<code>x</code> is the predeclared identifier <code>nil</code> and <code>T</code>
is a pointer, function, slice, map, channel, or interface type.
</li>
<li>
<code>x</code> is an untyped <a href="#Constants">constant</a> representable
by a value of type <code>T</code>.
</li>
</ul>
</div>

<ul>
<li>
当 <code>x</code> 的类型和 <code>T</code> 相同时。
</li>
<li>
当 <code>x</code> 的类型 <code>V</code> 和 <code>T</code> 有相同的
<a href="#类型">基本类型</a> 且在 <code>V</code> 或 <code>T</code> 中至少有一个不是已命名类型时。
<li>
当 <code>T</code> 为接口类型且 <code>x</code> <a href="#接口类型">实现</a>了 <code>T</code>时。
</li>
<li>
当 <code>x</code> 为双向信道值、<code>T</code> 为信道类型、
<code>x</code> 的类型 <code>V</code> 和 <code>T</code> 的元素类型相同且在
<code>V</code> 或 <code>T</code> 中至少有一个不是已命名类型时。
</li>
<li>
当 <code>x</code> 为预声明标识符 <code>nil</code> 且 <code>T</code>
为指针、函数、切片、映射、通道或接口类型时。
</li>
<li>
当 <code>x</code> 无类型声明的，可通过类型 <code>T</code> 的值来表示的 <a href="#常量">常量</a>时。
</li>
</ul>

<div class="english">
<p>
Any value may be assigned to the <a href="#Blank_identifier">blank identifier</a>.
</p>
</div>

<p>
任何类型都可赋予<a href="#空白标识符">空白标识符</a>.
</p>


<div class="english">
<h2 id="Blocks">Blocks</h2>
</div>

<h2 id="块">块</h2>

<div class="english">
<p>
A <i>block</i> is a sequence of declarations and statements within matching
brace brackets.
</p>
</div>

<p>
<i>块</i> 为一对大括号括住的声明和语句。
</p>

<div class="english">
<pre class="ebnf">
Block = "{" { Statement ";" } "}" .
</pre>
</div>

<pre class="ebnf">
块 = "{" { 语句 ";" } "}" .
</pre>

<div class="english">
<p>
In addition to explicit blocks in the source code, there are implicit blocks:
</p>
</div>

<p>
除显式源码块外，还有隐式块：
</p>

<div class="english">
<ol>
	<li>The <i>universe block</i> encompasses all Go source text.</li>

	<li>Each <a href="#Packages">package</a> has a <i>package block</i> containing all
	    Go source text for that package.</li>

	<li>Each file has a <i>file block</i> containing all Go source text
	    in that file.</li>

	<li>Each <code>if</code>, <code>for</code>, and <code>switch</code>
	    statement is considered to be in its own implicit block.</li>

	<li>Each clause in a <code>switch</code> or <code>select</code> statement
	    acts as an implicit block.</li>
</ol>
</div>

<ol>
	<li><i>全域块</i> 包含所有的Go源码文本。</li>

	<li>每个<a href="#包">包</a>都有包含其所有Go源码文本的 <i>包块</i>。</li>

	<li>每个文件都有包含其所有Go源码文本的 <i>文件块</i>。</li>

	<li>每个 <code>if</code>、<code>for</code> 和
		<code>switch</code> 语句都被视为处于其自身的隐式块中。</li>

	<li>每个 <code>switch</code> 或 <code>select</code> 语句中的子句其行为如同隐式块。</li>
</ol>

<div class="english">
<p>
Blocks nest and influence <a href="#Declarations_and_scope">scoping</a>.
</p>
</div>

<p>
块嵌套并影响 <a href="#声明与作用域">作用域</a>。
</p>


<div class="english">
<h2 id="Declarations_and_scope">Declarations and scope</h2>
</div>

<h2 id="声明与作用域">声明与作用域</h2>

<div class="english">
<p>
A declaration binds a non-<a href="#Blank_identifier">blank</a>
identifier to a constant, type, variable, function, or package.
Every identifier in a program must be declared.
No identifier may be declared twice in the same block, and
no identifier may be declared in both the file and package block.
</p>
</div>

<p>
声明可将非<a href="#空白标识符">空白</a>标识符绑定到一个常量、类型、变量、函数或包。
在程序中，每个标识符都必须被声明。同一标识符不能在同一块中声明两次，且在文件与包块中不能同时声明。
</p>

<div class="english">
<pre class="ebnf">
Declaration   = ConstDecl | TypeDecl | VarDecl .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
</pre>
</div>

<pre class="ebnf">
声明 = 常量声明 | 类型声明 | 变量声明 .
顶级声明 = 声明 | 函数声明 | 方法声明 .
</pre>

<div class="english">
<p>
The <i>scope</i> of a declared identifier is the extent of source text in which
the identifier denotes the specified constant, type, variable, function, or package.
</p>
</div>

<p>
已声明标识符的 <i>作用域</i> 即为该标识符所表示的具体常量、类型、变量、函数或包在源文本中的作用范围。
</p>

<div class="english">
<p>
Go is lexically scoped using blocks:
</p>
</div>

<p>
Go使用块表示词法作用域：
</p>

<div class="english">
<ol>
	<li>The scope of a predeclared identifier is the universe block.</li>

	<li>The scope of an identifier denoting a constant, type, variable,
	    or function (but not method) declared at top level (outside any
	    function) is the package block.</li>

	<li>The scope of an imported package identifier is the file block
	    of the file containing the import declaration.</li>

	<li>The scope of an identifier denoting a function parameter or
	    result variable is the function body.</li>

	<li>The scope of a constant or variable identifier declared
	    inside a function begins at the end of the ConstSpec or VarSpec
	    (ShortVarDecl for short variable declarations)
	    and ends at the end of the innermost containing block.</li>

	<li>The scope of a type identifier declared inside a function
	    begins at the identifier in the TypeSpec
	    and ends at the end of the innermost containing block.</li>
</ol>
</div>

<ol>
	<li>预声明标识符的作用域为全域块。</li>

	<li>在顶级（即在任何函数之外）声明的表示常量、类型、变量或函数
		（而非方法）的标识符其作用域为该包块。</li>

	<li>已导入包的标识符其作用域为包含导入声明的文件块。</li>

	<li>表示函数参数或返回值变量的标识符其作用域为该函数体。</li>

	<li>在函数中声明为常量或变量的标识符，其作用域始于该函数中具体常量实现或变量实现
		（ShortVarDecl表示短变量声明）的结尾，止于最内部包含块的结尾。</li>

	<li>在函数中声明为类型的标识符，其作用域始于该函数中具体类型实现的标识符，
		止于最内部包含块的结尾。</li>
</ol>

<div class="english">
<p>
An identifier declared in a block may be redeclared in an inner block.
While the identifier of the inner declaration is in scope, it denotes
the entity declared by the inner declaration.
</p>
</div>

<p>
在块中声明的标识符可在其内部块中重新声明。
当其内部声明的标识符在作用域中时，即表示其实体在该内部声明中声明。
</p>

<div class="english">
<p>
The <a href="#Package_clause">package clause</a> is not a declaration; the package name
does not appear in any scope. Its purpose is to identify the files belonging
to the same <a href="#Packages">package</a> and to specify the default package name for import
declarations.
</p>
</div>

<p>
<a href="#包子句">包子句</a>并非声明；包名不会出现在任何作用域中。
其目的是为了识别该文件是否属于相同的<a href="#包">包</a>并为导入声明指定默认包名。
</p>


<div class="english">
<h3 id="Label_scopes">Label scopes</h3>
</div>

<h3 id="标签作用域">标签作用域</h3>

<div class="english">
<p>
Labels are declared by <a href="#Labeled_statements">labeled statements</a> and are
used in the <code>break</code>, <code>continue</code>, and <code>goto</code>
statements (§<a href="#Break_statements">Break statements</a>, §<a href="#Continue_statements">Continue statements</a>, §<a href="#Goto_statements">Goto statements</a>).
It is illegal to define a label that is never used.
In contrast to other identifiers, labels are not block scoped and do
not conflict with identifiers that are not labels. The scope of a label
is the body of the function in which it is declared and excludes
the body of any nested function.
</p>
</div>

<p>
标签通过<a href="#标签语句">标签语句</a>声明，并用于 <code>break</code>、<code>continue</code>
和 <code>goto</code> 语句（§<a href="#Break语句">Break语句</a>,
§<a href="#Continue语句">Continue语句</a>, §<a href="#Goto语句">Goto语句</a>）。
定义不会使用的标签是非法的。与其它标识符相反，标签并不限定作用域且与非标签标识符并不冲突。
标签的作用域为除任何嵌套函数体外其声明的函数体。
</p>


<div class="english">
<h3 id="Blank_identifier">Blank identifier</h3>
</div>

<h3 id="空白标识符">空白标识符</h3>

<div class="english">
<p>
The <i>blank identifier</i>, represented by the underscore character <code>_</code>, may be used in a declaration like
any other identifier but the declaration does not introduce a new binding.
</p>
</div>

<p>
<i>空白标识符</i> 通过下划线字符 <code>_</code> 表示，
它可像其它标识符一样用于声明，但该标识符不能传入一个新的绑定。
</p>


<div class="english">
<h3 id="Predeclared_identifiers">Predeclared identifiers</h3>
</div>

<h3 id="预声明标识符">预声明标识符</h3>

<div class="english">
<p>
The following identifiers are implicitly declared in the
<a href="#Blocks">universe block</a>:
</p>
</div>

<p>
在<a href="#块">全域块</a>中，以下标识符是隐式声明的：
</p>

<div class="english">
<pre class="grammar">
Types:
	bool byte complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

Constants:
	true false iota

Zero value:
	nil

Functions:
	append cap close complex copy delete imag len
	make new panic print println real recover
</pre>
</div>

<pre class="grammar">
类型：
	bool byte complex64 complex128 error float32 float64
	int int8 int16 int32 int64 rune string
	uint uint8 uint16 uint32 uint64 uintptr

常量：
	true false iota

零值：
	nil

函数：
	append cap close complex copy delete imag len
	make new panic print println real recover
</pre>


<div class="english">
<h3 id="Exported_identifiers">Exported identifiers</h3>
</div>

<h3 id="已导出标识符">已导出标识符</h3>

<div class="english">
<p>
An identifier may be <i>exported</i> to permit access to it from another package.
An identifier is exported if both:
</p>
</div>

<p>
标识符可被 <i>导出</i> 以允许从另一个包访问。同时符合以下条件即为已导出标识符：
</p>

<div class="english">
<ol>
	<li>the first character of the identifier's name is a Unicode upper case
	letter (Unicode class "Lu"); and</li>
	<li>the identifier is declared in the <a href="#Blocks">package block</a>
	or it is a <a href="#Struct_types">field name</a> or
	<a href="#MethodName">method name</a>.</li>
</ol>
<p>
All other identifiers are not exported.
</p>
</div>

<ol>
	<li>标识符名的第一个字符为Unicode大写字母（Unicode类别“Lu”）；且</li>
	<li>该标识符在<a href="#块">包块</a>中已声明或为<a href="#结构类型">字段名</a>或
	<a href="#方法名">方法名</a>。</li>
</ol>
<p>
其它所有标识符均为未导出的。
</p>


<div class="english">
<h3 id="Uniqueness_of_identifiers">Uniqueness of identifiers</h3>
</div>

<h3 id="标识符的唯一性">标识符的唯一性</h3>

<div class="english">
<p>
Given a set of identifiers, an identifier is called <i>unique</i> if it is
<i>different</i> from every other in the set.
Two identifiers are different if they are spelled differently, or if they
appear in different <a href="#Packages">packages</a> and are not
<a href="Exported_identifiers">exported</a>. Otherwise, they are the same.
</p>
</div>

<p>
给定一个标识符集，若其中一个标识符<i>不同于</i>该集中的任一标识符，那么它就是<i>唯一的</i>。
若两个标识符拼写不同，或它们出现在不同的<a href="#包">包</a>中且未
<a href="已导出标识符">导出</a>，那么它们就是不同的。否则，它们就是相同的。
</p>

<div class="english">
<h3 id="Constant_declarations">Constant declarations</h3>
</div>

<h3 id="常量声明">常量声明</h3>

<div class="english">
<p>
A constant declaration binds a list of identifiers (the names of
the constants) to the values of a list of <a href="#Constant_expressions">constant expressions</a>.
The number of identifiers must be equal
to the number of expressions, and the <i>n</i>th identifier on
the left is bound to the value of the <i>n</i>th expression on the
right.
</p>
</div>

<p>
常量声明将一个标识符（即常量名）列表绑定至一个<a href="#常量表达式">常量表达式</a>列表的值。
标识符的数量必须与表达式的数量相等，且左边第 <i>n</i> 个标识符会绑定至右边的第 <i>n</i> 个表达式的值。
</p>

<div class="english">
<pre class="ebnf">
ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .

IdentifierList = identifier { "," identifier } .
ExpressionList = Expression { "," Expression } .
</pre>
</div>

<pre class="ebnf">
常量声明   = "const" ( 常量实现 | "(" { 常量实现 ";" } ")" ) .
常量实现   = 标识符列表 [ [ 类型 ] "=" 表达式列表 ] .

标识符列表 = 标识符 { "," 标识符 } .
表达式列表 = 表达式 { "," 表达式 } .
</pre>

<div class="english">
<p>
If the type is present, all constants take the type specified, and
the expressions must be <a href="#Assignability">assignable</a> to that type.
If the type is omitted, the constants take the
individual types of the corresponding expressions.
If the expression values are untyped <a href="#Constants">constants</a>,
the declared constants remain untyped and the constant identifiers
denote the constant values. For instance, if the expression is a
floating-point literal, the constant identifier denotes a floating-point
constant, even if the literal's fractional part is zero.
</p>
</div>

<p>
若该类型存在，所有常量都将获得该类型实现，且该表达式对于该类型必须是
<a href="#可赋值性">可赋值</a>的。若该类型被省略，则该常量将获得其对应表达式的具体类型。
若该表达式值为无类型声明<a href="#常量">常量</a>，则其余已声明无类型常量与该常量标识符表示其常量值。
例如，若该表达式为浮点数字面，则该常量标识符表示一个浮点数常量，即使该字面的小数部分为零。
</p>

<div class="english">
<pre>
const Pi float64 = 3.14159265358979323846
const zero = 0.0         // untyped floating-point constant
const (
	size int64 = 1024
	eof        = -1  // untyped integer constant
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", untyped integer and string constants
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
</pre>
</div>

<pre>
const Pi float64 = 3.14159265358979323846
const zero = 0.0       // 无类型声明浮点常量
const (
	size int64 = 1024
	eof        = -1    // 无类型声明整数常量
)
const a, b, c = 3, 4, "foo"  // a = 3, b = 4, c = "foo", 无类型声明整数和字符串常量
const u, v float32 = 0, 3    // u = 0.0, v = 3.0
</pre>

<div class="english">
<p>
Within a parenthesized <code>const</code> declaration list the
expression list may be omitted from any but the first declaration.
Such an empty list is equivalent to the textual substitution of the
first preceding non-empty expression list and its type if any.
Omitting the list of expressions is therefore equivalent to
repeating the previous list.  The number of identifiers must be equal
to the number of expressions in the previous list.
Together with the <a href="#Iota"><code>iota</code> constant generator</a>
this mechanism permits light-weight declaration of sequential values:
</p>
</div>

<p>
在 <code>const</code> 后括号中的声明列表，除第一句声明外，任何表达式列表都可省略。
若前面第一个非空表达式有类型，那么这样的空列表等价于该表达式原文和类型的代换。
因此，省略表达式的列表等价于重复前面的列表。其标识符的数量必须与上一个表达式的数量相等。
连同 <a href="#Iota"><code>iota</code> 常量生成器</a>，该机制允许轻量级连续值声明：
</p>

<div class="english">
<pre>
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Partyday
	numberOfDays  // this constant is not exported
)
</pre>
</div>

<pre>
const (
	Sunday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Partyday
	numberOfDays  // 该常量未导出
)
</pre>


<h3 id="Iota">Iota</h3>

<div class="english">
<p>
Within a <a href="#Constant_declarations">constant declaration</a>, the predeclared identifier
<code>iota</code> represents successive untyped integer <a href="#Constants">
constants</a>. It is reset to 0 whenever the reserved word <code>const</code>
appears in the source and increments after each <a href="#ConstSpec">ConstSpec</a>.
It can be used to construct a set of related constants:
</p>
</div>

<p>
在<a href="#常量声明">常量声明</a>中预声明标识符 <code>iota</code> 表示连续的无类型声明整数
<a href="#常量">常量</a>。每当保留字 <code>const</code> 出现在源码中和每个
<a href="#常量实现">常量实现</a>增量后，它都会被重置为0。它可被用来构造相关常量的集：
</p>

<div class="english">
<pre>
const (  // iota is reset to 0
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const (
	a = 1 &lt;&lt; iota  // a == 1 (iota has been reset)
	b = 1 &lt;&lt; iota  // b == 2
	c = 1 &lt;&lt; iota  // c == 4
)

const (
	u         = iota * 42  // u == 0     (untyped integer constant)
	v float64 = iota * 42  // v == 42.0  (float64 constant)
	w         = iota * 42  // w == 84    (untyped integer constant)
)

const x = iota  // x == 0 (iota has been reset)
const y = iota  // y == 0 (iota has been reset)
</pre>
</div>

<pre>
const (  // iota重置为0
	c0 = iota  // c0 == 0
	c1 = iota  // c1 == 1
	c2 = iota  // c2 == 2
)

const (
	a = 1 &lt;&lt; iota  // a == 1 （iota已重置）
	b = 1 &lt;&lt; iota  // b == 2
	c = 1 &lt;&lt; iota  // c == 4
)

const (
	u         = iota * 42  // u == 0     （无类型声明整数常量）
	v float64 = iota * 42  // v == 42.0  （float64常量）
	w         = iota * 42  // w == 84    （无类型声明整数常量）
)

const x = iota  // x == 0 （iota已重置）
const y = iota  // y == 0 （iota已重置）
</pre>

<div class="english">
<p>
Within an ExpressionList, the value of each <code>iota</code> is the same because
it is only incremented after each ConstSpec:
</p>
</div>

<p>
在表达式列表中，每个 <code>iota</code> 的值都相同，因为它只在每个常量实现后增量。
</p>

<div class="english">
<pre>
const (
	bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1  // bit0 == 1, mask0 == 0
	bit1, mask1                           // bit1 == 2, mask1 == 1
	_, _                                  // skips iota == 2
	bit3, mask3                           // bit3 == 8, mask3 == 7
)
</pre>
</div>

<pre>
const (
	bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1  // bit0 == 1, mask0 == 0
	bit1, mask1                           // bit1 == 2, mask1 == 1
	_, _                                  // 跳过 iota == 2
	bit3, mask3                           // bit3 == 8, mask3 == 7
)
</pre>

<div class="english">
<p>
This last example exploits the implicit repetition of the
last non-empty expression list.
</p>
</div>

<p>
最后一个例子采用上一个非空表达式列表的隐式副本。
</p>


<div class="english">
<h3 id="Type_declarations">Type declarations</h3>
</div>

<h3 id="类型声明">类型声明</h3>

<div class="english">
<p>
A type declaration binds an identifier, the <i>type name</i>, to a new type
that has the same <a href="#Types">underlying type</a> as
an existing type.  The new type is <a href="#Type_identity">different</a> from
the existing type.
</p>
</div>

<p>
类型声明将标识符、<i>类型名</i> 绑定至一个与现存类型有相同的
<a href="#类型标识">基本类型</a>的新类型。新类型<a href="#类型">不同</a>于现有类型。
</p>

<div class="english">
<pre class="ebnf">
TypeDecl     = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
TypeSpec     = identifier Type .
</pre>
</div>

<pre class="ebnf">
类型声明     = "type" ( 类型实现 | "(" { 类型实现 ";" } ")" ) .
类型实现     = 标识符 类型 .
</pre>

<pre>
type IntArray [16]int

type (
	Point struct{ x, y float64 }
	Polar Point
)

type TreeNode struct {
	left, right *TreeNode
	value *Comparable
}

type Block interface {
	BlockSize() int
	Encrypt(src, dst []byte)
	Decrypt(src, dst []byte)
}
</pre>

<div class="english">
<p>
The declared type does not inherit any <a href="#Method_declarations">methods</a>
bound to the existing type, but the <a href="#Method_sets">method set</a>
of an interface type or of elements of a composite type remains unchanged:
</p>
</div>

<p>
声明类型不继承任何<a href="#方法声明">方法</a>绑定到现存类型，
但接口类型或复合类型元素的<a href="#方法集">方法集</a>保持不变：
</p>

<div class="english">
<pre>
// A Mutex is a data type with two methods, Lock and Unlock.
type Mutex struct         { /* Mutex fields */ }
func (m *Mutex) Lock()    { /* Lock implementation */ }
func (m *Mutex) Unlock()  { /* Unlock implementation */ }

// NewMutex has the same composition as Mutex but its method set is empty.
type NewMutex Mutex

// The method set of the <a href="#Pointer_types">base type</a> of PtrMutex remains unchanged,
// but the method set of PtrMutex is empty.
type PtrMutex *Mutex

// The method set of *PrintableMutex contains the methods
// Lock and Unlock bound to its anonymous field Mutex.
type PrintableMutex struct {
	Mutex
}

// MyBlock is an interface type that has the same method set as Block.
type MyBlock Block
</pre>
</div>

<pre>
// Mutex为带有Lock和Unlock两个方法的数据类型.
type Mutex struct         { /* Mutex字段 */ }
func (m *Mutex) Lock()    { /* Lock实现*/ }
func (m *Mutex) Unlock()  { /* Unlock实现*/ }

// NewMutex和Mutex拥有相同的组成，但它的方法集为空.
type NewMutex Mutex

// PtrMutex的<a href="#指针类型">基本类型</a>的方法集保持不变.
// 但PtrMutex的方法集为空.
type PtrMutex *Mutex

// *PrintableMutex的方法集包含方法
// Lock和Unlock绑定至其匿名字段Mutex.
type PrintableMutex struct {
	Mutex
}

// MyBlock为与Block拥有相同方法集的接口类型.
type MyBlock Block
</pre>

<div class="english">
<p>
A type declaration may be used to define a different boolean, numeric, or string
type and attach methods to it:
</p>
</div>

<p>
类型声明可用来定义不同的布尔值、数字或字符串类型并对其附上方法：
</p>

<pre>
type TimeZone int

const (
	EST TimeZone = -(5 + iota)
	CST
	MST
	PST
)

func (tz TimeZone) String() string {
	return fmt.Sprintf("GMT+%dh", tz)
}
</pre>


<div class="english">
<h3 id="Variable_declarations">Variable declarations</h3>
</div>

<h3 id="变量声明">变量声明</h3>

<div class="english">
<p>
A variable declaration creates a variable, binds an identifier to it and
gives it a type and optionally an initial value.
</p>
</div>

<p>
变量声明将一个标识符绑定至一个创建的变量并赋予其类型和可选的初始值。
</p>

<div class="english">
<pre class="ebnf">
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
</pre>
</div>

<pre class="ebnf">
变量声明     = "var" ( 变量实现 | "(" { 变量实现 ";" } ")" ) .
变量实现     = 标识符列表 ( 类型 [ "=" 表达式类表 ] | "=" 表达式列表 ) .
</pre>

<div class="english">
<pre>
var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
	i       int
	u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // map lookup; only interested in "found"
</pre>
</div>

<pre>
var i int
var U, V, W float64
var k = 0
var x, y float32 = -1, -2
var (
	i       int
	u, v, s = 2.0, 3.0, "bar"
)
var re, im = complexSqrt(-1)
var _, found = entries[name]  // 映射检查；只与“found”有关
</pre>

<div class="english">
<p>
If a list of expressions is given, the variables are initialized
by assigning the expressions to the variables (§<a href="#Assignments">Assignments</a>)
in order; all expressions must be consumed and all variables initialized from them.
Otherwise, each variable is initialized to its <a href="#The_zero_value">zero value</a>.
</p>
</div>

<p>
若给定一个表达式列表，则变量通过按顺序将该表达式赋予该变量（§<a href="#赋值">赋值</a>）来初始化；
所有表达式必须用尽且所有变量根据他们初始化。否则，每个变量初始化为其 <a href="#零值">零值</a>。
</p>

<div class="english">
<p>
If the type is present, each variable is given that type.
Otherwise, the types are deduced from the assignment
of the expression list.
</p>
</div>

<p>
若该类型已存在，每个变量都赋予该类型。否则，该类型根据该表达式列表赋值。
</p>

<div class="english">
<p>
If the type is absent and the corresponding expression evaluates to an
untyped <a href="#Constants">constant</a>, the type of the declared variable
is as described in §<a href="#Assignments">Assignments</a>.
</p>
</div>

<p>
若该类型不存在且其对应表达式计算结果为无类型定义<a href="#常量">常量</a>，
则该声明变量的类型由其§<a href="#赋值">赋值</a>描述。
</p>

<div class="english">
<p>
Implementation restriction: A compiler may make it illegal to declare a variable
inside a <a href="#Function_declarations">function body</a> if the variable is
never used.
</p>
</div>

<p>
实现限制：若在<a href="#函数声明">函数体</a>内声明不会使用的变量，编译器可能将其判定为非法。
</p>

<div class="english">
<h3 id="Short_variable_declarations">Short variable declarations</h3>
</div>

<h3 id="短变量声明">短变量声明</h3>

<div class="english">
<p>
A <i>short variable declaration</i> uses the syntax:
</p>
</div>

<p>
<i>短变量声明</i> 使用此语法：
</p>

<div class="english">
<pre class="ebnf">
ShortVarDecl = IdentifierList ":=" ExpressionList .
</pre>
</div>

<pre class="ebnf">
短变量声明 = 标识符列表 ":=" 表达式列表 .
</pre>

<div class="english">
<p>
It is a shorthand for a regular <a href="#Variable_declarations">variable declaration</a>
with initializer expressions but no types:
</p>
</div>

<p>
它是有初始化表达式无类型声明的常规<a href="#变量声明">变量声明</a>的缩写：
</p>

<div class="english">
<pre class="grammar">
"var" IdentifierList = ExpressionList .
</pre>
</div>

<pre class="grammar">
"var" 标识符列表 = 表达式列表 .
</pre>

<div class="english">
<pre>
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w := os.Pipe(fd)  // os.Pipe() returns two values
_, y, _ := coord(p)  // coord() returns three values; only interested in y coordinate
</pre>
</div>

<pre>
i, j := 0, 10
f := func() int { return 7 }
ch := make(chan int)
r, w := os.Pipe(fd)  // os.Pipe() 返回两个值
_, y, _ := coord(p)  // coord() 返回三个值；只与和y同位的值相关
</pre>

<div class="english">
<p>
Unlike regular variable declarations, a short variable declaration may redeclare variables provided they
were originally declared in the same block with the same type, and at
least one of the non-<a href="#Blank_identifier">blank</a> variables is new.  As a consequence, redeclaration
can only appear in a multi-variable short declaration.
Redeclaration does not introduce a new
variable; it just assigns a new value to the original.
</p>
</div>

<p>
不同于常规变量声明，在至少有一个非<a href="#Blank_identifier">空白</a>变量时，
短变量声明可在相同块中对原来声明的变量以相同的类型重声明。因此，重声明只能出现在多变量短声明中。
重声明不能生成新的变量；它只能赋予新的值给原来的变量。
</p>

<div class="english">
<pre>
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // redeclares offset
</pre>
</div>

<pre>
field1, offset := nextField(str, 0)
field2, offset := nextField(str, offset)  // 重声明 offset
</pre>

<div class="english">
<p>
Short variable declarations may appear only inside functions.
In some contexts such as the initializers for <code>if</code>,
<code>for</code>, or <code>switch</code> statements,
they can be used to declare local temporary variables (§<a href="#Statements">Statements</a>).
</p>
</div>

<p>
短变量声明只能出现在函数内部。在某些情况下，例如初始化 <code>if</code>、
<code>for</code>、或 <code>switch</code> 语句时，它们可用来声明局部临时变量
（§<a href="#语句">语句</a>）。
</p>

<div class="english">
<h3 id="Function_declarations">Function declarations</h3>
</div>

<h3 id="函数声明">函数声明</h3>

<div class="english">
<p>
A function declaration binds an identifier, the <i>function name</i>,
to a function.
</p>
</div>

<p>
函数声明将标识符，即 <i>函数名</i> 绑定至函数。
</p>

<div class="english">
<pre class="ebnf">
FunctionDecl = "func" FunctionName Signature [ Body ] .
FunctionName = identifier .
Body         = Block .
</pre>
</div>

<pre class="ebnf">
函数声明 = "func" 函数名 签名 [ 函数体 ] .
函数名   = 标识符 .
函数体   = 块 .
</pre>

<div class="english">
<p>
A function declaration may omit the body. Such a declaration provides the
signature for a function implemented outside Go, such as an assembly routine.
</p>
</div>

<p>
函数声明可省略函数体。这样的标识符为Go外部实现的函数提供签名，例如汇编例程。
</p>

<div class="english">
<pre>
func min(x int, y int) int {
	if x &lt; y {
		return x
	}
	return y
}

func flushICache(begin, end uintptr)  // implemented externally
</pre>
</div>

<pre>
func min(x int, y int) int {
	if x &lt; y {
		return x
	}
	return y
}

func flushICache(begin, end uintptr)  // 外部实现
</pre>

<div class="english">
<h3 id="Method_declarations">Method declarations</h3>
</div>

<h3 id="方法声明">方法声明</h3>

<div class="english">
<p>
A method is a function with a <i>receiver</i>.
A method declaration binds an identifier, the <i>method name</i>, to a method.
It also associates the method with the receiver's <i>base type</i>.
</p>
</div>

<p>
方法为带 <i>接收器</i> 的函数。方法声明将标识符，即 <i>方法名</i> 绑定至方法。
它也将该接收器的 <i>基础类型</i> 关联至该方法。
</p>

<div class="english">
<pre class="ebnf">
MethodDecl   = "func" Receiver MethodName Signature [ Body ] .
Receiver     = "(" [ identifier ] [ "*" ] BaseTypeName ")" .
BaseTypeName = identifier .
</pre>
</div>

<pre class="ebnf">
方法声明   = "func" 接收器 方法名 签名 [ 函数体 ] .
接收器     = "(" [ 标志符 ] [ "*" ] 基础类型名 ")" .
基础类型名 = 标志符 .
</pre>

<div class="english">
<p>
The receiver type must be of the form <code>T</code> or <code>*T</code> where
<code>T</code> is a type name. The type denoted by <code>T</code> is called
the receiver <i>base type</i>; it must not be a pointer or interface type and
it must be declared in the same package as the method.
The method is said to be <i>bound</i> to the base type and the method name
is visible only within selectors for that type.
</p>
</div>

<p>
接收器类型必须为形式 <code>T</code> 或 <code>*T</code>，其中 <code>T</code> 为类型名。
由 <code>T</code> 表示的类型称为接收器的 <i>基础类型</i>；
它不能为指针或接口类型且必须在同一包中声明为方法。
也就是说，该方法被 <i>绑定</i> 至基础类型且该方法名只对其内部此类型选择器可见。
</p>

<div class="english">
<p>
For a base type, the non-<a href="#Blank_identifier">blank</a> names of
methods bound to it must be <a href="#Uniqueness_of_identifiers">unique</a>.
If the base type is a <a href="#Struct_types">struct type</a>,
the non-blank method and field names must be distinct.
</p>
</div>

<p>
对于基础类型，方法绑定至该类型的非<a href="#空白标识符">空白</a>名必须
<a href="#标识符的唯一性">唯一</a>。
若其基础类型为<a href="#结构类型">结构类型</a>，则非空白方法与字段名不能相同。
</p>

<div class="english">
<p>
Given type <code>Point</code>, the declarations
</p>
</div>

<p>
给定 <code>Point</code> 类型，声明
</p>

<pre>
func (p *Point) Length() float64 {
	return math.Sqrt(p.x * p.x + p.y * p.y)
}

func (p *Point) Scale(factor float64) {
	p.x *= factor
	p.y *= factor
}
</pre>

<div class="english">
<p>
bind the methods <code>Length</code> and <code>Scale</code>,
with receiver type <code>*Point</code>,
to the base type <code>Point</code>.
</p>
</div>

<p>
将接收器类型为 <code>*Point</code> 的方法 <code>Length</code>
和 <code>Scale</code> 绑定至基础类型 <code>Point</code>。
</p>

<div class="english">
<p>
If the receiver's value is not referenced inside the body of the method,
its identifier may be omitted in the declaration. The same applies in
general to parameters of functions and methods.
</p>
</div>

<p>
若该接收器的值在该方法体中未被引用，它的标识符会在该声明中被忽略。
这同样适用于一般的函数和方法的参数。
</p>

<div class="english">
<p>
The type of a method is the type of a function with the receiver as first
argument.  For instance, the method <code>Scale</code> has type
</p>
</div>

<p>
方法的类型就是将接收者作为第一个参数的函数类型。例如，方法 <code>Scale</code> 拥有类型
</p>

<pre>
func(p *Point, factor float64)
</pre>

<div class="english">
<p>
However, a function declared this way is not a method.
</p>
</div>

<p>
然而，通过这种方式声明的函数不是方法。
</p>


<div class="english">
<h2 id="Expressions">Expressions</h2>
</div>

<h2 id="表达式">表达式</h2>

<div class="english">
<p>
An expression specifies the computation of a value by applying
operators and functions to operands.
</p>
</div>

<p>
表达式通过将运算符和函数应用至操作数来指定值的计算。
</p>

<div class="english">
<h3 id="Operands">Operands</h3>
</div>

<h3 id="操作数">操作数</h3>

<div class="english">
<p>
Operands denote the elementary values in an expression.
</p>
</div>

<p>
操作数表示表达式中的基本值。
</p>

<div class="english">
<pre class="ebnf">
Operand    = Literal | QualifiedIdent | MethodExpr | "(" Expression ")" .
Literal    = BasicLit | CompositeLit | FunctionLit .
BasicLit   = int_lit | float_lit | imaginary_lit | char_lit | string_lit .
</pre>
</div>

<pre class="ebnf">
操作数   = 字面 | 限定标识符 | 方法表达式 | "(" 表达式 ")" .
字面     = 基本字面 | 复合字面 | 函数字面 .
基本字面 = 整数字面 | 浮点数字面 | 虚数字面 | 字符字面 | 字符串字面 .
</pre>


<div class="english">
<h3 id="Qualified_identifiers">Qualified identifiers</h3>
</div>

<h3 id="限定标识符">限定标识符</h3>

<div class="english">
<p>
A qualified identifier is a non-<a href="#Blank_identifier">blank</a> identifier
qualified by a package name prefix.
</p>
</div>

<p>
限定标识符为通过包名前缀限定的非<a href="#空白标识符">空白</a>标志符
</p>

<div class="english">
<pre class="ebnf">
QualifiedIdent = [ PackageName "." ] identifier .
</pre>
</div>

<pre class="ebnf">
限定标识符 = [ 包名 "." ] 标识符 .
</pre>

<div class="english">
<p>
A qualified identifier accesses an identifier in a different package, which
must be <a href="#Import_declarations">imported</a>.
The identifier must be <a href="#Exported_identifiers">exported</a> and
declared in the <a href="#Blocks">package block</a> of that package.
</p>
</div>

<p>
限定标识符用于访问另一个包中的标识符，它必须被<a href="#导入声明">导入</a>。
标识符必须是已<a href="#已导出标识符">导出</a>且在该包的<a href="#块">包块</a>中声明。
</p>

<div class="english">
<pre>
math.Sin	// denotes the Sin function in package math
</pre>
</div>

<pre>
math.Sin	// 表示math包中的Sin函数
</pre>

<div class="english">
<h3 id="Composite_literals">Composite literals</h3>
</div>

<h3 id="复合字面">复合字面</h3>

<div class="english">
<p>
Composite literals construct values for structs, arrays, slices, and maps
and create a new value each time they are evaluated.
They consist of the type of the value
followed by a brace-bound list of composite elements. An element may be
a single expression or a key-value pair.
</p>
</div>

<p>
复合字面每次为结构、数组、切片、映射构造值，或创建一个新值时，它们都会被求值。
它们由值的类型后跟一个大括号括住的列表组成。元素可为单个表达式或一个键-值对。
</p>

<div class="english">
<pre class="ebnf">
CompositeLit  = LiteralType LiteralValue .
LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType |
                SliceType | MapType | TypeName .
LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
ElementList   = Element { "," Element } .
Element       = [ Key ":" ] Value .
Key           = FieldName | ElementIndex .
FieldName     = identifier .
ElementIndex  = Expression .
Value         = Expression | LiteralValue .
</pre>
</div>

<pre class="ebnf">
复合字面 = 字面类型 字面值 .
字面类型 = 结构类型 | 数组类型 | "[" "..." "]" 元素类型 |
           切片类型 | 映射类型 | 类型名 .
字面值   = "{" [ 元素列表 [ "," ] ] "}" .
元素列表 = 元素 { "," 元素 } .
元素     = [ 键 ":" ] 值 .
键       = 字段名 | 元素索引 .
字段名   = 标识符 .
元素索引 = 表达式 .
值       = 表达式 | 字面值 .
</pre>

<div class="english">
<p>
The LiteralType must be a struct, array, slice, or map type
(the grammar enforces this constraint except when the type is given
as a TypeName).
The types of the expressions must be <a href="#Assignability">assignable</a>
to the respective field, element, and key types of the LiteralType;
there is no additional conversion.
The key is interpreted as a field name for struct literals,
an index expression for array and slice literals, and a key for map literals.
For map literals, all elements must have a key. It is an error
to specify multiple elements with the same field name or
constant key value.
</p>
</div>

<p>
字面类型必须为结构、数组、切片或映射类型（语法规则强制实施此约束，除非该类型作为类型名给定）。
表达式的类型对于其各自的字段、元素以及该字面类型的键类型必须为<a href="#可赋值性">可赋值</a>的，
即没有附加转换。作为结构字面的字段名，即数组和切片的索引表达式以及映射字面的键，其键是可解译的。
对于映射字面，所有元素都必须有键。指定多个具有相同字段名或常量键值的元素会产生一个错误。
</p>

<div class="english">
<p>
For struct literals the following rules apply:
</p>
</div>

<p>
以下规则适用于结构字面：
</p>

<div class="english">
<ul>
	<li>A key must be a field name declared in the LiteralType.
	</li>
	<li>A literal that does not contain any keys must
	    list an element for each struct field in the
	    order in which the fields are declared.
	</li>
	<li>If any element has a key, every element must have a key.
	</li>
	<li>A literal that contains keys does not need to
	    have an element for each struct field. Omitted fields
	    get the zero value for that field.
	</li>
	<li>A literal may omit the element list; such a literal evaluates
		to the zero value for its type.
	</li>
	<li>It is an error to specify an element for a non-exported
	    field of a struct belonging to a different package.
	</li>
</ul>
</div>

<ul>
	<li>键必须为字面类型中声明的字段名。</li>

	<li>不包含任何键的字面必须按字段的声明顺序列出每个结构字段的元素。</li>

	<li>若其中任何一个元素有键，那么每个元素都必须有键。</li>

	<li>包含键的字面无需每个结构字段都有元素。被忽略的字段会获得零值</li>

	<li>字面可忽略元素列表；这样的字面对其类型求值为零值。</li>

	<li>为属于不同包的结构的非已导出字段指定一个元素会产生一个错误。</li>
</ul>

<div class="english">
<p>
Given the declarations
</p>
</div>

<p>
给定声明
</p>

<pre>
type Point3D struct { x, y, z float64 }
type Line struct { p, q Point3D }
</pre>

<div class="english">
<p>
one may write
</p>
</div>

<p>
可写为
</p>

<div class="english">
<pre>
origin := Point3D{}                            // zero value for Point3D
line := Line{origin, Point3D{y: -4, z: 12.3}}  // zero value for line.q.x
</pre>
</div>

<pre>
origin := Point3D{}                            // Point3D 为零值
line := Line{origin, Point3D{y: -4, z: 12.3}}  // line.q.x 为零值
</pre>

<div class="english">
<p>
For array and slice literals the following rules apply:
</p>
</div>

<p>
以下规则适用于数组和切片字面：
</p>

<div class="english">
<ul>
	<li>Each element has an associated integer index marking
	    its position in the array.
	</li>
	<li>An element with a key uses the key as its index; the
	    key must be a constant integer expression.
	</li>
	<li>An element without a key uses the previous element's index plus one.
	    If the first element has no key, its index is zero.
	</li>
</ul>
</div>

<ul>
	<li>在数组中每个元素都有与之对应的整数下标来标明它的位置。</li>

	<li>带键的元素使用该键作为它的下标；键必须为常量整数表达式。</li>

	<li>无键的元素使用上一个元素的下标加一。若第一个元素无键，则它的下标为零。</li>
</ul>

<div class="english">
<p>
Taking the address of a composite literal (§<a href="#Address_operators">Address operators</a>)
generates a pointer to a unique instance of the literal's value.
</p>
</div>

<p>
获取复合字面的地址（§<a href="#地址操作符">地址操作符</a>）就是为字面值的唯一实例生成一个指针。
</p>

<pre>
var pointer *Point3D = &amp;Point3D{y: 1000}
</pre>

<div class="english">
<p>
The length of an array literal is the length specified in the LiteralType.
If fewer elements than the length are provided in the literal, the missing
elements are set to the zero value for the array element type.
It is an error to provide elements with index values outside the index range
of the array. The notation <code>...</code> specifies an array length equal
to the maximum element index plus one.
</p>
</div>

<p>
数组字面的长度为字面类型指定的长度。
若元素少于字面提供的长度，则缺失的元素会置为该数组元素类型的零值。
向超出数组下标范围的下标值提供元素会产生一个错误。
记号 <code>...</code> 指定一个数组，其长度等于最大元素下标加一。
</p>

<pre>
buffer := [10]string{}             // len(buffer) == 10
intSet := [6]int{1, 2, 3, 5}       // len(intSet) == 6
days := [...]string{"Sat", "Sun"}  // len(days) == 2
</pre>

<div class="english">
<p>
A slice literal describes the entire underlying array literal.
Thus, the length and capacity of a slice literal are the maximum
element index plus one. A slice literal has the form
</p>
</div>

<p>
切片字面描述全部的基本数组字面。因此，切片字面的长度和容量为其最大元素下标加一。切片字面具有形式
</p>

<pre>
[]T{x1, x2, … xn}
</pre>

<div class="english">
<p>
and is a shortcut for a slice operation applied to an array:
</p>
</div>

<p>
它是切片操作应用到数组的捷径。
</p>

<pre>
tmp := [n]T{x1, x2, … xn}
tmp[0 : n]
</pre>

<div class="english">
<p>
Within a composite literal of array, slice, or map type <code>T</code>,
elements that are themselves composite literals may elide the respective
literal type if it is identical to the element type of <code>T</code>.
Similarly, elements that are addresses of composite literals may elide
the <code>&amp;T</code> when the the element type is <code>*T</code>.
</p>
</div>

<p>
在数组、切片或映射类型 <code>T</code> 的复合字面中，若其元素本身亦为复合字面，
且该复合字面的元素类型与 <code>T</code> 的相同，则可省略其各自的元素类型。
类似地，当元素类型为 <code>*T</code> 时，若其元素为复合字面的地址，则可省略 <code>&amp;T</code>。
</p>

<div class="english">
<pre>
[...]Point{{1.5, -3.5}, {0, 0}}   // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}        // same as [][]int{[]int{1, 2, 3}, []int{4, 5}}

[...]*Point{{1.5, -3.5}, {0, 0}}  // same as [...]*Point{&amp;Point{1.5, -3.5}, &amp;Point{0, 0}}
</pre>
</div>

<pre>
[...]Point{{1.5, -3.5}, {0, 0}}   // 等价于 [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}        // 等价于 [][]int{[]int{1, 2, 3}, []int{4, 5}}

[...]*Point{{1.5, -3.5}, {0, 0}}  // 等价于 [...]*Point{&amp;Point{1.5, -3.5}, &amp;Point{0, 0}}
</pre>

<div class="english">
<p>
A parsing ambiguity arises when a composite literal using the
TypeName form of the LiteralType appears between the
<a href="#Keywords">keyword</a> and the opening brace of the block of an
"if", "for", or "switch" statement, because the braces surrounding
the expressions in the literal are confused with those introducing
the block of statements. To resolve the ambiguity in this rare case,
the composite literal must appear within
parentheses.
</p>
</div>

<p>
当复合字面使用字面类型的类型名形式时，若它出现在<a href="#关键字">关键字</a>
"if"、"for" 或 "switch" 语句及其开大括号之间，就会产生解析歧义。因为在该字面中，
表达式外围的大括号会和那些语句块前的混淆。为解决此罕见情况中的歧义，该复合字面必须出现在小括号中。
</p>

<pre>
if x == (T{a,b,c}[i]) { … }
if (x == T{a,b,c}[i]) { … }
</pre>

<div class="english">
<p>
Examples of valid array, slice, and map literals:
</p>
</div>

<p>
有效的数组、切片和映射字面的例子：
</p>

<div class="english">
<pre>
// list of prime numbers
primes := []int{2, 3, 5, 7, 9, 2147483647}

// vowels[ch] is true if ch is a vowel
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// the array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}

// frequencies in Hz for equal-tempered scale (A4 = 440Hz)
noteFrequency := map[string]float32{
	"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
	"G0": 24.50, "A0": 27.50, "B0": 30.87,
}
</pre>
</div>

<pre>
// 素数列表
primes := []int{2, 3, 5, 7, 9, 2147483647}

// 若 ch 为元音则 vowels[ch] 为 true
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// 数组 [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}

// 平均律以Hz为单位的频率（A4 = 440Hz）
noteFrequency := map[string]float32{
	"C0": 16.35, "D0": 18.35, "E0": 20.60, "F0": 21.83,
	"G0": 24.50, "A0": 27.50, "B0": 30.87,
}
</pre>


<div class="english">
<h3 id="Function_literals">Function literals</h3>
</div>

<h3 id="函数字面">函数字面</h3>

<div class="english">
<p>
A function literal represents an anonymous function.
It consists of a specification of the function type and a function body.
</p>
</div>

<p>
函数字面表示匿名函数。它由函数类型和函数体的规范组成。
</p>

<div class="english">
<pre class="ebnf">
FunctionLit = FunctionType Body .
</pre>
</div>

<pre class="ebnf">
函数字面 = 函数类型 函数体 .
</pre>

<pre>
func(a, b int, z float64) bool { return a*b &lt; int(z) }
</pre>

<div class="english">
<p>
A function literal can be assigned to a variable or invoked directly.
</p>
</div>

<p>
函数字面可赋予一个变量或直接调用。
</p>

<pre>
f := func(x, y int) int { return x + y }
func(ch chan int) { ch &lt;- ACK }(replyChan)
</pre>

<div class="english">
<p>
Function literals are <i>closures</i>: they may refer to variables
defined in a surrounding function. Those variables are then shared between
the surrounding function and the function literal, and they survive as long
as they are accessible.
</p>
</div>

<p>
<i>闭包</i> 的函数字面：它们可引用定义在外围函数中的变量。
那些变量共享于外围函数与函数字面之间，并且只要它们可访问就会继续存在。
</p>


<div class="english">
<h3 id="Primary_expressions">Primary expressions</h3>
</div>

<h3 id="主表达式">主表达式</h3>

<div class="english">
<p>
Primary expressions are the operands for unary and binary expressions.
</p>
</div>

<p>
主表达式为一元和二元表达式的操作数。
</p>

<div class="english">
<pre class="ebnf">
PrimaryExpr =
	Operand |
	Conversion |
	BuiltinCall |
	PrimaryExpr Selector |
	PrimaryExpr Index |
	PrimaryExpr Slice |
	PrimaryExpr TypeAssertion |
	PrimaryExpr Call .

Selector       = "." identifier .
Index          = "[" Expression "]" .
Slice          = "[" [ Expression ] ":" [ Expression ] "]" .
TypeAssertion  = "." "(" Type ")" .
Call           = "(" [ ArgumentList [ "," ] ] ")" .
ArgumentList   = ExpressionList [ "..." ] .
</pre>
</div>

<pre class="ebnf">
主表达式 =
	操作数 |
	强制转换 |
	内建调用 |
	主表达式 选择器 |
	主表达式 下标 |
	主表达式 切片 |
	主表达式 类型断言 |
	主表达式 调用 .

选择器   = "." 标识符 .
下标     = "[" 表达式 "]" .
切片     = "[" [ 表达式 ] ":" [ 表达式 ] "]" .
类型断言 = "." "(" 类型 ")" .
调用     = "(" [ 参数列表 [ "," ] ] ")" .
参数列表 = 表达式列表 [ "..." ] .
</pre>


<pre>
x
2
(s + ".txt")
f(3.1415, true)
Point{1, 2}
m["foo"]
s[i : j + 1]
obj.color
math.Sin
f.p[i].x()
</pre>


<div class="english">
<h3 id="Selectors">Selectors</h3>
</div>

<h3 id="选择器">选择器</h3>

<div class="english">
<p>
A primary expression of the form
</p>
</div>

<p>
形式为
</p>

<pre>
x.f
</pre>

<div class="english">
<p>
denotes the field or method <code>f</code> of the value denoted by <code>x</code>
(or sometimes <code>*x</code>; see below). The identifier <code>f</code>
is called the (field or method)
<i>selector</i>; it must not be the <a href="#Blank_identifier">blank identifier</a>.
The type of the expression is the type of <code>f</code>.
</p>
</div>

<p>
的主表达式表示 <code>x</code>（有时为 <code>*x</code>，见下）所表示的值的字段或方法 <code>f</code>。
标识符 <code>f</code> 称为（字段或方法）<i>选择器</i>，它不能为<a href="#空白标识符">空白标识符</a>。
该表达式的类型即为 <code>f</code> 的类型。
</p>

<div class="english">
<p>
A selector <code>f</code> may denote a field or method <code>f</code> of
a type <code>T</code>, or it may refer
to a field or method <code>f</code> of a nested anonymous field of
<code>T</code>.
The number of anonymous fields traversed
to reach <code>f</code> is called its <i>depth</i> in <code>T</code>.
The depth of a field or method <code>f</code>
declared in <code>T</code> is zero.
The depth of a field or method <code>f</code> declared in
an anonymous field <code>A</code> in <code>T</code> is the
depth of <code>f</code> in <code>A</code> plus one.
</p>
</div>

<p>
选择器 <code>f</code> 可代表类型为 <code>T</code> 的字段或方法 <code>f</code>，
或引用 <code>T</code> 中嵌套匿名字段的字段或方法 <code>f</code>。
在 <code>T</code> 中遍历区域 <code>f</code> 的匿名字段所得的数量称为它的 <i>深度</i>。
以 <code>T</code> 声明的字段或方法 <code>f</code> 的深度为0。
在 <code>T</code> 中以匿名字段 <code>A</code> 声明的字段或方法 <code>f</code> 的深度
为 <code>f</code> 在 <code>A</code> 中的深度加1。
</p>

<div class="english">
<p>
The following rules apply to selectors:
</p>
</div>

<p>
以下规则适用于选择器：
</p>

<div class="english">
<ol>
<li>
For a value <code>x</code> of type <code>T</code> or <code>*T</code>
where <code>T</code> is not an interface type,
<code>x.f</code> denotes the field or method at the shallowest depth
in <code>T</code> where there
is such an <code>f</code>.
If there is not exactly <a href="#Uniqueness_of_identifiers">one <code>f</code></a>
with shallowest depth, the selector expression is illegal.
</li>
<li>
For a variable <code>x</code> of type <code>I</code>
where <code>I</code> is an interface type,
<code>x.f</code> denotes the actual method with name <code>f</code> of the value assigned
to <code>x</code> if there is such a method.
If no value or <code>nil</code> was assigned to <code>x</code>, <code>x.f</code> is illegal.
</li>
<li>
In all other cases, <code>x.f</code> is illegal.
</li>
</ol>
</div>

<ol>
<li>
对于非接口类型 <code>T</code> 或 <code>*T</code> 的值 <code>x</code>，
<code>x.f</code> 中的 <code>f</code> 表示在 <code>T</code> 中最浅深度的字段或方法。
若并非<a href="#标识符的唯一性">只有一个 <code>f</code></a>，该选择器表达式即为非法的。
</li>
<li>
对于接口类型 <code>I</code> 的变量 <code>x</code>，
<code>x.f</code> 表示赋予 <code>x</code> 的值名为 <code>f</code> 的真实方法。
若没有值或 <code>nil</code> 赋予 <code>x</code>，<code>x.f</code>即为非法的。
</li>
<li>
其它情况下，所有 <code>x.f</code> 均为非法的。
</li>
</ol>

<div class="english">
<p>
Selectors automatically dereference pointers to structs.
If <code>x</code> is a pointer to a struct, <code>x.y</code>
is shorthand for <code>(*x).y</code>; if the field <code>y</code>
is also a pointer to a struct, <code>x.y.z</code> is shorthand
for <code>(*(*x).y).z</code>, and so on.
If <code>x</code> contains an anonymous field of type <code>*A</code>,
where <code>A</code> is also a struct type,
<code>x.f</code> is a shortcut for <code>(*x.A).f</code>.
</p>
</div>

<p>
选择器会自动解引用指向结构的指针。
若 <code>x</code> 为指向结构的指针，<code>x.y</code> 即为 <code>(*x).y</code> 的缩写；
若字段 <code>y</code> 亦为指向结构的指针，<code>x.y.z</code> 即为 <code>(*(*x).y).z</code> 的缩写,
以此类推。
若 <code>x</code> 包含类型为 <code>*A</code> 的匿名字段，且 <code>A</code> 亦为结构类型，
<code>x.f</code> 即为 <code>(*x.A).f</code> 的缩写。
</p>

<div class="english">
<p>
For example, given the declarations:
</p>
</div>

<p>
例如，给定声明：
</p>

<div class="english">
<pre>
type T0 struct {
	x int
}

func (recv *T0) M0()

type T1 struct {
	y int
}

func (recv T1) M1()

type T2 struct {
	z int
	T1
	*T0
}

func (recv *T2) M2()

var p *T2  // with p != nil and p.T1 != nil
</pre>
</div>

<pre>
type T0 struct {
	x int
}

func (recv *T0) M0()

type T1 struct {
	y int
}

func (recv T1) M1()

type T2 struct {
	z int
	T1
	*T0
}

func (recv *T2) M2()

var p *T2  // 其中 p != nil 且 p.T1 != nil
</pre>

<div class="english">
<p>
one may write:
</p>
</div>

<p>
可写为：
</p>

<pre>
p.z   // (*p).z
p.y   // ((*p).T1).y
p.x   // (*(*p).T0).x

p.M2  // (*p).M2
p.M1  // ((*p).T1).M1
p.M0  // ((*p).T0).M0
</pre>


<!--
<span class="alert">
TODO: Specify what happens to receivers.
</span>
-->

<!--
<span class="alert">
TODO: 详述接收器会发生什么事。
</span>
-->


<div class="english">
<h3 id="Indexes">Indexes</h3>
</div>

<h3 id="下标">下标</h3>

<div class="english">
<p>
A primary expression of the form
</p>
</div>

<p>
形式为
</p>

<pre>
a[x]
</pre>

<div class="english">
<p>
denotes the element of the array, slice, string or map <code>a</code> indexed by <code>x</code>.
The value <code>x</code> is called the
<i>index</i> or <i>map key</i>, respectively. The following
rules apply:
</p>
</div>

<p>
的主表达式表示数组、切片、字符串或映射 <code>a</code> 的元素通过 <code>x</code> 索引。
值 <code>x</code> 称为 <i>下标</i> 或 <i>映射键</i>。以下规则适用于其对应的类型：
</p>

<div class="english">
<p>
For <code>a</code> of type <code>A</code> or <code>*A</code>
where <code>A</code> is an <a href="#Array_types">array type</a>,
or for <code>a</code> of type <code>S</code> where <code>S</code> is a <a href="#Slice_types">slice type</a>:
</p>
<ul>
	<li><code>x</code> must be an integer value and <code>0 &lt;= x &lt; len(a)</code></li>
	<li><code>a[x]</code> is the array element at index <code>x</code> and the type of
	  <code>a[x]</code> is the element type of <code>A</code></li>
	<li>if <code>a</code> is <code>nil</code> or if the index <code>x</code> is out of range,
	a <a href="#Run_time_panics">run-time panic</a> occurs</li>
</ul>
</div>

<p>
对于类型为<a href="#数组类型">数组类型</a> <code>A</code> 或 <code>*A</code> 的 <code>a</code>，
或对于类型为<a href="#切片类型">切片类型</a> <code>S</code> 的 <code>a</code>：
</p>
<ul>
	<li><code>x</code> 必须为整数值且 <code>0 &lt;= x &lt; len(a)</code></li>
	<li><code>a[x]</code> 为下标 <code>x</code> 的数组元素且
	  <code>a[x]</code> 的类型为 <code>A</code> 的元素类型</li>
	<li>若 <code>a</code> 为 <code>nil</code> 或下标 <code>x</code> 超出范围，
	就会出现一个<a href="#运行时异常">运行时异常</a></li>
</ul>

<div class="english">
<p>
For <code>a</code> of type <code>T</code>
where <code>T</code> is a <a href="#String_types">string type</a>:
</p>
<ul>
	<li><code>x</code> must be an integer value and <code>0 &lt;= x &lt; len(a)</code></li>
	<li><code>a[x]</code> is the byte at index <code>x</code> and the type of
	  <code>a[x]</code> is <code>byte</code></li>
	<li><code>a[x]</code> may not be assigned to</li>
	<li>if the index <code>x</code> is out of range,
	a <a href="#Run_time_panics">run-time panic</a> occurs</li>
</ul>
</div>

<p>
对于类型为<a href="#字符串类型">字符串类型</a> <code>T</code> 的 <code>a</code>：
</p>
<ul>
	<li><code>x</code> 必须为整数值且 <code>0 &lt;= x &lt; len(a)</code></li>
	<li><code>a[x]</code> 为下标 <code>x</code> 的字节且
	  <code>a[x]</code> 的类型为 <code>byte</code></li>
	<li><code>a[x]</code> 不可赋值</li>
	<li>若下标 <code>x</code> 超出范围，
	就会出现一个<a href="#运行时异常">运行时异常</a></li>
</ul>

<div class="english">
<p>
For <code>a</code> of type <code>M</code>
where <code>M</code> is a <a href="#Map_types">map type</a>:
</p>
<ul>
	<li><code>x</code>'s type must be
	<a href="#Assignability">assignable</a>
	to the key type of <code>M</code></li>
	<li>if the map contains an entry with key <code>x</code>,
	  <code>a[x]</code> is the map value with key <code>x</code>
	  and the type of <code>a[x]</code> is the value type of <code>M</code></li>
	<li>if the map is <code>nil</code> or does not contain such an entry,
	  <code>a[x]</code> is the <a href="#The_zero_value">zero value</a>
	  for the value type of <code>M</code></li>
</ul>
</div>

<p>
对于类型为<a href="#映射类型">映射类型</a> <code>M</code> 的 <code>a</code>：
</p>
<ul>
	<li><code>x</code> 的类型必须<a href="#可赋值性">可赋值</a>至 <code>M</code> 的键类型</li>
	<li>若映射包含键为 <code>x</code> 的项，则 <code>a[x]</code> 为键 <code>x</code> 的映射值，
	  且 <code>a[x]</code> 的类型为 <code>M</code> 的值类型</li>
	<li>若映射为 <code>nil</code> 或不包含这样的项，
	  <code>a[x]</code> 为 <code>M</code> 值类型的<a href="#零值">零值</a></li>
</ul>

<div class="english">
<p>
Otherwise <code>a[x]</code> is illegal.
</p>
</div>

<p>
否则 <code>a[x]</code> 即为非法的。
</p>

<div class="english">
<p>
An index expression on a map <code>a</code> of type <code>map[K]V</code>
may be used in an assignment or initialization of the special form
</p>
</div>

<p>
在类型为 <code>map[K]V</code> 的映射 <code>a</code> 中，下标表达式可使用特殊形式
</p>

<pre>
v, ok = a[x]
v, ok := a[x]
var v, ok = a[x]
</pre>

<div class="english">
<p>
where the result of the index expression is a pair of values with types
<code>(V, bool)</code>. In this form, the value of <code>ok</code> is
<code>true</code> if the key <code>x</code> is present in the map, and
<code>false</code> otherwise. The value of <code>v</code> is the value
<code>a[x]</code> as in the single-result form.
</p>
</div>

<p>
赋值或初始化，该下标表达式结果的类型为 <code>(V, bool)</code> 的值对。
在此形式中，若键 <code>x</code> 已在映射中，则 <code>ok</code> 的值为 <code>true</code>，
否则即为 <code>false</code>。<code>v</code> 的值为 <code>a[x]</code> 的单值形式。
</p>

<div class="english">
<p>
Assigning to an element of a <code>nil</code> map causes a
<a href="#Run_time_panics">run-time panic</a>.
</p>
</div>

<p>
向 <code>nil</code> 映射的元素赋值会引起<a href="#运行时异常">运行时异常</a>
</p>


<div class="english">
<h3 id="Slices">Slices</h3>
</div>

<h3 id="切片">切片</h3>

<div class="english">
<p>
For a string, array, pointer to array, or slice <code>a</code>, the primary expression
</p>
</div>

<p>
对于字符串，数组，指向数组的指针或切片 <code>a</code>，主表达式
</p>

<pre>
a[low : high]
</pre>

<div class="english">
<p>
constructs a substring or slice. The index expressions <code>low</code> and
<code>high</code> select which elements appear in the result. The result has
indexes starting at 0 and length equal to
<code>high</code>&nbsp;-&nbsp;<code>low</code>.
After slicing the array <code>a</code>
</p>
</div>

<p>
会构造一个字串或切片。下标表达式 <code>low</code> 和 <code>high</code> 则选出哪些元素出现在结果中。
该结果的下标起始于 0 且长度等于 <code>high</code>&nbsp;-&nbsp;<code>low</code>。
在切下数组 <code>a</code>
</p>

<pre>
a := [5]int{1, 2, 3, 4, 5}
s := a[1:4]
</pre>

<div class="english">
<p>
the slice <code>s</code> has type <code>[]int</code>, length 3, capacity 4, and elements
</p>
</div>

<p>
之后，切片 <code>s</code> 的类型为 <code>[]int</code>，长度为 3，容量为 4，且元素
</p>

<pre>
s[0] == 2
s[1] == 3
s[2] == 4
</pre>

<div class="english">
<p>
For convenience, any of the index expressions may be omitted. A missing <code>low</code>
index defaults to zero; a missing <code>high</code> index defaults to the length of the
sliced operand:
</p>
</div>

<p>
为方便起见，任何下标表达式都可省略。略去的 <code>low</code> 下标默认为零；
略去的 <code>high</code> 下标默认为已切下的操作数的长度：
</p>

<pre>
a[2:]  // same a[2 : len(a)]
a[:3]  // same as a[0 : 3]
a[:]   // same as a[0 : len(a)]
</pre>

<div class="english">
<p>
For arrays or strings, the indexes <code>low</code> and <code>high</code> must
satisfy 0 &lt;= <code>low</code> &lt;= <code>high</code> &lt;= length; for
slices, the upper bound is the capacity rather than the length.
</p>
</div>

<p>
对于数组或字符串，下标 <code>low</code> 和 <code>high</code> 必须满足
0 &lt;= <code>low</code> &lt;= <code>high</code> &lt;= 长度；对于切片，其上界为容量而非长度。
</p>

<div class="english">
<p>
If the sliced operand is a string or slice, the result of the slice operation
is a string or slice of the same type.
If the sliced operand is an array, it must be <a href="#Address_operators">addressable</a>
and the result of the slice operation is a slice with the same element type as the array.
</p>
</div>

<p>
若已切下操作数为字符串或切片，该切片操作的结果即为相同类型的字符串或切片。
若已切下操作数为数组，它必须为<a href="#地址操作符">可寻址的</a>，
且该切片操作的结果为以相同元素类型作为数组的切片。
</p>


<div class="english">
<h3 id="Type_assertions">Type assertions</h3>
</div>

<h3 id="类型断言">类型断言</h3>

<div class="english">
<p>
For an expression <code>x</code> of <a href="#Interface_types">interface type</a>
and a type <code>T</code>, the primary expression
</p>
</div>

<p>
对于<a href="#接口类型">接口类型</a>的表达式 <code>x</code> 与类型 <code>T</code>，主表达式
</p>

<pre>
x.(T)
</pre>

<div class="english">
<p>
asserts that <code>x</code> is not <code>nil</code>
and that the value stored in <code>x</code> is of type <code>T</code>.
The notation <code>x.(T)</code> is called a <i>type assertion</i>.
</p>
</div>

<p>
断言 <code>x</code> 不为 <code>nil</code> 且存储于 <code>x</code> 中的值其类型为 <code>T</code>。
记法 <code>x.(T)</code> 称为 <i>类型断言</i>。
</p>

<div class="english">
<p>
More precisely, if <code>T</code> is not an interface type, <code>x.(T)</code> asserts
that the dynamic type of <code>x</code> is <a href="#Type_identity">identical</a>
to the type <code>T</code>.
If <code>T</code> is an interface type, <code>x.(T)</code> asserts that the dynamic type
of <code>x</code> implements the interface <code>T</code> (§<a href="#Interface_types">Interface types</a>).
</p>
</div>

<p>
更确切地说，若 <code>T</code> 为非接口类型，<code>x.(T)</code> 断言 <code>x</code> 的动态类型
与 <code>T</code><a href="#类型标识">相同</a>。若 <code>T</code> 为接口类型，<code>x.(T)</code>
则断言<code>x</code> 的动态类型实现了接口 <code>T</code>（§<a href="#接口类型">接口类型</a>）。
</p>

<div class="english">
<p>
If the type assertion holds, the value of the expression is the value
stored in <code>x</code> and its type is <code>T</code>. If the type assertion is false,
a <a href="#Run_time_panics">run-time panic</a> occurs.
In other words, even though the dynamic type of <code>x</code>
is known only at run-time, the type of <code>x.(T)</code> is
known to be <code>T</code> in a correct program.
</p>
</div>

<p>
若该类型断言成立，该表达式的值即为存储于 <code>x</code> 中的值，且其类型为 <code>T</code>。若该类型断言不成立，
就会出现一个<a href="#运行时异常">运行时异常</a>。换句话说，即使 <code>x</code> 的动态类型只能在运行时可知，
在正确的程序中，<code>x.(T)</code> 的类型也可知为 <code>T</code>。
</p>

<div class="english">
<p>
If a type assertion is used in an assignment or initialization of the form
</p>
</div>

<p>
若类型断言以
</p>

<pre>
v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)
</pre>

<div class="english">
<p>
the result of the assertion is a pair of values with types <code>(T, bool)</code>.
If the assertion holds, the expression returns the pair <code>(x.(T), true)</code>;
otherwise, the expression returns <code>(Z, false)</code> where <code>Z</code>
is the <a href="#The_zero_value">zero value</a> for type <code>T</code>.
No run-time panic occurs in this case.
The type assertion in this construct thus acts like a function call
returning a value and a boolean indicating success.  (§<a href="#Assignments">Assignments</a>)
</p>
</div>

<p>
的形式用于赋值或初始化，该断言的结果即为类型为 <code>(T, bool)</code> 的值对。
若该断言成立，该表达式返回值对 <code>(x.(T), true)</code>；否则，该表达式返回 <code>(Z, false)</code>，
其中 <code>Z</code> 为类型为 <code>T</code> 的<a href="#零值">零值</a>。此种情况不会产生运行时异常。
类型断言在这种构造中，其行为类似于函数调用返回一个值与一个布尔值以表示成功。（§<a href="#赋值">赋值</a>）
</p>


<div class="english">
<h3 id="Calls">Calls</h3>
</div>

<h3 id="调用">调用</h3>

<div class="english">
<p>
Given an expression <code>f</code> of function type
<code>F</code>,
</p>
</div>

<p>
给定函数类型为 <code>F</code> 的表达式 <code>f</code>，
</p>

<pre>
f(a1, a2, … an)
</pre>

<div class="english">
<p>
calls <code>f</code> with arguments <code>a1, a2, … an</code>.
Except for one special case, arguments must be single-valued expressions
<a href="#Assignability">assignable</a> to the parameter types of
<code>F</code> and are evaluated before the function is called.
The type of the expression is the result type
of <code>F</code>.
A method invocation is similar but the method itself
is specified as a selector upon a value of the receiver type for
the method.
</p>
</div>

<p>
以实参 <code>a1, a2, … an</code> 调用 <code>f</code>。
除一种特殊情况外，实参必须为 <a href="#可赋值性">可赋予</a>
<code>F</code> 的形参类型的单值表达式，且在该函数被调用前求值。
该表达式的类型为 <code>F</code> 的结果类型。
方法调用也类似，但方法本身作为选择器被指定，该选择器取决于方法接收器类型的值。
</p>

<div class="english">
<pre>
math.Atan2(x, y)  // function call
var pt *Point
pt.Scale(3.5)  // method call with receiver pt
</pre>
</div>

<pre>
math.Atan2(x, y)  // 函数调用
var pt *Point
pt.Scale(3.5)     // 带接收器 pt 的方法调用
</pre>

<div class="english">
<p>
In a function call, the function value and arguments are evaluated in
<a href="#Order_of_evaluation">the usual order</a>.
After they are evaluated, the parameters of the call are passed by value to the function
and the called function begins execution.
The return parameters of the function are passed by value
back to the calling function when the function returns.
</p>
</div>

<p>
在函数调用中，函数值与实参按<a href="#求值顺序">一般顺序</a>求值。
在它们求值后，该调用的形参传值至该函数，被调用函数开始执行。
当函数返回时，该函数的返回形参将值传回调用函数。
</p>

<div class="english">
<p>
Calling a <code>nil</code> function value
causes a <a href="#Run_time_panics">run-time panic</a>.
</p>
</div>

<p>
调用 <code>nil</code> 函数值会引起 <a href="#运行时异常">运行时异常</a>。
</p>

<div class="english">
<p>
As a special case, if the return parameters of a function or method
<code>g</code> are equal in number and individually
assignable to the parameters of another function or method
<code>f</code>, then the call <code>f(g(<i>parameters_of_g</i>))</code>
will invoke <code>f</code> after binding the return values of
<code>g</code> to the parameters of <code>f</code> in order.  The call
of <code>f</code> must contain no parameters other than the call of <code>g</code>.
If <code>f</code> has a final <code>...</code> parameter, it is
assigned the return values of <code>g</code> that remain after
assignment of regular parameters.
</p>
</div>

<p>
作为一种特殊情况，若函数或方法 <code>g</code> 的返回形参在数量上等于函数或方法 <code>f</code> 的形参，
且分别可赋予它，那么调用 <code>f(g(<i>g的形参</i>))</code> 将在依序绑定 <code>g</code>
的返回值至 <code>f</code> 的形参后引用 <code>f</code>。除 <code>g</code> 的调用外，
<code>f</code> 的调用必须不包含任何形参。若 <code>f</code> 的最后有 <code>...</code> 形参，
它在常规的形参赋值后，可被赋予 <code>g</code> 余下的返回值。
</p>

<pre>
func Split(s string, pos int) (string, string) {
	return s[0:pos], s[pos:]
}

func Join(s, t string) string {
	return s + t
}

if Join(Split(value, len(value)/2)) != value {
	log.Panic("test fails")
}
</pre>

<div class="english">
<p>
A method call <code>x.m()</code> is valid if the <a href="#Method_sets">method set</a>
of (the type of) <code>x</code> contains <code>m</code> and the
argument list can be assigned to the parameter list of <code>m</code>.
If <code>x</code> is <a href="#Address_operators">addressable</a> and <code>&amp;x</code>'s method
set contains <code>m</code>, <code>x.m()</code> is shorthand
for <code>(&amp;x).m()</code>:
</p>
</div>

<p>
若 <code>x</code>（的类型）的<a href="#方法集">方法集</a>包含 <code>m</code>，
且其实参列表可赋予 <code>m</code> 的形参列表，方法调用 <code>x.m()</code> 即为有效的。
若 <code>x</code> 为 <a href="#地址操作符">可寻址</a>的且 <code>&amp;x</code> 的方法集包含 <code>m</code>，
<code>x.m()</code> 即为 <code>(&amp;x).m()</code> 的简写：
</p>

<pre>
var p Point
p.Scale(3.5)
</pre>

<div class="english">
<p>
There is no distinct method type and there are no method literals.
</p>
</div>

<p>
其中即没有明显的方法类型，也没有方法字面。
</p>


<div class="english">
<h3 id="Passing_arguments_to_..._parameters">Passing arguments to <code>...</code> parameters</h3>
</div>

<h3 id="传递实参至...形参">传递实参至...形参</h3>

<div class="english">
<p>
If <code>f</code> is variadic with final parameter type <code>...T</code>,
then within the function the argument is equivalent to a parameter of type
<code>[]T</code>.  At each call of <code>f</code>, the argument
passed to the final parameter is
a new slice of type <code>[]T</code> whose successive elements are
the actual arguments, which all must be <a href="#Assignability">assignable</a>
to the type <code>T</code>. The length of the slice is therefore the number of
arguments bound to the final parameter and may differ for each call site.
</p>
</div>

<p>
若 <code>f</code> 为最后带有形参类型 <code>...T</code> 的可变参函数，
那么在该函数中，实参等价于类型为 <code>[]T</code> 的形参。
对于每一个 <code>f</code> 的调用，传递至最后形参的实参为类型为 <code>[]T</code> 的一个新切片，
其连续的元素即为实际的实参，它们必须都<a href="#可赋值性">可赋予</a>类型 <code>T</code>。
因此，该切片的长度为绑定至最后形参的实参的数目，且对于每一个调用位置可能都不同。
</p>

<div class="english">
<p>
Given the function and call
</p>
</div>

<p>
给定函数和调用
</p>

<pre>
func Greeting(prefix string, who ...string)
Greeting("hello:", "Joe", "Anna", "Eileen")
</pre>

<div class="english">
<p>
within <code>Greeting</code>, <code>who</code> will have the value
<code>[]string{"Joe", "Anna", "Eileen"}</code>
</p>
</div>

<p>
在 <code>Greeting</code> 中，<code>who</code> 将拥有值 <code>[]string{"Joe", "Anna", "Eileen"}</code>
</p>

<div class="english">
<p>
If the final argument is assignable to a slice type <code>[]T</code>, it may be
passed unchanged as the value for a <code>...T</code> parameter if the argument
is followed by <code>...</code>. In this case no new slice is created.
</p>
</div>

<p>
若最后的实参可赋予类型为 <code>[]T</code> 的切片且后跟着 <code>...</code>，
它可能作为 <code>...T</code> 形参的值不变而被传入。
</p>

<div class="english">
<p>
Given the slice <code>s</code> and call
</p>
</div>

<p>
给定切片 <code>s</code> 与调用
</p>

<pre>
s := []string{"James", "Jasmine"}
Greeting("goodbye:", s...)
</pre>

<div class="english">
<p>
within <code>Greeting</code>, <code>who</code> will have the same value as <code>s</code>
with the same underlying array.
</p>
</div>

<p>
在 <code>Greeting</code> 中，<code>who</code> 将作为与 <code>s</code> 一样的值拥有与其相同的基本数组。
</p>


<div class="english">
<h3 id="Operators">Operators</h3>
</div>

<h3 id="操作符">操作符</h3>

<div class="english">
<p>
Operators combine operands into expressions.
</p>
</div>

<p>
操作符与操作数结合成为表达式。
</p>

<div class="english">
<pre class="ebnf">
Expression = UnaryExpr | Expression binary_op UnaryExpr .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .

binary_op  = "||" | "&amp;&amp;" | rel_op | add_op | mul_op .
rel_op     = "==" | "!=" | "&lt;" | "&lt;=" | ">" | ">=" .
add_op     = "+" | "-" | "|" | "^" .
mul_op     = "*" | "/" | "%" | "&lt;&lt;" | "&gt;&gt;" | "&amp;" | "&amp;^" .

unary_op   = "+" | "-" | "!" | "^" | "*" | "&amp;" | "&lt;-" .
</pre>
</div>

<pre class="ebnf">
表达式     = 一元表达式 | 表达式 二元操作符 一元表达式 .
一元表达式 = 主表达式 | 一元操作符 一元表达式 .

二元操作符 = "||" | "&amp;&amp;" | 比较操作符 | 加法操作符 | 乘法操作符 .
比较操作符 = "==" | "!=" | "&lt;" | "&lt;=" | ">" | ">=" .
加法操作符 = "+" | "-" | "|" | "^" .
乘法操作符 = "*" | "/" | "%" | "&lt;&lt;" | "&gt;&gt;" | "&amp;" | "&amp;^" .

一元操作符 = "+" | "-" | "!" | "^" | "*" | "&amp;" | "&lt;-" .
</pre>

<div class="english">
<p>
Comparisons are discussed <a href="#Comparison_operators">elsewhere</a>.
For other binary operators, the operand types must be <a href="#Type_identity">identical</a>
unless the operation involves shifts or untyped <a href="#Constants">constants</a>.
For operations involving constants only, see the section on
<a href="#Constant_expressions">constant expressions</a>.
</p>
</div>

<p>
比较操作将在<a href="#比较操作符">别处</a>讨论。
对于其他二元操作符，操作数的类型必须<a href="#类型标识">相同</a>，
除非该操作包含移位或无类型定义<a href="#常量">常量</a>。
</p>

<div class="english">
<p>
Except for shift operations, if one operand is an untyped <a href="#Constants">constant</a>
and the other operand is not, the constant is <a href="#Conversions">converted</a>
to the type of the other operand.
</p>
</div>

<p>
除移位操作外，若其中一个操作数为无类型定义<a href="#常量">常量</a>而另一个不是，
该常量需<a href="#强制转换">强制转换</a>为另一个操作数的类型。
</p>

<div class="english">
<p>
The right operand in a shift expression must have unsigned integer type
or be an untyped constant that can be converted to unsigned integer type.
If the left operand of a non-constant shift expression is an untyped constant,
the type of the constant is what it would be if the shift expression were
replaced by its left operand alone; the type is <code>int</code> if it cannot
be determined from the context (for instance, if the shift expression is an
operand in a comparison against an untyped constant).
</p>
</div>

<p>
移位表达式中的右操作数必须为无符号整数，或可转换为无符号整数的无类型定义常量。
若非常量移位表达式的左操作数为无类型定义常量，且该移位表达式已被其左操作数独自取代，
则该移位表达式的类型将变为该常量的类型；若其类型不能从上下文中判定
（例如，若该移位表达式在针对无类型定义常量的比较操作中），则为 <code>int</code>类型。
</p>

<div class="english">
<pre>
var s uint = 33
var i = 1&lt;&lt;s           // 1 has type int
var j int32 = 1&lt;&lt;s     // 1 has type int32; j == 0
var k = uint64(1&lt;&lt;s)   // 1 has type uint64; k == 1&lt;&lt;33
var m int = 1.0&lt;&lt;s     // 1.0 has type int
var n = 1.0&lt;&lt;s != 0    // 1.0 has type int; n == false if ints are 32bits in size
var o = 1&lt;&lt;s == 2&lt;&lt;s   // 1 and 2 have type int; o == true if ints are 32bits in size
var p = 1&lt;&lt;s == 1&lt;&lt;33  // illegal if ints are 32bits in size: 1 has type int, but 1&lt;&lt;33 overflows int
var u = 1.0&lt;&lt;s         // illegal: 1.0 has type float64, cannot shift
var v float32 = 1&lt;&lt;s   // illegal: 1 has type float32, cannot shift
var w int64 = 1.0&lt;&lt;33  // 1.0&lt;&lt;33 is a constant shift expression
</pre>
</div>

<pre>
var s uint = 33
var i = 1&lt;&lt;s           // 1 的类型为 int
var j int32 = 1&lt;&lt;s     // 1 的类型为 int32；j == 0
var k = uint64(1&lt;&lt;s)   // 1 的类型为 uint64；k == 1&lt;&lt;33
var m int = 1.0&lt;&lt;s     // 1.0 的类型为 int
var n = 1.0&lt;&lt;s != 0    // 1.0 的类型为 int；若int的大小为 32位，则 n == false
var o = 1&lt;&lt;s == 2&lt;&lt;s   // 1 与 2 的类型为 int；若 int 的大小为32位，则 o == true
var p = 1&lt;&lt;s == 1&lt;&lt;33  // 若 int 的大小为32位即为非法：虽然 1 的类型为 int，但 1&lt;&lt;33 溢出了 int
var u = 1.0&lt;&lt;s         // 非法: 1.0 的类型为 float64，不能移位
var v float32 = 1&lt;&lt;s   // 非法: 1 的类型为 float32，不能移位
var w int64 = 1.0&lt;&lt;33  // 1.0&lt;&lt;33 为常量移位表达式
</pre>


<div class="english">
<h3 id="Operator_precedence">Operator precedence</h3>
</div>

<h3 id="操作符优先级">操作符优先级</h3>

<div class="english">
<p>
Unary operators have the highest precedence.
As the  <code>++</code> and <code>--</code> operators form
statements, not expressions, they fall
outside the operator hierarchy.
As a consequence, statement <code>*p++</code> is the same as <code>(*p)++</code>.
</p>
</div>

<p>
一元操作符拥有最高优先级。
<code>++</code> 和 <code>--</code> 操作符是语句，而非表达式，它们不属于运算符一级。
因此，语句 <code>*p++</code> 等价于 <code>(*p)++</code>。
</p>

<div class="english">
<p>
There are five precedence levels for binary operators.
Multiplication operators bind strongest, followed by addition
operators, comparison operators, <code>&amp;&amp;</code> (logical and),
and finally <code>||</code> (logical or):
</p>
</div>

<p>
二元操作符有五种优先级。
乘法操作符结合性最强，其次为乘法操作符、比较操作符、<code>&amp;&amp;</code>（逻辑与），
最后为 <code>||</code>（逻辑或）：
</p>

<div class="english">
<pre class="grammar">
Precedence    Operator
    5             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^
    4             +  -  |  ^
    3             ==  !=  &lt;  &lt;=  &gt;  &gt;=
    2             &amp;&amp;
    1             ||
</pre>
</div>

<pre class="grammar">
  优先级        操作符
    5             *  /  %  &lt;&lt;  &gt;&gt;  &amp;  &amp;^
    4             +  -  |  ^
    3             ==  !=  &lt;  &lt;=  &gt;  &gt;=
    2             &amp;&amp;
    1             ||
</pre>

<div class="english">
<p>
Binary operators of the same precedence associate from left to right.
For instance, <code>x / y * z</code> is the same as <code>(x / y) * z</code>.
</p>
</div>

<p>
相同优先级的二元操作符从左到右结合。
例如，<code>x / y * z</code> 等价于 <code>(x / y) * z</code>。
</p>

<pre>
+x
23 + 3*x[i]
x &lt;= f()
^a &gt;&gt; b
f() || g()
x == y+1 &amp;&amp; &lt;-chanPtr &gt; 0
</pre>


<div class="english">
<h3 id="Arithmetic_operators">Arithmetic operators</h3>
</div>

<h3 id="算数操作符">算数操作符</h3>

<div class="english">
<p>
Arithmetic operators apply to numeric values and yield a result of the same
type as the first operand. The four standard arithmetic operators (<code>+</code>,
<code>-</code>,  <code>*</code>, <code>/</code>) apply to integer,
floating-point, and complex types; <code>+</code> also applies
to strings. All other arithmetic operators apply to integers only.
</p>
</div>

<p>
算数操作符适用于数值，并产生相同类型的结果作为第一个操作数。四个基本算数操作符
（<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>）适用于整数、浮点数和复数类型；
<code>+</code> 也适用于字符串。其他所有算数操作符仅适用于整数。
</p>

<div class="english">
<pre class="grammar">
+    sum                    integers, floats, complex values, strings
-    difference             integers, floats, complex values
*    product                integers, floats, complex values
/    quotient               integers, floats, complex values
%    remainder              integers

&amp;    bitwise and            integers
|    bitwise or             integers
^    bitwise xor            integers
&amp;^   bit clear (and not)    integers

&lt;&lt;   left shift             integer &lt;&lt; unsigned integer
&gt;&gt;   right shift            integer &gt;&gt; unsigned integer
</pre>
</div>

<pre class="grammar">
+    和                     integers, floats, complex values, strings
-    差                     integers, floats, complex values
*    积                     integers, floats, complex values
/    商                     integers, floats, complex values
%    余                     integers

&amp;    按位与                 integers
|    按位或                 integers
^    按位异或               integers
&amp;^   位清除（同或）         integers

&lt;&lt;   向左移位               integer &lt;&lt; unsigned integer
&gt;&gt;   向右移位               integer &gt;&gt; unsigned integer
</pre>

<div class="english">
<p>
Strings can be concatenated using the <code>+</code> operator
or the <code>+=</code> assignment operator:
</p>
</div>

<p>
字符串可使用 <code>+</code> 操作符连结或 <code>+=</code> 赋值操作符：
</p>

<pre>
s := "hi" + string(c)
s += " and good bye"
</pre>

<div class="english">
<p>
String addition creates a new string by concatenating the operands.
</p>
</div>

<p>
字符串加法通过连结操作数创建一个新的字符串。
</p>

<div class="english">
<p>
For two integer values <code>x</code> and <code>y</code>, the integer quotient
<code>q = x / y</code> and remainder <code>r = x % y</code> satisfy the following
relationships:
</p>
</div>

<p>
对于两个整数值 <code>x</code> 与 <code>y</code>，整数除法 <code>q = x / y</code>
和取余 <code>r = x % y</code> 满足以下关系：
</p>

<div class="english">
<pre>
x = q*y + r  and  |r| &lt; |y|
</pre>
</div>

<pre>
x = q*y + r  且  |r| &lt; |y|
</pre>

<div class="english">
<p>
with <code>x / y</code> truncated towards zero
(<a href="http://en.wikipedia.org/wiki/Modulo_operation">"truncated division"</a>).
</p>
</div>

<p>
将 <code>x / y</code> 向零截断（“<a href="http://en.wikipedia.org/wiki/Modulo_operation">除法截断</a>”）。
</p>

<pre>
 x     y     x / y     x % y
 5     3       1         2
-5     3      -1        -2
 5    -3      -1         2
-5    -3       1        -2
</pre>

<div class="english">
<p>
As an exception to this rule, if the dividend <code>x</code> is the most
negative value for the int type of <code>x</code>, the quotient
<code>q = x / -1</code> is equal to <code>x</code> (and <code>r = 0</code>).
</p>
</div>

<p>
作为该规则的一个例外，若被除数 <code>x</code> 为 <code>x</code> 的int类型的最小负值，商
<code>q = x / -1</code> 等于 <code>x</code>（且 <code>r = 0</code>）。
</p>

<pre>
			 x, q
int8                     -128
int16                  -32768
int32             -2147483648
int64    -9223372036854775808
</pre>

<div class="english">
<p>
If the divisor is zero, a <a href="#Run_time_panics">run-time panic</a> occurs.
If the dividend is positive and the divisor is a constant power of 2,
the division may be replaced by a right shift, and computing the remainder may
be replaced by a bitwise "and" operation:
</p>
</div>

<p>
若被除数为零，就会出现一个<a href="#运行时异常">运行时异常</a>。
若被除数为正，且除数为2的常量次幂，则该除法可被向右移位取代，且计算其商可被按位“与”操作取代：
</p>

<pre>
 x     x / 4     x % 4     x &gt;&gt; 2     x &amp; 3
 11      2         3         2          3
-11     -2        -3        -3          1
</pre>

<div class="english">
<p>
The shift operators shift the left operand by the shift count specified by the
right operand. They implement arithmetic shifts if the left operand is a signed
integer and logical shifts if it is an unsigned integer.
There is no upper limit on the shift count. Shifts behave
as if the left operand is shifted <code>n</code> times by 1 for a shift
count of <code>n</code>.
As a result, <code>x &lt;&lt; 1</code> is the same as <code>x*2</code>
and <code>x &gt;&gt; 1</code> is the same as
<code>x/2</code> but truncated towards negative infinity.
</p>
</div>

<p>
移位操作符通过右操作数指定的移位计数来移位左操作数。若左操作数为带符号整数，它们就执行算术移位；
若左操作数为为无符号整数，它们则执行逻辑移位。移位计数没有上界。
若左操作数移位 <code>n</code> 次，移位的行为如同从 1 到 <code>n</code> 的一个移位计数。
按照其结果，<code>x &lt;&lt; 1</code> 等价于 <code>x*2</code>，而 <code>x &gt;&gt; 1</code>
等价于 <code>x/2</code> 但向负无穷大截断。
</p>

<div class="english">
<p>
For integer operands, the unary operators
<code>+</code>, <code>-</code>, and <code>^</code> are defined as
follows:
</p>
</div>

<p>
对于整数操作数，一元操作符 <code>+</code>、<code>-</code> 和 <code>^</code> 的定义如下：
</p>

<div class="english">
<pre class="grammar">
+x                          is 0 + x
-x    negation              is 0 - x
^x    bitwise complement    is m ^ x  with m = "all bits set to 1" for unsigned x
                                      and  m = -1 for signed x
</pre>
</div>

<pre class="grammar">
+x                  即为 0 + x
-x    相反数        即为 0 - x
^x    按位补码      即为 m ^ x  对于无符号的 x，m = "所有位置为1"
                                对于带符号的 x，m = -1
</pre>

<div class="english">
<p>
For floating-point numbers,
<code>+x</code> is the same as <code>x</code>,
while <code>-x</code> is the negation of <code>x</code>.
The result of a floating-point division by zero is not specified beyond the
IEEE-754 standard; whether a <a href="#Run_time_panics">run-time panic</a>
occurs is implementation-specific.
</p>
</div>

<p>
对于浮点数，<code>+x</code> 等价于 <code>x</code>，而 <code>-x</code> 则为 <code>x</code> 的相反数。
浮点数除以零的结果因超出 IEEE-754 标准的范围而未指定；是否会出现<a href="#运行时异常">运行时异常</a>取决于具体实现。
</p>

<div class="english">
<h3 id="Integer_overflow">Integer overflow</h3>
</div>

<h3 id="整数溢出">整数溢出</h3>

<div class="english">
<p>
For unsigned integer values, the operations <code>+</code>,
<code>-</code>, <code>*</code>, and <code>&lt;&lt;</code> are
computed modulo 2<sup><i>n</i></sup>, where <i>n</i> is the bit width of
the unsigned integer's type
(§<a href="#Numeric_types">Numeric types</a>). Loosely speaking, these unsigned integer operations
discard high bits upon overflow, and programs may rely on ``wrap around''.
</p>
</div>

<p>
对于无符号整数值，操作 <code>+</code>、<code>-</code>、<code>*</code> 和 <code>&lt;&lt;</code>
均被计算为取模 2<sup><i>n</i></sup>，其中 <i>n</i> 为该无符号整数类型的位宽
（§<a href="#数值类型">数值类型</a>）。不严格地说，这些无符号整数操作抛弃高位向上溢出，而程序可依赖“折回”。
</p>

<div class="english">
<p>
For signed integers, the operations <code>+</code>,
<code>-</code>, <code>*</code>, and <code>&lt;&lt;</code> may legally
overflow and the resulting value exists and is deterministically defined
by the signed integer representation, the operation, and its operands.
No exception is raised as a result of overflow. A
compiler may not optimize code under the assumption that overflow does
not occur. For instance, it may not assume that <code>x &lt; x + 1</code> is always true.
</p>
</div>

<p>
对于带符号整数，操作 <code>+</code>、<code>-</code>、<code>*</code> 和 <code>&lt;&lt;</code> 可合法溢出，
而由此产生的值会继续存在，并由该带符号整数表现、操作、与其操作数决定性地定义。
没有例外作为溢出的结果提高。在溢出不会发生的假定情况下下编译器可能不会优化代码。
例如，它可能不假定 <code>x &lt; x + 1</code> 总为真。
</p>


<div class="english">
<h3 id="Comparison_operators">Comparison operators</h3>
</div>

<h3 id="比较操作符">比较操作符</h3>

<div class="english">
<p>
Comparison operators compare two operands and yield a boolean value.
</p>
</div>

<p>
比较操作符比较两个操作数并产生一个布尔值。
</p>

<div class="english">
<pre class="grammar">
==    equal
!=    not equal
&lt;     less
&lt;=    less or equal
&gt;     greater
&gt;=    greater or equal
</pre>
</div>

<pre class="grammar">
==    等于
!=    不等于
&lt;     小于
&lt;=    小于等于
&gt;     大于
&gt;=    大于等于
</pre>

<div class="english">
<p>
In any comparison, the first operand
must be <a href="#Assignability">assignable</a>
to the type of the second operand, or vice versa.
</p>
</div>

<p>
在任何比较中，第一个操作数必须<a href="#可赋值性">可赋予</a>第二个操作数的类型，反之亦然。
</p>

<div class="english">
<p>
The equality operators <code>==</code> and <code>!=</code> apply
to operands that are <i>comparable</i>.
The ordering operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>
apply to operands that are <i>ordered</i>.
These terms and the result of the comparisons are defined as follows:
</p>
</div>

<p>
相等操作符 <code>==</code> 和 <code>!=</code> 适用于<i>可比较</i>操作数。
顺序操作符 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code> 和 <code>&gt;=</code>
适用于<i>有序的</i>操作数。这些比较操作的关系和值定义如下：
</p>

<div class="english">
<ul>
	<li>
	Boolean values are comparable.
	Two boolean values are equal if they are either both
	<code>true</code> or both <code>false</code>.
	</li>

	<li>
	Integer values are comparable and ordered, in the usual way.
	</li>

	<li>
	Floating point values are comparable and ordered,
	as defined by the IEEE-754 standard.
	</li>

	<li>
	Complex values are comparable.
	Two complex values <code>u</code> and <code>v</code> are
	equal if both <code>real(u) == real(v)</code> and
	<code>imag(u) == imag(v)</code>.
	</li>

	<li>
	String values are comparable and ordered, lexically byte-wise.
	</li>

	<li>
	Pointer values are comparable.
	Two pointer values are equal if they point to the same variable or if both have value <code>nil</code>.
	Pointers to distinct <a href="#Size_and_alignment_guarantees">zero-size</a> variables may or may not be equal.
	</li>

	<li>
	Channel values are comparable.
	Two channel values are equal if they were created by the same call to <code>make</code>
	(§<a href="#Making_slices_maps_and_channels">Making slices, maps, and channels</a>)
	or if both have value <code>nil</code>.
	</li>

	<li>
	Interface values are comparable.
	Two interface values are equal if they have <a href="#Type_identity">identical</a> dynamic types
	and equal dynamic values or if both have value <code>nil</code>.
	</li>

	<li>
	A value <code>x</code> of non-interface type <code>X</code> and
	a value <code>t</code> of interface type <code>T</code> are comparable when values
	of type <code>X</code> are comparable and
	<code>X</code> implements <code>T</code>.
	They are equal if <code>t</code>'s dynamic type is identical to <code>X</code>
	and <code>t</code>'s dynamic value is equal to <code>x</code>.
	</li>

	<li>
	Struct values are comparable if all their fields are comparable.
	Two struct values are equal if their corresponding
	non-<a href="#Blank_identifier">blank</a> fields are equal.
	</li>

	<li>
	Array values are comparable if values of the array element type are comparable.
	Two array values are equal if their corresponding elements are equal.
	</li>
</ul>
</div>

<ul>
	<li>
	布尔值之间可比较。若两个布尔值同为 <code>true</code> 或同为 <code>false</code>，它们即为相等。
	</li>

	<li>
	通常情况下，整数值之间可比较或排序。
	</li>

	<li>
	根据 IEEE-754 标准的定义，浮点数值之间可比较或排序。
	</li>

	<li>
	复数值之间可比较。对于两个复数值 <code>u</code> 与 <code>v</code>，
	若 <code>real(u) == real(v)</code> 且 <code>imag(u) == imag(v)</code>，它们即为相等。
	</li>

	<li>
	根据按字节词法，字符串值之间可比较或排序。
	</li>

	<li>
	指针值之间可比较。若两个指针指向相同的值或其值同为 <code>nil</code>，它们即为相等。
	指向明显为<a href="#大小与对齐保证">零大小</a>变量的指针可能相等也可能不相等。
	</li>

	<li>
	信道值可比较。若两个信道值通过相同的 <code>make</code> 调用
	（§<a href="#创建切片、映射和信道">创建切片、映射和信道</a>）创建或同为 <code>nil</code> 值，它们即为相等。
	</li>

	<li>
	接口值可比较。若两个接口值拥有<a href="#类型标识">相同</a>的动态类型与相等的动态值，或同为
	<code>nil</code> 值，它们即为相等。
	</li>

	<li>
	当非接口类型 <code>X</code> 的值可比较且 <code>X</code> 实现了 <code>T</code> 时，
	非接口类型 <code>X</code> 的值 <code>x</code> 与接口类型 <code>T</code> 的值 <code>t</code> 则可比较。
	若 <code>t</code> 的动态类型与 <code>X</code> 相同且 <code>t</code> 动态值等于 <code>x</code>，它们即为相等。
	</li>

	<li>
	若两个结构值的所有字段可比较，它们即可比较。若其相应的非<a href="#空白标识符">空白</a>字段相等，它们即为相等。
	</li>

	<li>
	若两个数组元素类型的值可比较，则数组值可比较。若其相应的元素相等，它们即为相等。
	</li>
</ul>

<div class="english">
<p>
A comparison of two interface values with identical dynamic types
causes a <a href="#Run_time_panics">run-time panic</a> if values
of that type are not comparable.  This behavior applies not only to direct interface
value comparisons but also when comparing arrays of interface values
or structs with interface-valued fields.
</p>
</div>

<p>
两个动态类型相同的接口值进行比较，若该动态类型的值不可比较，将引起一个<a href="#运行时异常">运行时异常</a>。
此行为不仅适用于直接的接口值比较，当比较接口值的数组或接口值作为字段的结构时也适用。
</p>

<div class="english">
<p>
Slice, map, and function values are not comparable.
However, as a special case, a slice, map, or function value may
be compared to the predeclared identifier <code>nil</code>.
Comparison of pointer, channel, and interface values to <code>nil</code>
is also allowed and follows from the general rules above.
</p>
</div>

<p>
切片、映射和函数值同类型之间不可比较。然而，作为一种特殊情况，切片、映射或函数值可与预声明标识符 <code>nil</code>
进行比较。指针、信道和接口值与 <code>nil</code> 之间的比较也允许并遵循上面的一般规则。
</p>

<div class="english">
<p>
The result of a comparison can be assigned to any boolean type.
If the context does not demand a specific boolean type,
the result has type <code>bool</code>.
</p>
</div>

<p>
比较的结果可赋予任何布尔类型。若上下文无需特殊的布尔类型，其结为的类型即为 <code>bool</code>。
</p>

<div class="english">
<pre>
type MyBool bool

var x, y int
var (
	b1 MyBool = x == y // result of comparison has type MyBool
	b2 bool   = x == y // result of comparison has type bool
	b3        = x == y // result of comparison has type bool
)
</pre>
</div>

<pre>
type MyBool bool

var x, y int
var (
	b1 MyBool = x == y // 比较的结果为类型 MyBool
	b2 bool   = x == y // 比较的结果为类型 bool
	b3        = x == y // 比较的结果为类型 bool
)
</pre>

<div class="english">
<h3 id="Logical_operators">Logical operators</h3>
</div>

<h3 id="逻辑操作符">逻辑操作符</h3>

<div class="english">
<p>
Logical operators apply to <a href="#Boolean_types">boolean</a> values
and yield a result of the same type as the operands.
The right operand is evaluated conditionally.
</p>
</div>

<p>
逻辑操作符适用于<a href="#布尔类型">布尔</a>值并根据操作数产生一个相同类型的结果。右操作数有条件地求值。
</p>

<div class="english">
<pre class="grammar">
&amp;&amp;    conditional and    p &amp;&amp; q  is  "if p then q else false"
||    conditional or     p || q  is  "if p then true else q"
!     not                !p      is  "not p"
</pre>
</div>

<pre class="grammar">
&amp;&amp;    条件与    p &amp;&amp; q  即  “若 p 则 q 否则 false”
||    条件或    p || q  即  “若 p 则 true 否则 q”
!     非        !p      即  “非 p”
</pre>


<div class="english">
<h3 id="Address_operators">Address operators</h3>
</div>

<h3 id="地址操作符">地址操作符</h3>

<div class="english">
<p>
For an operand <code>x</code> of type <code>T</code>, the address operation
<code>&amp;x</code> generates a pointer of type <code>*T</code> to <code>x</code>.
The operand must be <i>addressable</i>,
that is, either a variable, pointer indirection, or slice indexing
operation; or a field selector of an addressable struct operand;
or an array indexing operation of an addressable array.
As an exception to the addressability requirement, <code>x</code> may also be a
<a href="#Composite_literals">composite literal</a>.
</p>
</div>

<p>
对于类型为 <code>T</code> 的操作数 <code>x</code>，地址操作符 <code>&amp;x</code> 将生成一个类型为
<code>*T</code> 的指针指向 <code>x</code>。操作数必须<i>可寻址</i>，即，变量、间接指针、切片索引操作，
或可寻址结构操作数的字段选择器，或可寻址数组的数组索引操作均不可寻址。作为可寻址性需求的例外，
<code>x</code> 也可为 <a href="#复合字面">复合字面</a>.
</p>

<div class="english">
<p>
For an operand <code>x</code> of pointer type <code>*T</code>, the pointer
indirection <code>*x</code> denotes the value of type <code>T</code> pointed
to by <code>x</code>.
If <code>x</code> is <code>nil</code>, an attempt to evaluate <code>*x</code>
will cause a <a href="#Run_time_panics">run-time panic</a>.
</p>
</div>

<p>
对于指针类型为 <code>*T</code> 的操作数 <code>x</code>，间接指针 <code>*x</code>
表示类型为 <code>T</code> 的值指向 <code>x</code>。若 <code>x</code> 为 <code>nil</code>，
尝试求值 <code>*x</code> 将会引起<a href="#运行时异常">运行时异常</a>。
</p>

<pre>
&amp;x
&amp;a[f(2)]
*p
*pf(x)
</pre>


<div class="english">
<h3 id="Receive_operator">Receive operator</h3>
</div>

<h3 id="接收操作符">接收操作符</h3>

<div class="english">
<p>
For an operand <code>ch</code> of <a href="#Channel_types">channel type</a>,
the value of the receive operation <code>&lt;-ch</code> is the value received
from the channel <code>ch</code>. The type of the value is the element type of
the channel. The expression blocks until a value is available.
Receiving from a <code>nil</code> channel blocks forever.
</p>
</div>

<p>
For an operand <code>ch</code> of <a href="#Channel_types">channel type</a>,
the value of the receive operation <code>&lt;-ch</code> is the value received
from the channel <code>ch</code>. The type of the value is the element type of
the channel. The expression blocks until a value is available.
Receiving from a <code>nil</code> channel blocks forever.
对于<a href="#信道类型">信道类型</a>的操作数 <code>ch</code>，接收操作符 <code>&lt;-ch</code> 的值即为从信道
<code>ch</code> 接收的值。该值的类型即为该信道的元素类型。该值前的表达式块是有效的。
从 <code>nil</code> 信道接收将永远死锁，
</p>

<pre>
v1 := &lt;-ch
v2 = &lt;-ch
f(&lt;-ch)
&lt;-strobe  // wait until clock pulse and discard received value
</pre>

<p>
A receive expression used in an assignment or initialization of the form
</p>

<pre>
x, ok = &lt;-ch
x, ok := &lt;-ch
var x, ok = &lt;-ch
</pre>

<p>
yields an additional result.
The boolean variable <code>ok</code> indicates whether
the received value was sent on the channel (<code>true</code>)
or is a <a href="#The_zero_value">zero value</a> returned
because the channel is closed and empty (<code>false</code>).
</p>

<!--
<p>
<span class="alert">TODO: Probably in a separate section, communication semantics
need to be presented regarding send, receive, select, and goroutines.</span>
</p>
-->

<!--
<p>
<span class="alert">
TODO: 或许在单独的章节中，通信语义需要就发送、接收、选择和够程介绍一下。
</span>
</p>
-->


<div class="english">
<h3 id="Method_expressions">Method expressions</h3>
</div>

<h3 id="方法表达式">方法表达式</h3>

<p>
If <code>M</code> is in the <a href="#Method_sets">method set</a> of type <code>T</code>,
<code>T.M</code> is a function that is callable as a regular function
with the same arguments as <code>M</code> prefixed by an additional
argument that is the receiver of the method.
</p>

<pre class="ebnf">
MethodExpr    = ReceiverType "." MethodName .
ReceiverType  = TypeName | "(" "*" TypeName ")" .
</pre>

<p>
Consider a struct type <code>T</code> with two methods,
<code>Mv</code>, whose receiver is of type <code>T</code>, and
<code>Mp</code>, whose receiver is of type <code>*T</code>.
</p>

<pre>
type T struct {
	a int
}
func (tv  T) Mv(a int) int         { return 0 }  // value receiver
func (tp *T) Mp(f float32) float32 { return 1 }  // pointer receiver
var t T
</pre>

<p>
The expression
</p>

<pre>
T.Mv
</pre>

<p>
yields a function equivalent to <code>Mv</code> but
with an explicit receiver as its first argument; it has signature
</p>

<pre>
func(tv T, a int) int
</pre>

<p>
That function may be called normally with an explicit receiver, so
these three invocations are equivalent:
</p>

<pre>
t.Mv(7)
T.Mv(t, 7)
f := T.Mv; f(t, 7)
</pre>

<p>
Similarly, the expression
</p>

<pre>
(*T).Mp
</pre>

<p>
yields a function value representing <code>Mp</code> with signature
</p>

<pre>
func(tp *T, f float32) float32
</pre>

<p>
For a method with a value receiver, one can derive a function
with an explicit pointer receiver, so
</p>

<pre>
(*T).Mv
</pre>

<p>
yields a function value representing <code>Mv</code> with signature
</p>

<pre>
func(tv *T, a int) int
</pre>

<p>
Such a function indirects through the receiver to create a value
to pass as the receiver to the underlying method;
the method does not overwrite the value whose address is passed in
the function call.
</p>

<p>
The final case, a value-receiver function for a pointer-receiver method,
is illegal because pointer-receiver methods are not in the method set
of the value type.
</p>

<p>
Function values derived from methods are called with function call syntax;
the receiver is provided as the first argument to the call.
That is, given <code>f := T.Mv</code>, <code>f</code> is invoked
as <code>f(t, 7)</code> not <code>t.f(7)</code>.
To construct a function that binds the receiver, use a
<a href="#Function_literals">closure</a>.
</p>

<p>
It is legal to derive a function value from a method of an interface type.
The resulting function takes an explicit receiver of that interface type.
</p>

<div class="english">
<h3 id="Conversions">Conversions</h3>
</div>

<h3 id="强制转换">强制转换</h3>

<p>
Conversions are expressions of the form <code>T(x)</code>
where <code>T</code> is a type and <code>x</code> is an expression
that can be converted to type <code>T</code>.
</p>

<pre class="ebnf">
Conversion = Type "(" Expression ")" .
</pre>

<p>
If the type starts with an operator it must be parenthesized:
</p>

<pre>
*Point(p)        // same as *(Point(p))
(*Point)(p)      // p is converted to (*Point)
&lt;-chan int(c)    // same as &lt;-(chan int(c))
(&lt;-chan int)(c)  // c is converted to (&lt;-chan int)
</pre>

<p>
A <a href="#Constants">constant</a> value <code>x</code> can be converted to
type <code>T</code> in any of these cases:
</p>

<ul>
	<li>
	<code>x</code> is representable by a value of type <code>T</code>.
	</li>
	<li>
	<code>x</code> is an integer constant and <code>T</code> is a
	<a href="#String_types">string type</a>.
	The same rule as for non-constant <code>x</code> applies in this case
	(§<a href="#Conversions_to_and_from_a_string_type">Conversions to and from a string type</a>).
	</li>
</ul>

<p>
Converting a constant yields a typed constant as result.
</p>

<pre>
uint(iota)               // iota value of type uint
float32(2.718281828)     // 2.718281828 of type float32
complex128(1)            // 1.0 + 0.0i of type complex128
string('x')              // "x" of type string
string(0x266c)           // "♬" of type string
MyString("foo" + "bar")  // "foobar" of type MyString
string([]byte{'a'})      // not a constant: []byte{'a'} is not a constant
(*int)(nil)              // not a constant: nil is not a constant, *int is not a boolean, numeric, or string type
int(1.2)                 // illegal: 1.2 cannot be represented as an int
string(65.0)             // illegal: 65.0 is not an integer constant
</pre>

<p>
A non-constant value <code>x</code> can be converted to type <code>T</code>
in any of these cases:
</p>

<ul>
	<li>
	<code>x</code> is <a href="#Assignability">assignable</a>
	to <code>T</code>.
	</li>
	<li>
	<code>x</code>'s type and <code>T</code> have identical
	<a href="#Types">underlying types</a>.
	</li>
	<li>
	<code>x</code>'s type and <code>T</code> are unnamed pointer types
	and their pointer base types have identical underlying types.
	</li>
	<li>
	<code>x</code>'s type and <code>T</code> are both integer or floating
	point types.
	</li>
	<li>
	<code>x</code>'s type and <code>T</code> are both complex types.
	</li>
	<li>
	<code>x</code> is an integer or has type <code>[]byte</code> or
	<code>[]rune</code> and <code>T</code> is a string type.
	</li>
	<li>
	<code>x</code> is a string and <code>T</code> is <code>[]byte</code> or
	<code>[]rune</code>.
	</li>
</ul>

<p>
Specific rules apply to (non-constant) conversions between numeric types or
to and from a string type.
These conversions may change the representation of <code>x</code>
and incur a run-time cost.
All other conversions only change the type but not the representation
of <code>x</code>.
</p>

<p>
There is no linguistic mechanism to convert between pointers and integers.
The package <a href="#Package_unsafe"><code>unsafe</code></a>
implements this functionality under
restricted circumstances.
</p>

<div class="english">
<h4>Conversions between numeric types</h4>
</div>

<h4>数值类型间的转换</h4>

<p>
For the conversion of non-constant numeric values, the following rules apply:
</p>

<ol>
<li>
When converting between integer types, if the value is a signed integer, it is
sign extended to implicit infinite precision; otherwise it is zero extended.
It is then truncated to fit in the result type's size.
For example, if <code>v := uint16(0x10F0)</code>, then <code>uint32(int8(v)) == 0xFFFFFFF0</code>.
The conversion always yields a valid value; there is no indication of overflow.
</li>
<li>
When converting a floating-point number to an integer, the fraction is discarded
(truncation towards zero).
</li>
<li>
When converting an integer or floating-point number to a floating-point type,
or a complex number to another complex type, the result value is rounded
to the precision specified by the destination type.
For instance, the value of a variable <code>x</code> of type <code>float32</code>
may be stored using additional precision beyond that of an IEEE-754 32-bit number,
but float32(x) represents the result of rounding <code>x</code>'s value to
32-bit precision. Similarly, <code>x + 0.1</code> may use more than 32 bits
of precision, but <code>float32(x + 0.1)</code> does not.
</li>
</ol>

<p>
In all non-constant conversions involving floating-point or complex values,
if the result type cannot represent the value the conversion
succeeds but the result value is implementation-dependent.
</p>

<div class="english">
<h4 id="Conversions_to_and_from_a_string_type">Conversions to and from a string type</h4>
</div>

<h4 id="字符串类型的转换">字符串类型的转换</h4>

<ol>
<li>
Converting a signed or unsigned integer value to a string type yields a
string containing the UTF-8 representation of the integer. Values outside
the range of valid Unicode code points are converted to <code>"\uFFFD"</code>.

<pre>
string('a')       // "a"
string(-1)        // "\ufffd" == "\xef\xbf\xbd "
string(0xf8)      // "\u00f8" == "ø" == "\xc3\xb8"
type MyString string
MyString(0x65e5)  // "\u65e5" == "日" == "\xe6\x97\xa5"
</pre>
</li>

<li>
Converting a slice of bytes to a string type yields
a string whose successive bytes are the elements of the slice.  If
the slice value is <code>nil</code>, the result is the empty string.

<pre>
string([]byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"

type MyBytes []byte
string(MyBytes{'h', 'e', 'l', 'l', '\xc3', '\xb8'})  // "hellø"
</pre>
</li>

<li>
Converting a slice of runes to a string type yields
a string that is the concatenation of the individual rune values
converted to strings.  If the slice value is <code>nil</code>, the
result is the empty string.

<pre>
string([]rune{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"

type MyRunes []rune
string(MyRunes{0x767d, 0x9d6c, 0x7fd4})  // "\u767d\u9d6c\u7fd4" == "白鵬翔"
</pre>
</li>

<li>
Converting a value of a string type to a slice of bytes type
yields a slice whose successive elements are the bytes of the string.
If the string is empty, the result is <code>[]byte(nil)</code>.

<pre>
[]byte("hellø")   // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
MyBytes("hellø")  // []byte{'h', 'e', 'l', 'l', '\xc3', '\xb8'}
</pre>
</li>

<li>
Converting a value of a string type to a slice of runes type
yields a slice containing the individual Unicode code points of the string.
If the string is empty, the result is <code>[]rune(nil)</code>.
<pre>
[]rune(MyString("白鵬翔"))  // []rune{0x767d, 0x9d6c, 0x7fd4}
MyRunes("白鵬翔")           // []rune{0x767d, 0x9d6c, 0x7fd4}
</pre>
</li>
</ol>


<div class="english">
<h3 id="Constant_expressions">Constant expressions</h3>
</div>

<h3 id="常量表达式">常量表达式</h3>

<p>
Constant expressions may contain only <a href="#Constants">constant</a>
operands and are evaluated at compile-time.
</p>

<p>
Untyped boolean, numeric, and string constants may be used as operands
wherever it is legal to use an operand of boolean, numeric, or string type,
respectively.
Except for shift operations, if the operands of a binary operation are
different kinds of untyped constants, the operation and, for non-boolean operations, the result use
the kind that appears later in this list: integer, character, floating-point, complex.
For example, an untyped integer constant divided by an
untyped complex constant yields an untyped complex constant.
</p>

<p>
A constant <a href="#Comparison_operators">comparison</a> always yields
an untyped boolean constant.  If the left operand of a constant
<a href="#Operators">shift expression</a> is an untyped constant, the
result is an integer constant; otherwise it is a constant of the same
type as the left operand, which must be of integer type
(§<a href="#Arithmetic_operators">Arithmetic operators</a>).
Applying all other operators to untyped constants results in an untyped
constant of the same kind (that is, a boolean, integer, floating-point,
complex, or string constant).
</p>

<pre>
const a = 2 + 3.0          // a == 5.0   (untyped floating-point constant)
const b = 15 / 4           // b == 3     (untyped integer constant)
const c = 15 / 4.0         // c == 3.75  (untyped floating-point constant)
const Θ float64 = 3/2      // Θ == 1.5   (type float64)
const d = 1 &lt;&lt; 3.0         // d == 8     (untyped integer constant)
const e = 1.0 &lt;&lt; 3         // e == 8     (untyped integer constant)
const f = int32(1) &lt;&lt; 33   // f == 0     (type int32)
const g = float64(2) &gt;&gt; 1  // illegal    (float64(2) is a typed floating-point constant)
const h = "foo" &gt; "bar"    // h == true  (untyped boolean constant)
const j = true             // j == true  (untyped boolean constant)
const k = 'w' + 1          // k == 'x'   (untyped character constant)
const l = "hi"             // l == "hi"  (untyped string constant)
const m = string(k)        // m == "x"   (type string)
const Σ = 1 - 0.707i       //            (untyped complex constant)
const Δ = Σ + 2.0e-4       //            (untyped complex constant)
const Φ = iota*1i - 1/1i   //            (untyped complex constant)
</pre>

<p>
Applying the built-in function <code>complex</code> to untyped
integer, character, or floating-point constants yields
an untyped complex constant.
</p>

<pre>
const ic = complex(0, c)   // ic == 3.75i (untyped complex constant)
const iΘ = complex(0, Θ)   // iΘ == 1.5i  (type complex128)
</pre>

<p>
Constant expressions are always evaluated exactly; intermediate values and the
constants themselves may require precision significantly larger than supported
by any predeclared type in the language. The following are legal declarations:
</p>

<pre>
const Huge = 1 &lt;&lt; 100
const Four int8 = Huge &gt;&gt; 98
</pre>

<p>
The values of <i>typed</i> constants must always be accurately representable as values
of the constant type. The following constant expressions are illegal:
</p>

<pre>
uint(-1)     // -1 cannot be represented as a uint
int(3.14)    // 3.14 cannot be represented as an int
int64(Huge)  // 1&lt;&lt;100 cannot be represented as an int64
Four * 300   // 300 cannot be represented as an int8
Four * 100   // 400 cannot be represented as an int8
</pre>

<p>
The mask used by the unary bitwise complement operator <code>^</code> matches
the rule for non-constants: the mask is all 1s for unsigned constants
and -1 for signed and untyped constants.
</p>

<pre>
^1         // untyped integer constant, equal to -2
uint8(^1)  // error, same as uint8(-2), out of range
^uint8(1)  // typed uint8 constant, same as 0xFF ^ uint8(1) = uint8(0xFE)
int8(^1)   // same as int8(-2)
^int8(1)   // same as -1 ^ int8(1) = -2
</pre>

<p>
Implementation restriction: A compiler may use rounding while
computing untyped floating-point or complex constant expressions; see
the implementation restriction in the section
on <a href="#Constants">constants</a>.  This rounding may cause a
floating-point constant expression to be invalid in an integer
context, even if it would be integral when calculated using infinite
precision.
</p>

<!--
<p>
<span class="alert">
TODO: perhaps ^ should be disallowed on non-uints instead of assuming twos complement.
Also it may be possible to make typed constants more like variables, at the cost of fewer
overflow etc. errors being caught.
</span>
</p>
-->

<!--
<p>
<span class="alert">
TODO: 也许 ^ 应当禁止用于非无符号整数，而不是采取二进制补码。
它可能会使有类型声明的常量更像变量，以更小的代价捕获溢出等错误。
</span>
</p>
-->

<div class="english">
<h3 id="Order_of_evaluation">Order of evaluation</h3>
</div>

<h3 id="求值顺序">求值顺序</h3>

<p>
When evaluating the elements of an assignment or expression,
all function calls, method calls and
communication operations are evaluated in lexical left-to-right
order.
</p>

<p>
For example, in the assignment
</p>
<pre>
y[f()], ok = g(h(), i()+x[j()], &lt;-c), k()
</pre>
<p>
the function calls and communication happen in the order
<code>f()</code>, <code>h()</code>, <code>i()</code>, <code>j()</code>,
<code>&lt;-c</code>, <code>g()</code>, and <code>k()</code>.
However, the order of those events compared to the evaluation
and indexing of <code>x</code> and the evaluation
of <code>y</code> is not specified.
</p>

<p>
Floating-point operations within a single expression are evaluated according to
the associativity of the operators.  Explicit parentheses affect the evaluation
by overriding the default associativity.
In the expression <code>x + (y + z)</code> the addition <code>y + z</code>
is performed before adding <code>x</code>.
</p>

<div class="english">
<h2 id="Statements">Statements</h2>
</div>

<h2 id="语句">语句</h2>

<p>
Statements control execution.
</p>

<pre class="ebnf">
Statement =
	Declaration | LabeledStmt | SimpleStmt |
	GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt |
	FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt |
	DeferStmt .

SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
</pre>


<div class="english">
<h3 id="Empty_statements">Empty statements</h3>
</div>

<h3 id="空语句">空语句</h3>

<p>
The empty statement does nothing.
</p>

<pre class="ebnf">
EmptyStmt = .
</pre>


<div class="english">
<h3 id="Labeled_statements">Labeled statements</h3>
</div>

<h3 id="已标签语句">已标签语句</h3>

<p>
A labeled statement may be the target of a <code>goto</code>,
<code>break</code> or <code>continue</code> statement.
</p>

<pre class="ebnf">
LabeledStmt = Label ":" Statement .
Label       = identifier .
</pre>

<pre>
Error: log.Panic("error encountered")
</pre>


<div class="english">
<h3 id="Expression_statements">Expression statements</h3>
</div>

<h3 id="表达式语句">表达式语句</h3>

<p>
Function calls, method calls, and receive operations
can appear in statement context. Such statements may be parenthesized.
</p>

<pre class="ebnf">
ExpressionStmt = Expression .
</pre>

<pre>
h(x+y)
f.Close()
&lt;-ch
(&lt;-ch)
</pre>


<div class="english">
<h3 id="Send_statements">Send statements</h3>
</div>

<h3 id="发送语句">发送语句</h3>

<p>
A send statement sends a value on a channel.
The channel expression must be of <a href="#Channel_types">channel type</a>
and the type of the value must be <a href="#Assignability">assignable</a>
to the channel's element type.
</p>

<pre class="ebnf">
SendStmt = Channel "&lt;-" Expression .
Channel  = Expression .
</pre>

<p>
Both the channel and the value expression are evaluated before communication
begins. Communication blocks until the send can proceed.
A send on an unbuffered channel can proceed if a receiver is ready.
A send on a buffered channel can proceed if there is room in the buffer.
A send on a closed channel proceeds by causing a <a href="#Run_time_panics">run-time panic</a>.
A send on a <code>nil</code> channel blocks forever.
</p>

<pre>
ch &lt;- 3
</pre>


<div class="english">
<h3 id="IncDec_statements">IncDec statements</h3>
</div>

<h3 id="递增递减语句">递增递减语句</h3>

<p>
The "++" and "--" statements increment or decrement their operands
by the untyped <a href="#Constants">constant</a> <code>1</code>.
As with an assignment, the operand must be <a href="#Address_operators">addressable</a>
or a map index expression.
</p>

<pre class="ebnf">
IncDecStmt = Expression ( "++" | "--" ) .
</pre>

<p>
The following <a href="#Assignments">assignment statements</a> are semantically
equivalent:
</p>

<pre class="grammar">
IncDec statement    Assignment
x++                 x += 1
x--                 x -= 1
</pre>



<div class="english">
<h3 id="Assignments">Assignments</h3>
</div>

<h3 id="赋值">赋值</h3>

<pre class="ebnf">
Assignment = ExpressionList assign_op ExpressionList .

assign_op = [ add_op | mul_op ] "=" .
</pre>

<p>
Each left-hand side operand must be <a href="#Address_operators">addressable</a>,
a map index expression, or the <a href="#Blank_identifier">blank identifier</a>.
Operands may be parenthesized.
</p>

<pre>
x = 1
*p = f()
a[i] = 23
(k) = &lt;-ch  // same as: k = &lt;-ch
</pre>

<p>
An <i>assignment operation</i> <code>x</code> <i>op</i><code>=</code>
<code>y</code> where <i>op</i> is a binary arithmetic operation is equivalent
to <code>x</code> <code>=</code> <code>x</code> <i>op</i>
<code>y</code> but evaluates <code>x</code>
only once.  The <i>op</i><code>=</code> construct is a single token.
In assignment operations, both the left- and right-hand expression lists
must contain exactly one single-valued expression.
</p>

<pre>
a[i] &lt;&lt;= 2
i &amp;^= 1&lt;&lt;n
</pre>

<p>
A tuple assignment assigns the individual elements of a multi-valued
operation to a list of variables.  There are two forms.  In the
first, the right hand operand is a single multi-valued expression
such as a function evaluation or <a href="#Channel_types">channel</a> or
<a href="#Map_types">map</a> operation or a <a href="#Type_assertions">type assertion</a>.
The number of operands on the left
hand side must match the number of values.  For instance, if
<code>f</code> is a function returning two values,
</p>

<pre>
x, y = f()
</pre>

<p>
assigns the first value to <code>x</code> and the second to <code>y</code>.
The <a href="#Blank_identifier">blank identifier</a> provides a
way to ignore values returned by a multi-valued expression:
</p>

<pre>
x, _ = f()  // ignore second value returned by f()
</pre>

<p>
In the second form, the number of operands on the left must equal the number
of expressions on the right, each of which must be single-valued, and the
<i>n</i>th expression on the right is assigned to the <i>n</i>th
operand on the left.  The assignment proceeds in two phases.
First, the operands of <a href="#Indexes">index expressions</a>
and <a href="#Address_operators">pointer indirections</a>
(including implicit pointer indirections in <a href="#Selectors">selectors</a>)
on the left and the expressions on the right are all
<a href="#Order_of_evaluation">evaluated in the usual order</a>.
Second, the assignments are carried out in left-to-right order.
</p>

<pre>
a, b = b, a  // exchange a and b

x := []int{1, 2, 3}
i := 0
i, x[i] = 1, 2  // set i = 1, x[0] = 2

i = 0
x[i], i = 2, 1  // set x[0] = 2, i = 1

x[0], x[0] = 1, 2  // set x[0] = 1, then x[0] = 2 (so x[0] = 2 at end)

x[1], x[3] = 4, 5  // set x[1] = 4, then panic setting x[3] = 5.

type Point struct { x, y int }
var p *Point
x[2], p.x = 6, 7  // set x[2] = 6, then panic setting p.x = 7
</pre>

<p>
In assignments, each value must be
<a href="#Assignability">assignable</a> to the type of the
operand to which it is assigned. If an untyped <a href="#Constants">constant</a>
is assigned to a variable of interface type, the constant is <a href="#Conversions">converted</a>
to type <code>bool</code>, <code>rune</code>, <code>int</code>, <code>float64</code>,
<code>complex128</code> or <code>string</code>
respectively, depending on whether the value is a
boolean, character, integer, floating-point, complex, or string constant.
</p>


<div class="english">
<h3 id="If_statements">If statements</h3>
</div>

<h3 id="If语句">If语句</h3>

<p>
"If" statements specify the conditional execution of two branches
according to the value of a boolean expression.  If the expression
evaluates to true, the "if" branch is executed, otherwise, if
present, the "else" branch is executed.
</p>

<pre class="ebnf">
IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] .
</pre>

<pre>
if x &gt; max {
	x = max
}
</pre>

<p>
The expression may be preceded by a simple statement, which
executes before the expression is evaluated.
</p>

<pre>
if x := f(); x &lt; y {
	return x
} else if x &gt; z {
	return z
} else {
	return y
}
</pre>


<div class="english">
<h3 id="Switch_statements">Switch statements</h3>
</div>

<h3 id="Switch语句">Switch语句</h3>

<p>
"Switch" statements provide multi-way execution.
An expression or type specifier is compared to the "cases"
inside the "switch" to determine which branch
to execute.
</p>

<pre class="ebnf">
SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
</pre>

<p>
There are two forms: expression switches and type switches.
In an expression switch, the cases contain expressions that are compared
against the value of the switch expression.
In a type switch, the cases contain types that are compared against the
type of a specially annotated switch expression.
</p>

<div class="english">
<h4 id="Expression_switches">Expression switches</h4>
</div>

<h4 id="表达式选择">表达式选择</h4>

<p>
In an expression switch,
the switch expression is evaluated and
the case expressions, which need not be constants,
are evaluated left-to-right and top-to-bottom; the first one that equals the
switch expression
triggers execution of the statements of the associated case;
the other cases are skipped.
If no case matches and there is a "default" case,
its statements are executed.
There can be at most one default case and it may appear anywhere in the
"switch" statement.
A missing switch expression is equivalent to
the expression <code>true</code>.
</p>

<pre class="ebnf">
ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .
ExprCaseClause = ExprSwitchCase ":" { Statement ";" } .
ExprSwitchCase = "case" ExpressionList | "default" .
</pre>

<p>
In a case or default clause,
the last statement only may be a "fallthrough" statement
(§<a href="#Fallthrough_statements">Fallthrough statement</a>) to
indicate that control should flow from the end of this clause to
the first statement of the next clause.
Otherwise control flows to the end of the "switch" statement.
</p>

<p>
The expression may be preceded by a simple statement, which
executes before the expression is evaluated.
</p>

<pre>
switch tag {
default: s3()
case 0, 1, 2, 3: s1()
case 4, 5, 6, 7: s2()
}

switch x := f(); {  // missing switch expression means "true"
case x &lt; 0: return -x
default: return x
}

switch {
case x &lt; y: f1()
case x &lt; z: f2()
case x == 4: f3()
}
</pre>

<div class="english">
<h4 id="Type_switches">Type switches</h4>
</div>

<h4 id="类型选择">类型选择</h4>

<p>
A type switch compares types rather than values. It is otherwise similar
to an expression switch. It is marked by a special switch expression that
has the form of a <a href="#Type_assertions">type assertion</a>
using the reserved word <code>type</code> rather than an actual type.
Cases then match literal types against the dynamic type of the expression
in the type assertion.
</p>

<pre class="ebnf">
TypeSwitchStmt  = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .
TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
TypeCaseClause  = TypeSwitchCase ":" { Statement ";" } .
TypeSwitchCase  = "case" TypeList | "default" .
TypeList        = Type { "," Type } .
</pre>

<p>
The TypeSwitchGuard may include a
<a href="#Short_variable_declarations">short variable declaration</a>.
When that form is used, the variable is declared at the beginning of
the <a href="#Blocks">implicit block</a> in each clause.
In clauses with a case listing exactly one type, the variable
has that type; otherwise, the variable has the type of the expression
in the TypeSwitchGuard.
</p>

<p>
The type in a case may be <code>nil</code>
(§<a href="#Predeclared_identifiers">Predeclared identifiers</a>);
that case is used when the expression in the TypeSwitchGuard
is a <code>nil</code> interface value.
</p>

<p>
Given an expression <code>x</code> of type <code>interface{}</code>,
the following type switch:
</p>

<pre>
switch i := x.(type) {
case nil:
	printString("x is nil")
case int:
	printInt(i)  // i is an int
case float64:
	printFloat64(i)  // i is a float64
case func(int) float64:
	printFunction(i)  // i is a function
case bool, string:
	printString("type is bool or string")  // i is an interface{}
default:
	printString("don't know the type")
}
</pre>

<p>
could be rewritten:
</p>

<pre>
v := x  // x is evaluated exactly once
if v == nil {
	printString("x is nil")
} else if i, isInt := v.(int); isInt {
	printInt(i)  // i is an int
} else if i, isFloat64 := v.(float64); isFloat64 {
	printFloat64(i)  // i is a float64
} else if i, isFunc := v.(func(int) float64); isFunc {
	printFunction(i)  // i is a function
} else {
	i1, isBool := v.(bool)
	i2, isString := v.(string)
	if isBool || isString {
		i := v
		printString("type is bool or string")  // i is an interface{}
	} else {
		i := v
		printString("don't know the type")  // i is an interface{}
	}
}
</pre>

<p>
The type switch guard may be preceded by a simple statement, which
executes before the guard is evaluated.
</p>

<p>
The "fallthrough" statement is not permitted in a type switch.
</p>

<div class="english">
<h3 id="For_statements">For statements</h3>
</div>

<h3 id="For语句">For语句</h3>

<p>
A "for" statement specifies repeated execution of a block. The iteration is
controlled by a condition, a "for" clause, or a "range" clause.
</p>

<pre class="ebnf">
ForStmt = "for" [ Condition | ForClause | RangeClause ] Block .
Condition = Expression .
</pre>

<p>
In its simplest form, a "for" statement specifies the repeated execution of
a block as long as a boolean condition evaluates to true.
The condition is evaluated before each iteration.
If the condition is absent, it is equivalent to <code>true</code>.
</p>

<pre>
for a &lt; b {
	a *= 2
}
</pre>

<p>
A "for" statement with a ForClause is also controlled by its condition, but
additionally it may specify an <i>init</i>
and a <i>post</i> statement, such as an assignment,
an increment or decrement statement. The init statement may be a
<a href="#Short_variable_declarations">short variable declaration</a>, but the post statement must not.
</p>

<pre class="ebnf">
ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
InitStmt = SimpleStmt .
PostStmt = SimpleStmt .
</pre>

<pre>
for i := 0; i &lt; 10; i++ {
	f(i)
}
</pre>

<p>
If non-empty, the init statement is executed once before evaluating the
condition for the first iteration;
the post statement is executed after each execution of the block (and
only if the block was executed).
Any element of the ForClause may be empty but the
<a href="#Semicolons">semicolons</a> are
required unless there is only a condition.
If the condition is absent, it is equivalent to <code>true</code>.
</p>

<pre>
for cond { S() }    is the same as    for ; cond ; { S() }
for      { S() }    is the same as    for true     { S() }
</pre>

<p>
A "for" statement with a "range" clause
iterates through all entries of an array, slice, string or map,
or values received on a channel. For each entry it assigns <i>iteration values</i>
to corresponding <i>iteration variables</i> and then executes the block.
</p>

<pre class="ebnf">
RangeClause = Expression [ "," Expression ] ( "=" | ":=" ) "range" Expression .
</pre>

<p>
The expression on the right in the "range" clause is called the <i>range expression</i>,
which may be an array, pointer to an array, slice, string, map, or channel.
As with an assignment, the operands on the left must be
<a href="#Address_operators">addressable</a> or map index expressions; they
denote the iteration variables. If the range expression is a channel, only
one iteration variable is permitted, otherwise there may be one or two.
If the second iteration variable is the <a href="#Blank_identifier">blank identifier</a>,
the range clause is equivalent to the same clause with only the first variable present.
</p>

<p>
The range expression is evaluated once before beginning the loop
except if the expression is an array, in which case, depending on
the expression, it might not be evaluated (see below).
Function calls on the left are evaluated once per iteration.
For each iteration, iteration values are produced as follows:
</p>

<pre class="grammar">
Range expression                          1st value          2nd value (if 2nd variable is present)

array or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E
string          s  string type            index    i  int    see below  rune
map             m  map[K]V                key      k  K      m[k]       V
channel         c  chan E                 element  e  E
</pre>

<ol>
<li>
For an array, pointer to array, or slice value <code>a</code>, the index iteration
values are produced in increasing order, starting at element index 0. As a special
case, if only the first iteration variable is present, the range loop produces
iteration values from 0 up to <code>len(a)</code> and does not index into the array
or slice itself. For a <code>nil</code> slice, the number of iterations is 0.
</li>

<li>
For a string value, the "range" clause iterates over the Unicode code points
in the string starting at byte index 0.  On successive iterations, the index value will be the
index of the first byte of successive UTF-8-encoded code points in the string,
and the second value, of type <code>rune</code>, will be the value of
the corresponding code point.  If the iteration encounters an invalid
UTF-8 sequence, the second value will be <code>0xFFFD</code>,
the Unicode replacement character, and the next iteration will advance
a single byte in the string.
</li>

<li>
The iteration order over maps is not specified
and is not guaranteed to be the same from one iteration to the next.
If map entries that have not yet been reached are deleted during iteration,
the corresponding iteration values will not be produced. If map entries are
inserted during iteration, the behavior is implementation-dependent, but the
iteration values for each entry will be produced at most once. If the map
is <code>nil</code>, the number of iterations is 0.
</li>

<li>
For channels, the iteration values produced are the successive values sent on
the channel until the channel is <a href="#Close">closed</a>. If the channel
is <code>nil</code>, the range expression blocks forever.
</li>
</ol>

<p>
The iteration values are assigned to the respective
iteration variables as in an <a href="#Assignments">assignment statement</a>.
</p>

<p>
The iteration variables may be declared by the "range" clause using a form of
<a href="#Short_variable_declarations">short variable declaration</a>
(<code>:=</code>).
In this case their types are set to the types of the respective iteration values
and their <a href="#Declarations_and_scope">scope</a> ends at the end of the "for"
statement; they are re-used in each iteration.
If the iteration variables are declared outside the "for" statement,
after execution their values will be those of the last iteration.
</p>

<pre>
var testdata *struct {
	a *[7]int
}
for i, _ := range testdata.a {
	// testdata.a is never evaluated; len(testdata.a) is constant
	// i ranges from 0 to 6
	f(i)
}

var a [10]string
m := map[string]int{"mon":0, "tue":1, "wed":2, "thu":3, "fri":4, "sat":5, "sun":6}
for i, s := range a {
	// type of i is int
	// type of s is string
	// s == a[i]
	g(i, s)
}

var key string
var val interface {}  // value type of m is assignable to val
for key, val = range m {
	h(key, val)
}
// key == last map key encountered in iteration
// val == map[key]

var ch chan Work = producer()
for w := range ch {
	doWork(w)
}
</pre>


<div class="english">
<h3 id="Go_statements">Go statements</h3>
</div>

<h3 id="Go语句">Go语句</h3>

<p>
A "go" statement starts the execution of a function or method call
as an independent concurrent thread of control, or <i>goroutine</i>,
within the same address space.
</p>

<pre class="ebnf">
GoStmt = "go" Expression .
</pre>

<p>
The expression must be a call.
The function value and parameters are
<a href="#Calls">evaluated as usual</a>
in the calling goroutine, but
unlike with a regular call, program execution does not wait
for the invoked function to complete.
Instead, the function begins executing independently
in a new goroutine.
When the function terminates, its goroutine also terminates.
If the function has any return values, they are discarded when the
function completes.
</p>

<pre>
go Server()
go func(ch chan&lt;- bool) { for { sleep(10); ch &lt;- true; }} (c)
</pre>


<div class="english">
<h3 id="Select_statements">Select statements</h3>
</div>

<h3 id="Select语句">Select语句</h3>

<p>
A "select" statement chooses which of a set of possible communications
will proceed.  It looks similar to a "switch" statement but with the
cases all referring to communication operations.
</p>

<pre class="ebnf">
SelectStmt = "select" "{" { CommClause } "}" .
CommClause = CommCase ":" { Statement ";" } .
CommCase   = "case" ( SendStmt | RecvStmt ) | "default" .
RecvStmt   = [ Expression [ "," Expression ] ( "=" | ":=" ) ] RecvExpr .
RecvExpr   = Expression .
</pre>

<p>
RecvExpr must be a <a href="#Receive_operator">receive operation</a>.
For all the cases in the "select"
statement, the channel expressions are evaluated in top-to-bottom order, along with
any expressions that appear on the right hand side of send statements.
A channel may be <code>nil</code>,
which is equivalent to that case not
being present in the select statement
except, if a send, its expression is still evaluated.
If any of the resulting operations can proceed, one of those is
chosen and the corresponding communication and statements are
evaluated.  Otherwise, if there is a default case, that executes;
if there is no default case, the statement blocks until one of the communications can
complete.
If there are no cases with non-<code>nil</code> channels,
the statement blocks forever.
Even if the statement blocks,
the channel and send expressions are evaluated only once,
upon entering the select statement.
</p>
<p>
Since all the channels and send expressions are evaluated, any side
effects in that evaluation will occur for all the communications
in the "select" statement.
</p>
<p>
If multiple cases can proceed, a uniform pseudo-random choice is made to decide
which single communication will execute.
<p>
The receive case may declare one or two new variables using a
<a href="#Short_variable_declarations">short variable declaration</a>.
</p>

<pre>
var c, c1, c2, c3 chan int
var i1, i2 int
select {
case i1 = &lt;-c1:
	print("received ", i1, " from c1\n")
case c2 &lt;- i2:
	print("sent ", i2, " to c2\n")
case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3
	if ok {
		print("received ", i3, " from c3\n")
	} else {
		print("c3 is closed\n")
	}
default:
	print("no communication\n")
}

for {  // send random sequence of bits to c
	select {
	case c &lt;- 0:  // note: no statement, no fallthrough, no folding of cases
	case c &lt;- 1:
	}
}

select {}  // block forever
</pre>


<div class="english">
<h3 id="Return_statements">Return statements</h3>
</div>

<h3 id="Return语句">Return语句</h3>

<p>
A "return" statement terminates execution of the containing function
and optionally provides a result value or values to the caller.
</p>

<pre class="ebnf">
ReturnStmt = "return" [ ExpressionList ] .
</pre>

<p>
In a function without a result type, a "return" statement must not
specify any result values.
</p>
<pre>
func noResult() {
	return
}
</pre>

<p>
There are three ways to return values from a function with a result
type:
</p>

<ol>
	<li>The return value or values may be explicitly listed
		in the "return" statement. Each expression must be single-valued
		and <a href="#Assignability">assignable</a>
		to the corresponding element of the function's result type.
<pre>
func simpleF() int {
	return 2
}

func complexF1() (re float64, im float64) {
	return -7.0, -4.0
}
</pre>
	</li>
	<li>The expression list in the "return" statement may be a single
		call to a multi-valued function. The effect is as if each value
		returned from that function were assigned to a temporary
		variable with the type of the respective value, followed by a
		"return" statement listing these variables, at which point the
		rules of the previous case apply.
<pre>
func complexF2() (re float64, im float64) {
	return complexF1()
}
</pre>
	</li>
	<li>The expression list may be empty if the function's result
		type specifies names for its result parameters (§<a href="#Function_types">Function Types</a>).
		The result parameters act as ordinary local variables
		and the function may assign values to them as necessary.
		The "return" statement returns the values of these variables.
<pre>
func complexF3() (re float64, im float64) {
	re = 7.0
	im = 4.0
	return
}

func (devnull) Write(p []byte) (n int, _ error) {
	n = len(p)
	return
}
</pre>
	</li>
</ol>

<p>
Regardless of how they are declared, all the result values are initialized to the zero values for their type (§<a href="#The_zero_value">The zero value</a>) upon entry to the function.
</p>

<!--
<p>
<span class="alert">
TODO: Define when return is required.<br />
</span>
</p>
-->

<!--
<p>
<span class="alert">
TODO: 定义什么时候需要返回。<br />
</span>
</p>
-->

<div class="english">
<h3 id="Break_statements">Break statements</h3>
</div>

<h3 id="Break语句">Break语句</h3>

<p>
A "break" statement terminates execution of the innermost
"for", "switch" or "select" statement.
</p>

<pre class="ebnf">
BreakStmt = "break" [ Label ] .
</pre>

<p>
If there is a label, it must be that of an enclosing
"for", "switch" or "select" statement, and that is the one whose execution
terminates
(§<a href="#For_statements">For statements</a>, §<a href="#Switch_statements">Switch statements</a>, §<a href="#Select_statements">Select statements</a>).
</p>

<pre>
L:
	for i &lt; n {
		switch i {
		case 5:
			break L
		}
	}
</pre>

<div class="english">
<h3 id="Continue_statements">Continue statements</h3>
</div>

<h3 id="Continue语句">Continue语句</h3>

<p>
A "continue" statement begins the next iteration of the
innermost "for" loop at its post statement (§<a href="#For_statements">For statements</a>).
</p>

<pre class="ebnf">
ContinueStmt = "continue" [ Label ] .
</pre>

<p>
If there is a label, it must be that of an enclosing
"for" statement, and that is the one whose execution
advances
(§<a href="#For_statements">For statements</a>).
</p>

<div class="english">
<h3 id="Goto_statements">Goto statements</h3>
</div>

<h3 id="Goto语句">Goto语句</h3>

<p>
A "goto" statement transfers control to the statement with the corresponding label.
</p>

<pre class="ebnf">
GotoStmt = "goto" Label .
</pre>

<pre>
goto Error
</pre>

<p>
Executing the "goto" statement must not cause any variables to come into
<a href="#Declarations_and_scope">scope</a> that were not already in scope at the point of the goto.
For instance, this example:
</p>

<pre>
	goto L  // BAD
	v := 3
L:
</pre>

<p>
is erroneous because the jump to label <code>L</code> skips
the creation of <code>v</code>.
</p>

<p>
A "goto" statement outside a <a href="#Blocks">block</a> cannot jump to a label inside that block.
For instance, this example:
</p>

<pre>
if n%2 == 1 {
	goto L1
}
for n &gt; 0 {
	f()
	n--
L1:
	f()
	n--
}
</pre>

<p>
is erroneous because the label <code>L1</code> is inside
the "for" statement's block but the <code>goto</code> is not.
</p>

<div class="english">
<h3 id="Fallthrough_statements">Fallthrough statements</h3>
</div>

<h3 id="Fallthrough语句">Fallthrough语句</h3>

<p>
A "fallthrough" statement transfers control to the first statement of the
next case clause in a expression "switch" statement (§<a href="#Expression_switches">Expression switches</a>). It may
be used only as the final non-empty statement in a case or default clause in an
expression "switch" statement.
</p>

<pre class="ebnf">
FallthroughStmt = "fallthrough" .
</pre>


<div class="english">
<h3 id="Defer_statements">Defer statements</h3>
</div>

<h3 id="Defer语句">Defer语句</h3>

<p>
A "defer" statement invokes a function whose execution is deferred to the moment
the surrounding function returns.
</p>

<pre class="ebnf">
DeferStmt = "defer" Expression .
</pre>

<p>
The expression must be a function or method call.
Each time the "defer" statement
executes, the function value and parameters to the call are
<a href="#Calls">evaluated as usual</a>
and saved anew but the
actual function is not invoked.
Instead, deferred calls are executed in LIFO order
immediately before the surrounding function returns,
after the return values, if any, have been evaluated, but before they
are returned to the caller. For instance, if the deferred function is
a <a href="#Function_literals">function literal</a> and the surrounding
function has <a href="#Function_types">named result parameters</a> that
are in scope within the literal, the deferred function may access and modify
the result parameters before they are returned.
If the deferred function has any return values, they are discarded when
the function completes.
</p>

<pre>
lock(l)
defer unlock(l)  // unlocking happens before surrounding function returns

// prints 3 2 1 0 before surrounding function returns
for i := 0; i &lt;= 3; i++ {
	defer fmt.Print(i)
}

// f returns 1
func f() (result int) {
	defer func() {
		result++
	}()
	return 0
}
</pre>

<div class="english">
<h2 id="Built-in_functions">Built-in functions</h2>
</div>

<h2 id="内建函数">内建函数</h2>

<p>
Built-in functions are
<a href="#Predeclared_identifiers">predeclared</a>.
They are called like any other function but some of them
accept a type instead of an expression as the first argument.
</p>

<p>
The built-in functions do not have standard Go types,
so they can only appear in <a href="#Calls">call expressions</a>;
they cannot be used as function values.
</p>

<pre class="ebnf">
BuiltinCall = identifier "(" [ BuiltinArgs [ "," ] ] ")" .
BuiltinArgs = Type [ "," ExpressionList ] | ExpressionList .
</pre>

<div class="english">
<h3 id="Close">Close</h3>
</div>

<h3 id="关闭">关闭</h3>

<p>
For a channel <code>c</code>, the built-in function <code>close(c)</code>
records that no more values will be sent on the channel.
It is an error if <code>c</code> is a receive-only channel.
Sending to or closing a closed channel causes a <a href="#Run_time_panics">run-time panic</a>.
Closing the nil channel also causes a <a href="#Run_time_panics">run-time panic</a>.
After calling <code>close</code>, and after any previously
sent values have been received, receive operations will return
the zero value for the channel's type without blocking.
The multi-valued <a href="#Receive_operator">receive operation</a>
returns a received value along with an indication of whether the channel is closed.
</p>


<div class="english">
<h3 id="Length_and_capacity">Length and capacity</h3>
</div>

<h3 id="长度与容量">长度与容量</h3>

<p>
The built-in functions <code>len</code> and <code>cap</code> take arguments
of various types and return a result of type <code>int</code>.
The implementation guarantees that the result always fits into an <code>int</code>.
</p>

<pre class="grammar">
Call      Argument type    Result

len(s)    string type      string length in bytes
          [n]T, *[n]T      array length (== n)
          []T              slice length
          map[K]T          map length (number of defined keys)
          chan T           number of elements queued in channel buffer

cap(s)    [n]T, *[n]T      array length (== n)
          []T              slice capacity
          chan T           channel buffer capacity
</pre>

<p>
The capacity of a slice is the number of elements for which there is
space allocated in the underlying array.
At any time the following relationship holds:
</p>

<pre>
0 &lt;= len(s) &lt;= cap(s)
</pre>

<p>
The length and capacity of a <code>nil</code> slice, map, or channel are 0.
</p>

<p>
The expression <code>len(s)</code> is <a href="#Constants">constant</a> if
<code>s</code> is a string constant. The expressions <code>len(s)</code> and
<code>cap(s)</code> are constants if the type of <code>s</code> is an array
or pointer to an array and the expression <code>s</code> does not contain
<a href="#Receive_operator">channel receives</a> or
<a href="#Calls">function calls</a>; in this case <code>s</code> is not evaluated.
Otherwise, invocations of <code>len</code> and <code>cap</code> are not
constant and <code>s</code> is evaluated.
</p>


<div class="english">
<h3 id="Allocation">Allocation</h3>
</div>

<h3 id="分配">分配</h3>

<p>
The built-in function <code>new</code> takes a type <code>T</code> and
returns a value of type <code>*T</code>.
The memory is initialized as described in the section on initial values
(§<a href="#The_zero_value">The zero value</a>).
</p>

<pre class="grammar">
new(T)
</pre>

<p>
For instance
</p>

<pre>
type S struct { a int; b float64 }
new(S)
</pre>

<p>
dynamically allocates memory for a variable of type <code>S</code>,
initializes it (<code>a=0</code>, <code>b=0.0</code>),
and returns a value of type <code>*S</code> containing the address
of the memory.
</p>

<div class="english">
<h3 id="Making_slices_maps_and_channels">Making slices, maps and channels</h3>
</div>

<h3 id="创建切片、映射与信道">创建切片、映射与信道</h3>

<p>
Slices, maps and channels are reference types that do not require the
extra indirection of an allocation with <code>new</code>.
The built-in function <code>make</code> takes a type <code>T</code>,
which must be a slice, map or channel type,
optionally followed by a type-specific list of expressions.
It returns a value of type <code>T</code> (not <code>*T</code>).
The memory is initialized as described in the section on initial values
(§<a href="#The_zero_value">The zero value</a>).
</p>

<pre class="grammar">
Call             Type T     Result

make(T, n)       slice      slice of type T with length n and capacity n
make(T, n, m)    slice      slice of type T with length n and capacity m

make(T)          map        map of type T
make(T, n)       map        map of type T with initial space for n elements

make(T)          channel    synchronous channel of type T
make(T, n)       channel    asynchronous channel of type T, buffer size n
</pre>


<p>
The arguments <code>n</code> and <code>m</code> must be of integer type.
A <a href="#Run_time_panics">run-time panic</a> occurs if <code>n</code>
is negative or larger than <code>m</code>, or if <code>n</code> or
<code>m</code> cannot be represented by an <code>int</code>.
</p>

<pre>
s := make([]int, 10, 100)       // slice with len(s) == 10, cap(s) == 100
s := make([]int, 10)            // slice with len(s) == cap(s) == 10
c := make(chan int, 10)         // channel with a buffer size of 10
m := make(map[string]int, 100)  // map with initial space for 100 elements
</pre>


<div class="english">
<h3 id="Appending_and_copying_slices">Appending to and copying slices</h3>
</div>

<h3 id="合并与复制切片">合并与复制切片</h3>

<p>
Two built-in functions assist in common slice operations.
</p>

<p>
The <a href="#Function_types">variadic</a> function <code>append</code>
appends zero or more values <code>x</code>
to <code>s</code> of type <code>S</code>, which must be a slice type, and
returns the resulting slice, also of type <code>S</code>.
The values <code>x</code> are passed to a parameter of type <code>...T</code>
where <code>T</code> is the <a href="#Slice_types">element type</a> of
<code>S</code> and the respective
<a href="#Passing_arguments_to_..._parameters">parameter passing rules</a> apply.
As a special case, <code>append</code> also accepts a first argument
assignable to type <code>[]byte</code> with a second argument of
string type followed by <code>...</code>. This form appends the
bytes of the string.
</p>

<pre class="grammar">
append(s S, x ...T) S  // T is the element type of S
</pre>

<p>
If the capacity of <code>s</code> is not large enough to fit the additional
values, <code>append</code> allocates a new, sufficiently large slice that fits
both the existing slice elements and the additional values. Thus, the returned
slice may refer to a different underlying array.
</p>

<pre>
s0 := []int{0, 0}
s1 := append(s0, 2)        // append a single element     s1 == []int{0, 0, 2}
s2 := append(s1, 3, 5, 7)  // append multiple elements    s2 == []int{0, 0, 2, 3, 5, 7}
s3 := append(s2, s0...)    // append a slice              s3 == []int{0, 0, 2, 3, 5, 7, 0, 0}

var t []interface{}
t = append(t, 42, 3.1415, "foo")                          t == []interface{}{42, 3.1415, "foo"}

var b []byte
b = append(b, "bar"...)  // append string contents      b == []byte{'b', 'a', 'r' }
</pre>

<p>
The function <code>copy</code> copies slice elements from
a source <code>src</code> to a destination <code>dst</code> and returns the
number of elements copied. Source and destination may overlap.
Both arguments must have <a href="#Type_identity">identical</a> element type <code>T</code> and must be
<a href="#Assignability">assignable</a> to a slice of type <code>[]T</code>.
The number of elements copied is the minimum of
<code>len(src)</code> and <code>len(dst)</code>.
As a special case, <code>copy</code> also accepts a destination argument assignable
to type <code>[]byte</code> with a source argument of a string type.
This form copies the bytes from the string into the byte slice.
</p>

<pre class="grammar">
copy(dst, src []T) int
copy(dst []byte, src string) int
</pre>

<p>
Examples:
</p>

<pre>
var a = [...]int{0, 1, 2, 3, 4, 5, 6, 7}
var s = make([]int, 6)
var b = make([]byte, 5)
n1 := copy(s, a[0:])            // n1 == 6, s == []int{0, 1, 2, 3, 4, 5}
n2 := copy(s, s[2:])            // n2 == 4, s == []int{2, 3, 4, 5, 4, 5}
n3 := copy(b, "Hello, World!")  // n3 == 5, b == []byte("Hello")
</pre>


<div class="english">
<h3 id="Deletion_of_map_elements">Deletion of map elements</h3>
</div>

<h3 id="映射元素的删除">映射元素的删除</h3>

<p>
The built-in function <code>delete</code> removes the element with key
<code>k</code> from a <a href="#Map_types">map</a> <code>m</code>. The
type of <code>k</code> must be <a href="#Assignability">assignable</a>
to the key type of <code>m</code>.
</p>

<pre class="grammar">
delete(m, k)  // remove element m[k] from map m
</pre>

<p>
If the element <code>m[k]</code> does not exist, <code>delete</code> is
a no-op. Calling <code>delete</code> with a nil map causes a
<a href="#Run_time_panics">run-time panic</a>.
</p>


<div class="english">
<h3 id="Complex_numbers">Manipulating complex numbers</h3>
</div>

<h3 id="操作复数">复数操作</h3>

<p>
Three functions assemble and disassemble complex numbers.
The built-in function <code>complex</code> constructs a complex
value from a floating-point real and imaginary part, while
<code>real</code> and <code>imag</code>
extract the real and imaginary parts of a complex value.
</p>

<pre class="grammar">
complex(realPart, imaginaryPart floatT) complexT
real(complexT) floatT
imag(complexT) floatT
</pre>

<p>
The type of the arguments and return value correspond.
For <code>complex</code>, the two arguments must be of the same
floating-point type and the return type is the complex type
with the corresponding floating-point constituents:
<code>complex64</code> for <code>float32</code>,
<code>complex128</code> for <code>float64</code>.
The <code>real</code> and <code>imag</code> functions
together form the inverse, so for a complex value <code>z</code>,
<code>z</code> <code>==</code> <code>complex(real(z),</code> <code>imag(z))</code>.
</p>

<p>
If the operands of these functions are all constants, the return
value is a constant.
</p>

<pre>
var a = complex(2, -2)             // complex128
var b = complex(1.0, -1.4)         // complex128
x := float32(math.Cos(math.Pi/2))  // float32
var c64 = complex(5, -x)           // complex64
var im = imag(b)                   // float64
var rl = real(c64)                 // float32
</pre>

<div class="english">
<h3 id="Handling_panics">Handling panics</h3>
</div>

<h3 id="异常处理">异常处理</h3>

<p> Two built-in functions, <code>panic</code> and <code>recover</code>,
assist in reporting and handling <a href="#Run_time_panics">run-time panics</a>
and program-defined error conditions.
</p>

<pre class="grammar">
func panic(interface{})
func recover() interface{}
</pre>

<p>
When a function <code>F</code> calls <code>panic</code>, normal
execution of <code>F</code> stops immediately.  Any functions whose
execution was <a href="#Defer_statements">deferred</a> by the
invocation of <code>F</code> are run in the usual way, and then
<code>F</code> returns to its caller.  To the caller, <code>F</code>
then behaves like a call to <code>panic</code>, terminating its own
execution and running deferred functions.  This continues until all
functions in the goroutine have ceased execution, in reverse order.
At that point, the program is
terminated and the error condition is reported, including the value of
the argument to <code>panic</code>.  This termination sequence is
called <i>panicking</i>.
</p>

<pre>
panic(42)
panic("unreachable")
panic(Error("cannot parse"))
</pre>

<p>
The <code>recover</code> function allows a program to manage behavior
of a panicking goroutine.  Executing a <code>recover</code> call
<i>inside</i> a deferred function (but not any function called by it) stops
the panicking sequence by restoring normal execution, and retrieves
the error value passed to the call of <code>panic</code>.  If
<code>recover</code> is called outside the deferred function it will
not stop a panicking sequence.  In this case, or when the goroutine
is not panicking, or if the argument supplied to <code>panic</code>
was <code>nil</code>, <code>recover</code> returns <code>nil</code>.
</p>

<p>
The <code>protect</code> function in the example below invokes
the function argument <code>g</code> and protects callers from
run-time panics raised by <code>g</code>.
</p>

<pre>
func protect(g func()) {
	defer func() {
		log.Println("done")  // Println executes normally even if there is a panic
		if x := recover(); x != nil {
			log.Printf("run time panic: %v", x)
		}
	}()
	log.Println("start")
	g()
}
</pre>


<div class="english">
<h3 id="Bootstrapping">Bootstrapping</h3>
</div>

<h3 id="引导">引导</h3>

<p>
Current implementations provide several built-in functions useful during
bootstrapping. These functions are documented for completeness but are not
guaranteed to stay in the language. They do not return a result.
</p>

<pre class="grammar">
Function   Behavior

print      prints all arguments; formatting of arguments is implementation-specific
println    like print but prints spaces between arguments and a newline at the end
</pre>


<div class="english">
<h2 id="Packages">Packages</h2>
</div>

<h2 id="包">包</h2>

<p>
Go programs are constructed by linking together <i>packages</i>.
A package in turn is constructed from one or more source files
that together declare constants, types, variables and functions
belonging to the package and which are accessible in all files
of the same package. Those elements may be
<a href="#Exported_identifiers">exported</a> and used in another package.
</p>

<div class="english">
<h3 id="Source_file_organization">Source file organization</h3>
</div>

<h3 id="源文件组织">源文件组织</h3>

<p>
Each source file consists of a package clause defining the package
to which it belongs, followed by a possibly empty set of import
declarations that declare packages whose contents it wishes to use,
followed by a possibly empty set of declarations of functions,
types, variables, and constants.
</p>

<pre class="ebnf">
SourceFile       = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
</pre>

<div class="english">
<h3 id="Package_clause">Package clause</h3>
</div>

<h3 id="包子句">包子句</h3>

<p>
A package clause begins each source file and defines the package
to which the file belongs.
</p>

<pre class="ebnf">
PackageClause  = "package" PackageName .
PackageName    = identifier .
</pre>

<p>
The PackageName must not be the <a href="#Blank_identifier">blank identifier</a>.
</p>

<pre>
package math
</pre>

<p>
A set of files sharing the same PackageName form the implementation of a package.
An implementation may require that all source files for a package inhabit the same directory.
</p>

<div class="english">
<h3 id="Import_declarations">Import declarations</h3>
</div>

<h3 id="导入声明">导入声明</h3>

<p>
An import declaration states that the source file containing the declaration
depends on functionality of the <i>imported</i> package
(<a href="#Program_initialization_and_execution">§Program initialization and execution</a>)
and it enables access to <a href="#Exported_identifiers">exported</a> identifiers
of that package.
The import names an identifier (PackageName) to be used for access and an ImportPath
that specifies the package to be imported.
</p>

<pre class="ebnf">
ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
ImportSpec       = [ "." | PackageName ] ImportPath .
ImportPath       = string_lit .
</pre>

<p>
The PackageName is used in <a href="#Qualified_identifiers">qualified identifiers</a>
to access exported identifiers of the package within the importing source file.
It is declared in the <a href="#Blocks">file block</a>.
If the PackageName is omitted, it defaults to the identifier specified in the
<a href="#Package_clause">package clause</a> of the imported package.
If an explicit period (<code>.</code>) appears instead of a name, all the
package's exported identifiers declared in that package's
<a href="#Blocks">package block</a> will be declared in the importing source
file's file block and can be accessed without a qualifier.
</p>

<p>
The interpretation of the ImportPath is implementation-dependent but
it is typically a substring of the full file name of the compiled
package and may be relative to a repository of installed packages.
</p>

<p>
Implementation restriction: A compiler may restrict ImportPaths to
non-empty strings using only characters belonging to
<a href="http://www.unicode.org/versions/Unicode6.0.0/">Unicode's</a>
L, M, N, P, and S general categories (the Graphic characters without
spaces) and may also exclude the characters
<code>!"#$%&amp;'()*,:;&lt;=&gt;?[\]^`{|}</code>
and the Unicode replacement character U+FFFD.
</p>

<p>
Assume we have compiled a package containing the package clause
<code>package math</code>, which exports function <code>Sin</code>, and
installed the compiled package in the file identified by
<code>"lib/math"</code>.
This table illustrates how <code>Sin</code> may be accessed in files
that import the package after the
various types of import declaration.
</p>

<pre class="grammar">
Import declaration          Local name of Sin

import   "lib/math"         math.Sin
import M "lib/math"         M.Sin
import . "lib/math"         Sin
</pre>

<p>
An import declaration declares a dependency relation between
the importing and imported package.
It is illegal for a package to import itself or to import a package without
referring to any of its exported identifiers. To import a package solely for
its side-effects (initialization), use the <a href="#Blank_identifier">blank</a>
identifier as explicit package name:
</p>

<pre>
import _ "lib/math"
</pre>


<div class="english">
<h3 id="An_example_package">An example package</h3>
</div>

<h3 id="一个例子包">一个例子包</h3>

<p>
Here is a complete Go package that implements a concurrent prime sieve.
</p>

<pre>
package main

import "fmt"

// Send the sequence 2, 3, 4, … to channel 'ch'.
func generate(ch chan&lt;- int) {
	for i := 2; ; i++ {
		ch &lt;- i  // Send 'i' to channel 'ch'.
	}
}

// Copy the values from channel 'src' to channel 'dst',
// removing those divisible by 'prime'.
func filter(src &lt;-chan int, dst chan&lt;- int, prime int) {
	for i := range src {  // Loop over values received from 'src'.
		if i%prime != 0 {
			dst &lt;- i  // Send 'i' to channel 'dst'.
		}
	}
}

// The prime sieve: Daisy-chain filter processes together.
func sieve() {
	ch := make(chan int)  // Create a new channel.
	go generate(ch)       // Start generate() as a subprocess.
	for {
		prime := &lt;-ch
		fmt.Print(prime, "\n")
		ch1 := make(chan int)
		go filter(ch, ch1, prime)
		ch = ch1
	}
}

func main() {
	sieve()
}
</pre>

<div class="english">
<h2 id="Program_initialization_and_execution">Program initialization and execution</h2>
</div>

<h2 id="程序初始化与执行">程序初始化与执行</h2>

<div class="english">
<h3 id="The_zero_value">The zero value</h3>
</div>

<h3 id="零值">零值</h3>

<p>
When memory is allocated to store a value, either through a declaration
or a call of <code>make</code> or <code>new</code>,
and no explicit initialization is provided, the memory is
given a default initialization.  Each element of such a value is
set to the <i>zero value</i> for its type: <code>false</code> for booleans,
<code>0</code> for integers, <code>0.0</code> for floats, <code>""</code>
for strings, and <code>nil</code> for pointers, functions, interfaces, slices, channels, and maps.
This initialization is done recursively, so for instance each element of an
array of structs will have its fields zeroed if no value is specified.
</p>
<p>
These two simple declarations are equivalent:
</p>

<pre>
var i int
var i int = 0
</pre>

<p>
After
</p>

<pre>
type T struct { i int; f float64; next *T }
t := new(T)
</pre>

<p>
the following holds:
</p>

<pre>
t.i == 0
t.f == 0.0
t.next == nil
</pre>

<p>
The same would also be true after
</p>

<pre>
var t T
</pre>

<div class="english">
<h3 id="Program_execution">Program execution</h3>
</div>

<h3 id="程序执行">程序执行</h3>

<p>
A package with no imports is initialized by assigning initial values to
all its package-level variables
and then calling any
package-level function with the name and signature of
</p>
<pre>
func init()
</pre>
<p>
defined in its source.
A package may contain multiple
<code>init</code> functions, even
within a single source file; they execute
in unspecified order.
</p>
<p>
Within a package, package-level variables are initialized,
and constant values are determined, in
data-dependent order: if the initializer of <code>A</code>
depends on the value of <code>B</code>, <code>A</code>
will be set after <code>B</code>.
It is an error if such dependencies form a cycle.
Dependency analysis is done lexically: <code>A</code>
depends on <code>B</code> if the value of <code>A</code>
contains a mention of <code>B</code>, contains a value
whose initializer
mentions <code>B</code>, or mentions a function that
mentions <code>B</code>, recursively.
If two items are not interdependent, they will be initialized
in the order they appear in the source.
Since the dependency analysis is done per package, it can produce
unspecified results  if <code>A</code>'s initializer calls a function defined
in another package that refers to <code>B</code>.
</p>
<p>
An <code>init</code> function cannot be referred to from anywhere
in a program. In particular, <code>init</code> cannot be called explicitly,
nor can a pointer to <code>init</code> be assigned to a function variable.
</p>
<p>
If a package has imports, the imported packages are initialized
before initializing the package itself. If multiple packages import
a package <code>P</code>, <code>P</code> will be initialized only once.
</p>
<p>
The importing of packages, by construction, guarantees that there can
be no cyclic dependencies in initialization.
</p>
<p>
A complete program is created by linking a single, unimported package
called the <i>main package</i> with all the packages it imports, transitively.
The main package must
have package name <code>main</code> and
declare a function <code>main</code> that takes no
arguments and returns no value.
</p>

<pre>
func main() { … }
</pre>

<p>
Program execution begins by initializing the main package and then
invoking the function <code>main</code>.
When the function <code>main</code> returns, the program exits.
It does not wait for other (non-<code>main</code>) goroutines to complete.
</p>

<p>
Package initialization&mdash;variable initialization and the invocation of
<code>init</code> functions&mdash;happens in a single goroutine,
sequentially, one package at a time.
An <code>init</code> function may launch other goroutines, which can run
concurrently with the initialization code. However, initialization
always sequences
the <code>init</code> functions: it will not start the next
<code>init</code> until
the previous one has returned.
</p>

<div class="english">
<h2 id="Errors">Errors</h2>
</div>

<h2 id="错误">错误</h2>

<p>
The predeclared type <code>error</code> is defined as
</p>

<pre>
type error interface {
	Error() string
}
</pre>

<p>
It is the conventional interface for representing an error condition,
with the nil value representing no error.
For instance, a function to read data from a file might be defined:
</p>

<pre>
func Read(f *File, b []byte) (n int, err error)
</pre>

<div class="english">
<h2 id="Run_time_panics">Run-time panics</h2>
</div>

<h2 id="运行时异常">运行时异常</h2>

<p>
Execution errors such as attempting to index an array out
of bounds trigger a <i>run-time panic</i> equivalent to a call of
the built-in function <a href="#Handling_panics"><code>panic</code></a>
with a value of the implementation-defined interface type <code>runtime.Error</code>.
That type satisfies the predeclared interface type
<a href="#Errors"><code>error</code></a>.
The exact error values that
represent distinct run-time error conditions are unspecified.
</p>

<pre>
package runtime

type Error interface {
	error
	// and perhaps other methods
}
</pre>

<div class="english">
<h2 id="System_considerations">System considerations</h2>
</div>

<h2 id="系统考虑">系统考虑</h2>

<div class="english">
<h3 id="Package_unsafe">Package <code>unsafe</code></h3>
</div>

<h3 id="包unsafe">包 <code>unsafe</code> </h3>

<p>
The built-in package <code>unsafe</code>, known to the compiler,
provides facilities for low-level programming including operations
that violate the type system. A package using <code>unsafe</code>
must be vetted manually for type safety.  The package provides the
following interface:
</p>

<pre class="grammar">
package unsafe

type ArbitraryType int  // shorthand for an arbitrary Go type; it is not a real type
type Pointer *ArbitraryType

func Alignof(variable ArbitraryType) uintptr
func Offsetof(selector ArbitraryType) uintptr
func Sizeof(variable ArbitraryType) uintptr
</pre>

<p>
Any pointer or value of <a href="#Types">underlying type</a> <code>uintptr</code> can be converted into
a <code>Pointer</code> and vice versa.
</p>
<p>
The function <code>Sizeof</code> takes an expression denoting a
variable of any type and returns the size of the variable in bytes.
</p>
<p>
The function <code>Offsetof</code> takes a selector (§<a href="#Selectors">Selectors</a>) denoting a struct
field of any type and returns the field offset in bytes relative to the
struct's address.
For a struct <code>s</code> with field <code>f</code>:
</p>

<pre>
uintptr(unsafe.Pointer(&amp;s)) + unsafe.Offsetof(s.f) == uintptr(unsafe.Pointer(&amp;s.f))
</pre>

<p>
Computer architectures may require memory addresses to be <i>aligned</i>;
that is, for addresses of a variable to be a multiple of a factor,
the variable's type's <i>alignment</i>.  The function <code>Alignof</code>
takes an expression denoting a variable of any type and returns the
alignment of the (type of the) variable in bytes.  For a variable
<code>x</code>:
</p>

<pre>
uintptr(unsafe.Pointer(&amp;x)) % unsafe.Alignof(x) == 0
</pre>

<p>
Calls to <code>Alignof</code>, <code>Offsetof</code>, and
<code>Sizeof</code> are compile-time constant expressions of type <code>uintptr</code>.
</p>
<p>

<div class="english">
<h3 id="Size_and_alignment_guarantees">Size and alignment guarantees</h3>
</div>

<h3 id="大小与对齐保证">大小与对齐保证</h3>

<p>
For the numeric types (§<a href="#Numeric_types">Numeric types</a>), the following sizes are guaranteed:
</p>

<pre class="grammar">
type                                 size in bytes

byte, uint8, int8                     1
uint16, int16                         2
uint32, int32, float32                4
uint64, int64, float64, complex64     8
complex128                           16
</pre>

<p>
The following minimal alignment properties are guaranteed:
</p>
<ol>
<li>For a variable <code>x</code> of any type: <code>unsafe.Alignof(x)</code> is at least 1.
</li>

<li>For a variable <code>x</code> of struct type: <code>unsafe.Alignof(x)</code> is the largest of
   all the values <code>unsafe.Alignof(x.f)</code> for each field <code>f</code> of <code>x</code>, but at least 1.
</li>

<li>For a variable <code>x</code> of array type: <code>unsafe.Alignof(x)</code> is the same as
   <code>unsafe.Alignof(x[0])</code>, but at least 1.
</li>
</ol>

<p>
A struct or array type has size zero if it contains no fields (or elements, respectively) that have a size greater than zero. Two distinct zero-size variables may have the same address in memory.
</p>
